<?xml version="1.0" encoding="utf-8"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2119 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC4949 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949.xml">
<!ENTITY RFC6347 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6347.xml">
<!ENTITY RFC6690 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6690.xml">
<!ENTITY RFC6749 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6749.xml">
<!ENTITY RFC6750 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6750.xml">
<!ENTITY RFC6819 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6819.xml">
<!ENTITY RFC6838 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6838.xml">
<!ENTITY RFC6920 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6920.xml">
<!ENTITY RFC7009 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7009.xml">
<!ENTITY RFC8949 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8949.xml">
<!ENTITY RFC7228 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7228.xml">
<!ENTITY RFC7231 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY RFC7252 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7252.xml">
<!ENTITY RFC7519 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7519.xml">
<!ENTITY RFC7521 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7521.xml">
<!ENTITY RFC7540 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7540.xml">
<!ENTITY RFC7591 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7591.xml">
<!ENTITY RFC7641 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7641.xml">
<!ENTITY RFC7662 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7662.xml">
<!ENTITY RFC7744 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7744.xml">
<!ENTITY RFC7959 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7959.xml">
<!ENTITY RFC8126 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8126.xml">
<!ENTITY RFC8152 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8152.xml">
<!ENTITY RFC8174 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8174.xml">
<!ENTITY RFC8252 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8252.xml">
<!ENTITY RFC8259 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8259.xml">
<!ENTITY RFC8392 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8392.xml">
<!ENTITY RFC8414 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8414.xml">
<!ENTITY RFC8446 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8446.xml">
<!ENTITY RFC8516 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.8516.xml">
<!ENTITY RFC8613 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.8613.xml">
<!ENTITY RFC8628 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8628.xml">
<!ENTITY RFC8693 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8693.xml">
<!ENTITY RFC8747 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.8747.xml">
<!ENTITY I-D.ietf-ace-oauth-params SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ace-oauth-params.xml">
<!ENTITY I-D.erdtman-ace-rpcc SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.erdtman-ace-rpcc.xml">
<!ENTITY I-D.ietf-tls-dtls13 SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-tls-dtls13.xml">
<!ENTITY I-D.ietf-quic-transport SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-quic-transport.xml">
<!ENTITY I-D.ietf-ace-dtls-authorize SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ace-dtls-authorize.xml">
<!ENTITY I-D.ietf-ace-oscore-profile SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ace-oscore-profile.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-ace-oauth-authz-44" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->

<title abbrev="ACE-OAuth">Authentication and Authorization for Constrained Environments (ACE) using the OAuth 2.0 Framework (ACE-OAuth)</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Ludwig Seitz" initials="L." surname="Seitz">
      <organization>Combitech</organization>

      <address>
        <postal>
          <street>Djäknegatan 31</street>
          <code>211 35</code> <city>Malmö</city>
          <country>Sweden</country>
       </postal>
        <email>ludwig.seitz@combitech.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Goeran Selander" initials="G." surname="Selander">
      <organization>Ericsson</organization>

      <address>
        <postal>
          <street>Faroegatan 6</street>
          <code>164 80</code> <city>Kista</city>
          <country>Sweden</country>
        </postal>
        <email>goran.selander@ericsson.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Erik Wahlstroem" initials="E." surname="Wahlstroem">
      <organization/>

      <address>
        <postal>
          <street></street>
          <code></code> <city></city>
          <country>Sweden</country>
        </postal>
        <email>erik@wahlstromstekniska.se</email>
      </address>
    </author>

    <author fullname="Samuel Erdtman" initials="S." surname="Erdtman">
      <organization>Spotify AB</organization>

      <address>
        <postal>
          <street>Birger Jarlsgatan 61, 4tr</street>
          <code>113 56</code> <city>Stockholm</city>
          <country>Sweden</country>
        </postal>
        <email>erdtman@spotify.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig">
      <organization>Arm Ltd.</organization>

      <address>
        <postal>
          <street></street>
          <code>6067</code> <city>Absam</city>
          <country>Austria</country>
        </postal>
        <email>Hannes.Tschofenig@arm.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>
    <date year="2021" />



    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
         in the current day for you. If only the current year is specified, xml2rfc will fill
	 in the current day and month for you. If the year is not the current one, it is necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the purpose of calculating the expiry date).  With drafts it is normally sufficient to specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>Security</area>

    <workgroup>ACE Working Group</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>CoAP, OAuth 2.0, Access Control, Authorization, Internet of Things</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>This specification defines a framework for authentication and
      authorization in Internet of Things (IoT) environments called ACE-OAuth.
      The framework is based on a set of building blocks including OAuth 2.0
      and the Constrained Application Protocol (CoAP), thus transforming a
      well-known and widely used authorization solution into a form suitable
      for IoT devices.  Existing specifications are used where possible, but
      extensions are added and profiles are defined to better serve the IoT use
      cases.
      </t>
    </abstract>
  </front>

<middle>

<!-- ***************************************************** -->

<section anchor="intro" title="Introduction">

   <t>Authorization is the process for granting approval to an entity to
   access a generic resource <xref target="RFC4949"/>. The authorization task
   itself can best be described as granting access to a requesting client, for
   a resource hosted on a device, the resource server (RS).  This exchange is
   mediated by one or multiple authorization servers (AS). Managing
   authorization for a large number of devices and users can be a complex task.
   </t>

   <t>While prior work on authorization solutions for the Web and for the mobile
   environment also applies to the Internet of Things (IoT) environment, many
   IoT devices are constrained, for example, in terms of processing
   capabilities, available memory, etc. For such devices the Constrained
   Application Protocol (CoAP) <xref target="RFC7252"/> can alleviate some
   resource concerns when used instead of HTTP to implement the communication
   flows of this specification.</t>

   <t><xref target="constraints"/> gives an overview of the constraints
   considered in this design, and a more detailed treatment of constraints can
   be found in <xref target="RFC7228"/>.  This design aims to accommodate
   different IoT deployments and thus a continuous range of device and network
   capabilities.  Taking energy consumption as an example: At one end there are
   energy-harvesting or  battery powered devices which have a tight power
   budget, on the other end there are mains-powered devices, and all levels in
   between.</t>

   <t>Hence, IoT devices may be very different in terms of available processing
   and message exchange capabilities and there is a need to support many
     different authorization use cases <xref target="RFC7744"/>.</t>

   <t>This specification describes a framework for authentication and authorization
   in constrained environments (ACE) built on re-use of OAuth 2.0
   <xref target="RFC6749"/>, thereby extending authorization to Internet of Things
   devices.  This specification contains the necessary building blocks
   for adjusting OAuth 2.0 to IoT environments.</t>

   <t>Profiles of this framework are available in separate specifications, such as
   <xref target="I-D.ietf-ace-dtls-authorize"/> or <xref target="I-D.ietf-ace-oscore-profile"/>. 
	   Such profiles may specify the use of the framework for a specific security protocol 
	   and the underlying transports for use in a specific deployment environment to improve interoperability.
   Implementations may claim conformance with a specific profile, whereby
   implementations utilizing the same profile interoperate, while
   implementations of different profiles are not expected to be interoperable.
   More powerful devices, such as mobile phones and tablets, may implement multiple
   profiles and will therefore be able to interact with a wider range of constrained devices. 
	   Requirements on profiles are described at contextually
   appropriate places throughout this specification, and also summarized in
   <xref target="app:profileRequirements"/>.
   </t>



</section>

<!-- ***************************************************** -->

<section anchor="terminology" title="Terminology">
  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in BCP 14 <xref
target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all capitals, as shown here.</t>

  <t>Certain security-related terms such as "authentication",
"authorization", "confidentiality", "(data) integrity", "message
authentication code", and "verify" are taken from <xref
target="RFC4949"/>.
  </t>

  <t>Since exchanges in this specification are described as RESTful protocol
    interactions, HTTP <xref target="RFC7231"/> offers useful terminology.
  </t>

  <t>Terminology for entities in the architecture is defined in OAuth
  2.0 <xref target="RFC6749"/> such as client (C), resource server (RS),
  and authorization server (AS).</t>

<t>Note that the term "endpoint" is used here following its OAuth
definition, which is to denote resources such as token and
introspection at the AS and authz-info at the RS (see <xref target="tokenAuthInfoEndpoint"/> for a definition of the authz-info endpoint).
The CoAP <xref target="RFC7252"/> definition, which is "An entity
participating in the CoAP protocol" is not used in this specification.</t>

<t>The specifications in this document is called the "framework" or "ACE framework".
When referring to "profiles of this framework" it refers to additional specifications that
define the use of this specification with concrete transport and communication
security protocols (e.g., CoAP over DTLS).
</t>

<t>The term "Access Information" is used for parameters, other than the access token, provided to the client by the AS to enable it to access the RS
(e.g. public key of the RS, profile supported by RS).</t>

<t>The term "Authorization Information" is used to denote all information,
including the claims of relevant access tokens, that an RS uses to determine whether an access request should be granted.</t>

</section>

<!-- ***************************************************** -->

<section anchor="overview" title="Overview">

  <t>This specification defines the ACE framework for authorization in the Internet
      of Things environment. It consists of a set of building blocks.</t>

  <t>
  The basic block is the OAuth 2.0 <xref target="RFC6749"/>
  framework, which enjoys widespread deployment.  Many IoT devices can support
  OAuth 2.0 without any additional extensions, but for certain constrained
  settings additional profiling is needed.
  </t>

  <t>Another building block is the lightweight web transfer protocol CoAP
  <xref target="RFC7252"/>, for those communication environments where HTTP is
  not appropriate.  CoAP typically runs on top of UDP, which further reduces
  overhead and message exchanges. While this specification defines extensions
  for the use of OAuth over CoAP, other underlying protocols are not prohibited
  from being supported in the future, such as HTTP/2 <xref target="RFC7540"/>,
  Message Queuing Telemetry Transport (MQTT) <xref target="MQTT5.0"/>,
  Bluetooth Low Energy (BLE) <xref target="BLE"/> and QUIC <xref
  target="I-D.ietf-quic-transport"/>.  Note that this document specifies
  protocol exchanges in terms of RESTful verbs such as GET and POST.
  Future profiles using protocols that do not support these verbs MUST
  specify how the corresponding protocol messages are transmitted instead.</t>

  
  <t>A third building block is the Concise Binary Object Representation
  (CBOR) <xref target="RFC8949"/>, for encodings where JSON
  <xref target="RFC8259"/> is not sufficiently compact.  CBOR is a binary
  encoding designed for small code and message size. Self-contained tokens
  and protocol message payloads are encoded in CBOR when CoAP is used. When CoAP
  is not used, the use of CBOR remains RECOMMENDED.
  </t>

  <t>A fourth building block is CBOR Object Signing and Encryption (COSE)
  <xref target="RFC8152"/>, which enables object-level layer security as an
  alternative or complement to transport layer security (DTLS
    <xref target="RFC6347"/> or TLS <xref target="RFC8446"/>). COSE is used to
    secure self-contained tokens such as proof-of-possession (PoP) tokens,
    which are an extension to the OAuth bearer tokens. The default token format
    is defined in CBOR Web Token (CWT) <xref target="RFC8392"/>.
    Application-layer security for CoAP using COSE can be provided with OSCORE
    <xref target="RFC8613"/>.</t>

  <t>With the building blocks listed above, solutions satisfying various
  IoT device and network constraints are possible.  A list of constraints is
  described in detail in <xref target="RFC7228"/> and a description
  of how the building blocks mentioned above relate to the various constraints
  can be found in <xref target="constraints"/>.</t>

  <t>Luckily, not every IoT device suffers from all constraints.  The ACE
  framework nevertheless takes all these aspects into account and allows
  several different deployment variants to co-exist, rather than mandating a
  one-size-fits-all solution.  It is important to cover the wide
  range of possible interworking use cases and the different requirements from
  a security point of view.  Once IoT deployments mature, popular deployment
  variants will be documented in the form of ACE profiles.</t>

  <section anchor="oauth2Overview" title="OAuth 2.0">
    <t>The OAuth 2.0 authorization framework enables a client to obtain
    scoped access to a resource with the permission of a resource
    owner.  Authorization information, or references to it, is passed between the nodes
    using access tokens.  These access tokens are issued to clients by an
    authorization server with the approval of the resource owner.  The client
    uses the access token to access the protected resources hosted by the
    resource server.</t>

    <t>A number of OAuth 2.0 terms are used within this specification:

      <list style="hanging">

        <t hangText="Access Tokens:"><vspace blankLines="0"/>
        Access tokens are credentials needed to access protected resources.  An
        access token is a data structure representing authorization permissions
        issued by the AS to the client.  Access tokens are generated by the AS
        and consumed by the RS.  The access token content is opaque
        to the client.
        <vspace blankLines="1"/>
        Access tokens can have different formats, and various methods
        of utilization e.g., cryptographic properties) based on the security
        requirements of the given deployment.
        <vspace blankLines="1"/>
	</t>

	<t hangText="Introspection:"><vspace blankLines="0"/>
	Introspection is a method for a resource server or potentially a client,
	to query the authorization server for the active state and content of a
	received access token.  This is particularly useful in those cases where
	the authorization decisions are very dynamic and/or where the received
	access token itself is an opaque reference rather than a self-contained
	token.  More information about introspection in OAuth 2.0 can be
	found in <xref target="RFC7662"/>.
	</t>
	
	<t hangText="Refresh Tokens:"><vspace blankLines="0"/>
	Refresh tokens are credentials used to obtain access tokens.
	Refresh tokens are issued to the client by the authorization
	server and are used to obtain a new access token when the current
	access token expires, or to obtain additional access tokens with
	identical or narrower scope (such access tokens may have a shorter
	lifetime and fewer permissions than authorized by the resource owner).
	Issuing a refresh token is optional at the discretion of the
	authorization server.  If the authorization server issues a refresh
	token, it is included when issuing an access token (i.e., step (B) in
	<xref target="fig:protocolFlow"/>).
	<vspace blankLines="1"/>
	A refresh token in OAuth 2.0 is a string representing the authorization
	granted	to the client by the resource owner.  The string is usually
	opaque to the client.  The token denotes an identifier used to retrieve
	the authorization information.  Unlike access tokens, refresh
	tokens are intended for use only with authorization servers and
	are never sent to resource servers.  In this framework, refresh
	tokens are encoded in binary instead of strings, if used.
	<vspace blankLines="1"/></t>
	
	<t hangText="Proof of Possession Tokens:"><vspace blankLines="0"/>
        A token may be bound to a cryptographic key,  which is then used
	to bind the token to a request authorized by the token.  Such tokens
	are called proof-of-possession tokens (or PoP tokens).
        <vspace blankLines="1"/>
        The proof-of-possession security concept used here assumes that
	the AS acts as a trusted third party that binds keys to tokens.
	In the case of access tokens, these so called PoP keys are then used by
	the client to demonstrate the possession of the secret to the RS when
	accessing the resource.  The RS, when receiving an access token, needs
	to verify that the key used by the client matches the one bound to the
	access token.  When this specification uses the term "access token" it
	is assumed to be a PoP access token unless specifically stated
	otherwise.

        <vspace blankLines="1"/>
        The key bound to the token (the PoP key) may use either symmetric or
	asymmetric cryptography.  The appropriate choice of the kind of
	cryptography depends on the constraints of the IoT devices as well as
	on the security requirements of the use case.
	<vspace blankLines="1"/>
        <list style="hanging">

          <t hangText="Symmetric PoP key:"><vspace blankLines="0"/>
              The AS generates a random symmetric PoP key.  The key is either
              stored to be returned on introspection calls or included in the
	      token.  Either the whole token or only the key MUST be encrypted
	      in the latter case.  The PoP key is also returned to
	      client together with the token.<vspace blankLines="1"/>

          </t>
          <t hangText="Asymmetric PoP key:"><vspace blankLines="0"/>
          An asymmetric key pair is generated by the client and the public key
	  is sent to the AS (if it does not already have knowledge of the
	  client's public key).  Information about the public key, which is the
	  PoP key in this case, is either stored to be returned on 
	  introspection calls or included inside the token and sent
	  back to the client.  The resource server consuming the token can
	  identify the public key from the information in the token, which
	  allows the client to use the corresponding private key for the
	  proof of possession.
          </t>
        </list>

        <vspace blankLines="1"/> The token is either a simple reference,
	or a structured information object (e.g., CWT <xref target="RFC8392"/>)
	protected by a cryptographic wrapper (e.g., COSE <xref
	target="RFC8152"/>).  The choice of PoP key does not necessarily imply
	a specific credential type for the integrity protection of the
	token.<vspace blankLines="1"/>
      </t>

      <t hangText="Scopes and Permissions:"><vspace blankLines="0"/>
         In OAuth 2.0, the client specifies the type of permissions it is
         seeking to obtain (via the scope parameter) in the access token
	 request.  In turn, the AS may use the scope response parameter to
	 inform the client of the scope of the access token issued.  As the
	 client could be a constrained device as well, this specification
	 defines the use of CBOR encoding, see <xref
	 target="oauthProfile"/>, for such requests and responses.
         <vspace blankLines="1"/>
         The values of the scope parameter in OAuth 2.0 are expressed as a list
	 of space-delimited, case-sensitive strings, with a semantic that is
	 well-known to the AS and the RS.
         <!-- <vspace blankLines="1"/>
         A common misconception is that the requested scopes must
         also be included in the returned access token, but the requested scopes
         are only metadata about the token.  They could also be packaged in the
         token as a separate attribute, but it's more common to assert the
         requested and authorized access using claims within the access token.
         <vspace blankLines="1"/>-->
         More details about the concept of scopes is found under Section 3.3 in
         <xref target="RFC6749" />.<vspace blankLines="1"/>
      </t>


      <t hangText="Claims:"><vspace blankLines="0"/>

      Information carried in the access token or returned from introspection, called claims, is in the form of
      name-value pairs.  An access token may, for example, include a claim
      identifying the AS that issued the token (via the "iss" claim) and
      what audience the access token is intended for (via the "aud" claim).
	The audience of an access token can be a specific resource or one or
	many resource servers.  The resource owner policies influence what
	claims are put into the access token by the authorization server.
        <vspace blankLines="1"/>
        While the structure and encoding of the access token varies throughout
        deployments, a standardized format has been defined with the JSON Web
        Token (JWT) <xref target="RFC7519"/> where claims are encoded as a
	JSON object.  In <xref target="RFC8392"/> the CBOR Web Token (CWT)
	has been defined as an equivalent format using CBOR encoding.
	<vspace blankLines="1"/>
      </t>
      
      <t hangText="The token and introspection Endpoints:"><vspace blankLines="0"/>
      The AS hosts the token endpoint that allows a client to request access
      tokens. The client makes a POST request to the token endpoint on the AS
      and receives the access token in the response (if the request was
      successful).
      <vspace blankLines="0"/>
      In some deployments, a token introspection endpoint is provided by
      the AS, which can be used by the RS and potentially the client, if they
      need to request additional information regarding a received access
      token.  The requesting entity makes a POST request to the introspection
      endpoint on the AS and receives information about the access token in
      the response. (See "Introspection" above.)
      <vspace blankLines="1"/>
        </t>

      
    </list>
  </t>
</section>

<section anchor="coap" title="CoAP">

    <t>
    CoAP is an application-layer protocol similar to HTTP, but specifically
    designed for constrained environments.  CoAP typically uses
    datagram-oriented transport, such as UDP, where reordering and loss
    of packets can occur.  A security solution needs to take the latter aspects
    into account.</t>

    <t>While HTTP uses headers and query strings to convey additional
    information about a request, CoAP encodes such information into header
    parameters called 'options'.</t>

    <t>CoAP supports application-layer fragmentation of the CoAP payloads
    through blockwise transfers <xref target="RFC7959"/>.  However,
    blockwise transfer does not increase the size limits of CoAP options,
    therefore data encoded in options has to be kept small.
 </t>

  <t>Transport layer security for CoAP can be provided by DTLS or TLS
  <xref target="RFC6347"/><xref target="RFC8446"/>
  <xref target="I-D.ietf-tls-dtls13"/>.
    CoAP defines a number of proxy operations that require transport layer
    security to be terminated at the proxy. One approach for protecting CoAP communication
    end-to-end through proxies, and also to support security for CoAP over
    a different transport in a uniform way, is to provide security at the application
    layer using an object-based security mechanism such as COSE <xref target="RFC8152"/>.
  </t>

  <t>
    One application of COSE is OSCORE
    <xref target="RFC8613"/>, which provides end-to-end confidentiality,
    integrity and replay protection, and a secure binding between CoAP request
    and response messages. In OSCORE, the CoAP messages are wrapped in COSE
    objects and sent using CoAP.
  </t>

  <t>In this framework the use of CoAP as replacement for HTTP is RECOMMENDED
  for use in constrained environments.  For communication security this
  framework does not make an explicit protocol recommendation, since the choice
  depends on the requirements of the specific application.  DTLS
  <xref target="RFC6347"/>, <xref target="I-D.ietf-tls-dtls13"/> and OSCORE
  <xref target="RFC8613"/> are mentioned as examples, other protocols fulfilling
  the requirements from <xref target="minimalCommSecReq"/> are also
  applicable.</t>

</section>
</section>


<!-- ***************************************************** -->
<section anchor="specs" title="Protocol Interactions">

<t>
    The ACE framework is based on the OAuth 2.0 protocol interactions using
    the token endpoint and optionally the introspection endpoint.
    A client obtains an access token, and optionally a refresh token, from an
    AS using the token endpoint and subsequently presents the access token to
    an RS to gain access to a protected resource. In most deployments the RS can
    process the access token locally, however in some cases the RS may present
    it to the AS via the introspection endpoint to get fresh information.
    These interactions are shown in <xref target="fig:protocolFlow"/>.  An
    overview of various OAuth concepts is provided in <xref
    target="oauth2Overview"/>.
</t>

<t><figure align="center" anchor="fig:protocolFlow"
           title="Basic Protocol Flow.">
  <artwork align="left"><![CDATA[
+--------+                               +---------------+
|        |---(A)-- Token Request ------->|               |
|        |                               | Authorization |
|        |<--(B)-- Access Token ---------|    Server     |
|        |    + Access Information       |               |
|        |    + Refresh Token (optional) +---------------+
|        |                                      ^ |
|        |            Introspection Request  (D)| |
| Client |                         Response     | |(E)
|        |            (optional exchange)       | |
|        |                                      | v
|        |                               +--------------+
|        |---(C)-- Token + Request ----->|              |
|        |                               |   Resource   |
|        |<--(F)-- Protected Resource ---|    Server    |
|        |                               |              |
+--------+                               +--------------+
  ]]></artwork>
</figure></t>

<t>
  <list style="hanging">
    <t hangText="Requesting an Access Token (A):"><vspace blankLines="0"/>
      The client makes an access token request to the token endpoint at the AS.
      This framework assumes the use of PoP access tokens (see <xref
      target="oauth2Overview"/> for a short description) wherein the AS binds a
      key to an access token.  The client may include permissions it seeks to
      obtain, and information about the credentials it wants to use for
      proof-of-possession (e.g., symmetric/asymmetric cryptography or a
      reference to a specific key) of the access token.<vspace blankLines="1"/>
    </t>

    <t hangText="Access Token Response (B):"><vspace blankLines="0"/>
      If the request from the client has been successfully verified, 
      authenticated, and authorized, the AS returns an access token and optionally a refresh
      token. Note that only certain grant types support refresh tokens.  The AS
      can also return additional parameters, referred to as "Access
      Information".  In addition to the response parameters defined by OAuth
      2.0 and the PoP access token extension, this framework defines parameters
      that can be used to inform the client about capabilities of the RS, e.g.
      the profile the RS supports.  More information about these parameters
      can be found in <xref target="tokenParams"/>.
      <vspace blankLines="1"/>
    </t>

    <t hangText="Resource Request (C):"><vspace blankLines="0"/>
      The client interacts with the RS to request access to the protected
      resource and provides the access token.  The protocol to use
      between the client and the RS is not restricted to CoAP. HTTP, HTTP/2
      <xref target="RFC7540"/>, QUIC <xref target="I-D.ietf-quic-transport"/>,
      MQTT <xref target="MQTT5.0"/>, Bluetooth Low Energy <xref target="BLE"/>,
      etc., are also viable candidates.
      <vspace blankLines="1"/>
      Depending on the device limitations and the selected protocol, this
      exchange may be split up into two parts:

<list style="empty">
  <t>(1) the client sends the access token containing, or referencing, the
  authorization information to the RS, that will be used for subsequent
  resource requests by the client, and </t>

  <t>(2) the client makes the resource access request, using the communication
  security protocol and other Access Information obtained from the AS.</t>
</list>

      <vspace blankLines="1"/>
      The client and the RS mutually authenticate using the security protocol
      specified in the profile (see step B) and the keys obtained in the access
      token or the Access Information.  The RS verifies that the token is
      integrity protected and originated by the AS. It then compares the claims
      contained in the access token with the resource request. If the RS is
      online, validation can be handed over to the AS using token introspection
      (see messages D and E) over HTTP or CoAP.<vspace blankLines="1"/>
    </t>

    <t hangText="Token Introspection Request (D):"><vspace blankLines="0"/>
      A resource server may be configured to introspect the access token by
      including it in a request to the introspection endpoint at that AS.
      Token introspection over
      CoAP is defined in <xref target="introspectionEndpoint"/> and for HTTP in
      <xref target="RFC7662"/>.
      <vspace blankLines="1"/>
      Note that token introspection is an optional step and can be omitted if
      the token is self-contained and the resource server is prepared to
      perform the token validation on its own.<vspace blankLines="1"/>
    </t>

    <t hangText="Token Introspection Response (E):"><vspace blankLines="0"/>
      The AS validates the token and returns the most recent parameters, such
      as scope, audience, validity etc. associated with it back to the RS.  The
      RS then uses the received parameters to process the request to either
      accept or to deny it.<vspace blankLines="1"/>
    </t>

    <t hangText="Protected Resource (F):"><vspace blankLines="0"/>
      If the request from the client is authorized, the RS fulfills the request
      and returns a response with the appropriate response code.  The RS uses
      the dynamically established keys to protect the response, according to
      the communication security protocol used.
    </t>
  </list>
</t>

<t>The OAuth 2.0 framework defines a number of "protocol flows" via grant types, which have been extended
further with extensions to OAuth 2.0 (such as <xref target="RFC7521"/> and <xref target="RFC8628"/>).
What grant type works best depends on the usage scenario and <xref target="RFC7744"/> describes many different IoT use cases but there are two grant types that cover a majority of these scenarios, namely the Authorization Code Grant (described in Section 4.1 of <xref target="RFC7521"/>) and the Client Credentials Grant (described in Section 4.4 of <xref target="RFC7521"/>). The Authorization Code Grant is a good fit for use with apps running on smart phones and tablets that request access to IoT devices, a common scenario in the smart home environment, where users need to go through an authentication and authorization phase (at least during the initial setup phase). The native apps guidelines described in <xref target="RFC8252"/> are applicable to this use case. The Client Credential Grant is a good fit for use with IoT devices where the OAuth client itself is constrained. In such a case, the resource owner has pre-arranged access rights for the client with the authorization server, which is often accomplished using a commissioning tool.</t>

<t>
    The consent of the resource owner, for giving a client access to a protected
    resource, can be provided dynamically as in the traditional OAuth flows, or it
    could be pre-configured by the resource owner as authorization policies at
    the AS, which the AS evaluates when a token request arrives.  The resource
    owner and the requesting party (i.e., client owner) are not shown in <xref
    target="fig:protocolFlow"/>.
</t>

<t>
  This framework supports a wide variety of communication security mechanisms
  between the ACE entities, such as client,
  AS, and RS. It is assumed that the client has been
  registered (also called enrolled or onboarded) to an AS using a mechanism defined outside the scope of this document.
  In practice, various techniques for onboarding have been used, such as factory-based provisioning or the use of
  commissioning tools. Regardless of the onboarding technique, this provisioning procedure implies that the client and the AS exchange credentials and
  configuration parameters.  These credentials are used to mutually authenticate each other and to protect messages exchanged between the client and the AS.</t>

 <t>It is also assumed that the RS has been registered with the AS, potentially in a similar way as the client has been registered with the AS.
 Established keying material between the AS and the RS allows the AS to apply
 cryptographic protection to the access token to ensure that its content cannot
 be modified, and if needed, that the content is confidentiality protected. Confidentiality protection of the access token content would be provided on top of 
 confidentiality protection via a communication security protocol. </t>

<t>The keying material necessary for establishing communication security
  between C and RS is dynamically established as part of the protocol described
  in this document.
</t>

<t>
    At the start of the protocol, there is an optional discovery step where the
    client discovers the resource server and the resources this server hosts.
    In this step, the client might also determine what permissions are needed to
    access the protected resource.  A generic procedure is described in <xref
    target="asDiscovery"/>; profiles MAY define other procedures for
    discovery.</t>

    <t>In Bluetooth Low Energy, for example, advertisements are broadcast by
    a peripheral, including information about the primary services.  In CoAP,
    as a second example, a client can make a request to "/.well-known/core" to
    obtain information about available resources, which are returned in a
    standardized format as described in <xref target="RFC6690"/>.
</t>
</section>



<!-- ***************************************************** -->

<section anchor="oauthProfile" title="Framework">

  <t>The following sections detail the profiling and extensions of OAuth 2.0
  for constrained environments, which constitutes the ACE framework.
  </t>

  <t>
    <list style="hanging">
      <t hangText="Credential Provisioning"><vspace blankLines="0"/>
        In constrained environments it cannot be assumed that the client and the RS
        are part of a common key infrastructure. Therefore, the AS provisions
	credentials and associated information to allow mutual authentication
	between the client and the RS. The resulting security association between the client
	and the RS may then also be used to bind these credentials to the
	access tokens the client uses.
        <vspace blankLines="1"/>
      </t>

      <t hangText="Proof-of-Possession"><vspace blankLines="0"/>
        The ACE framework, by default, implements proof-of-possession for
	access tokens, i.e., that the token holder can prove being a holder of
	the key bound to the token.  The binding is provided by the "cnf" claim
	<xref target="RFC8747"/> indicating what key is used for
	proof-of-possession. If a client needs to submit a new access token,
	e.g., to obtain additional access rights, they can request
	that the AS binds this token to the same key as the previous one.
	<vspace blankLines="1"/>
      </t>

      <t hangText="ACE Profiles"><vspace blankLines="0"/>
        The client or RS may be limited in the encodings or protocols it
        supports.  To support a variety of different deployment settings,
        specific interactions between client and RS are defined in an ACE
        profile.  In ACE framework the AS is expected to manage the matching
	of compatible profile choices between a client and an RS.  The AS
	informs the client of the selected profile using the "ace_profile"
	parameter in the token response.
      </t>
    </list>
  </t>

  <t>OAuth 2.0 requires the use of TLS both to protect the communication
  between AS and client when requesting an access token; between client and RS
  when accessing a resource and between AS and RS if introspection is used.
  In constrained settings TLS is not always feasible, or desirable.
  Nevertheless it is REQUIRED that the communications named above are
  encrypted, integrity protected and protected against message replay.  It is
  also REQUIRED that the communicating endpoints perform mutual authentication.
  Furthermore it MUST be assured that responses are bound to the requests in
  the sense that the receiver of a response can be certain that the response
  actually belongs to a certain request.  Note that setting up such a secure
  communication may require some unprotected messages to be exchanged first
  (e.g. sending the token from the client to the RS).</t>

  <t>Profiles MUST specify a communication security protocol between client
  and RS that provides the features required above.  Profiles MUST specify a
  communication security protocol RECOMMENDED to be used between client and AS
  that provides the features required above.  Profiles MUST specify for 
  introspection a communication security protocol RECOMMENDED to be used 
  between RS and AS that provides the features required above.  These 
  recommendations enable interoperability between different implementations
  without the need to define a new profile if the communication between C and
  AS, or between RS and AS, is protected with a different security protocol
  complying with the security requirements above.</t>

  <t>In OAuth 2.0 the communication with the Token and the Introspection
  endpoints at the AS is assumed to be via HTTP and may use Uri-query
  parameters.  When profiles of this framework use CoAP instead, it is 
  REQUIRED to use of the following alternative instead of Uri-query
  parameters: The sender (client or RS) encodes the parameters of its request
  as a CBOR map and submits that map as the payload of the POST request.
  The CBOR encoding for a number of  OAuth 2.0 parameters is specified in this
  document, if a profile needs to use other OAuth 2.0 parameters with CoAP it
  MUST specify their CBOR encoding.</t>
  
  <t>Profiles that use CBOR encoding of protocol message parameters at the
  outermost encoding layer MUST use the content format 'application/ace+cbor'.
  If CoAP is used for communication, the Content-Format MUST be abbreviated
  with the ID: 19 (see <xref target="IANAcoapContentFormat"/>).</t>

  <t>The OAuth 2.0 AS uses a JSON structure in the payload of its responses
  both to client and RS.  If CoAP is used, it is REQUIRED to use
  CBOR <xref target="RFC8949"/> instead of JSON.  Depending on the profile,
  the CBOR payload MAY be enclosed in a non-CBOR cryptographic wrapper.</t>

<section anchor="asDiscovery" title="Discovering Authorization Servers">
  <t>C must discover the AS in charge of RS to determine where to request the
access token. To do so, C must 1. find out the AS URI to which the token
request message must be sent and 2. MUST validate that the AS with this
URI is authorized to provide access tokens for this RS.
  </t>
  
  <t> In order to determine the AS URI, C MAY send an initial Unauthorized
Resource Request message to RS.  RS then denies the request and sends
the address of its AS back to C (see <xref target="rreq"/>). How C validates the
AS authorization is not in scope for this document. C may, e.g., ask
its owner if this AS is authorized for this RS. C may also use a
mechanism that addresses both problems at once (e.g. by querying a dedicated secure service provided by the client owner) .</t>

</section><!--AS Discovery -->

  <section anchor="rreq" title="Unauthorized Resource Request Message">
    <t>An Unauthorized Resource Request message is a request for any
    resource hosted by RS for which the client does not have authorization granted. RSes MUST
    treat any request for a protected resource as an Unauthorized Resource
    Request message when any of the following hold:

      <list style="symbols">
	<t>The request has been received on an unsecured channel.</t>
	<t>The RS has no valid access token for the sender of the request
	regarding the requested action on that resource.</t>
	<t>The RS has a valid access token for the sender of the request, but
	that token does not authorize the requested action on the requested
	resource.</t>
      </list>
    </t>

    <t>Note: These conditions ensure that the RS can handle requests autonomously
    once access was granted and a secure channel has been established between C
    and RS. The authz-info endpoint, as part of the process for authorizing
    to protected resources, is not itself a protected resource and MUST NOT be
    protected as specified above (cf.  <xref
    target="tokenAuthInfoEndpoint"/>).</t>

    <t>Unauthorized Resource Request messages MUST be denied with an "unauthorized_client"
    error response. In this response, the Resource Server SHOULD provide proper
    "AS Request Creation Hints" to enable the client to request an access token
    from RS's AS as described in <xref target="asInfo"/>.</t>

    <t>The handling of all client requests (including unauthorized ones)
    by the RS is described in <xref target="requestC2RS"/>.</t>   
  </section><!-- Unauthorized Request -->

  <section anchor="asInfo" title="AS Request Creation Hints">
    <t>The "AS Request Creation Hints" message is sent by an RS as a response to
    an Unauthorized Resource Request message (see <xref target="rreq"/>) to help
    the sender of the Unauthorized Resource Request message acquire a valid
    access token. The "AS Request Creation Hints" message is a CBOR or JSON map,
    with an OPTIONAL element "AS" specifying an absolute URI (see Section 4.3
    of <xref target="RFC3986"/>) that identifies the appropriate AS for the
    RS.</t>
    
    <t>The message can also contain the following OPTIONAL parameters:
    <list style="symbols">
      <t>A "audience" element contains an identifier the client
      should request at the AS, as suggested by the RS. With this parameter,
      when included in the access token request to the AS, the AS is able to 
      restrict the use of access token to specific RSs. See 
      <xref target="audience"/> for a discussion of this parameter.</t>
      <t>A "kid" element containing the key identifier of a key used in
      an existing security association between the client and the RS.
      The RS expects the client to request an access token bound to this
      key, in order to avoid having to re-establish the security
      association.</t>
      <t>A "cnonce" element containing a client-nonce. See <xref
      target="cnonceParam"/>.</t>
      <t>A "scope" element containing the suggested scope that the client
      should request towards the AS.</t>
    </list></t>
    
    <t><xref target="fig:asinfo"/> summarizes the parameters that may be
    part of the "AS Request Creation Hints".

      <figure align="center" anchor="fig:asinfo"
	      title="AS Request Creation Hints">
      <artwork align="left"><![CDATA[
        /-----------+----------+---------------------\
        | Name      | CBOR Key | Value Type          |
        |-----------+----------+---------------------|
        | AS        |     1    | text string         |
        | kid       |     2    | byte string         |
        | audience  |     5    | text string         |
        | scope     |     9    | text or byte string |
        | cnonce    |    39    | byte string         |
        \-----------+----------+---------------------/
      ]]></artwork></figure></t>

    <t>Note that the schema part of the AS parameter may need to be
    adapted to the security protocol that is used between the client
    and the AS. Thus the example AS value "coap://as.example.com/token"
    might need to be transformed to "coaps://as.example.com/token".
    It is assumed that the client can determine the correct schema part on
    its own depending on the way it communicates with the AS.</t>      
      
    <t><xref target="fig:as-info-payload"/> shows an example for an "AS
    Request Creation Hints" message payload using CBOR <xref target="RFC8949"/>
    diagnostic notation, using the parameter names instead of the CBOR keys for
    better human readability.</t>

    <figure title="AS Request Creation Hints payload example"
	    anchor="fig:as-info-payload"><artwork><![CDATA[
    4.01 Unauthorized
    Content-Format: application/ace+cbor
    Payload :
    {
     "AS" : "coaps://as.example.com/token",
     "audience" : "coaps://rs.example.com"
     "scope" : "rTempC",
     "cnonce" : h'e0a156bb3f'
    }
]]></artwork></figure>

    <t>In the example above, the response parameter "AS" points the receiver of
    this message to the URI "coaps://as.example.com/token" to request access
    tokens.  The RS sending this response uses an internal clock
    that is not synchronized with the clock of the AS.  Therefore, it
    can not reliably verify the expiration time of access tokens it receives.
    To ensure a certain level of access token freshness nevertheless, the RS has
    included a <spanx style="verb">cnonce</spanx> parameter (see <xref
    target="cnonceParam"/>) in the response. (The hex-sequence of the cnonce parameter 
    is encoded in CBOR-based notation in this example.)</t>

    <t><xref target="fig:as-info-cbor"/> illustrates the mandatory to use
    binary encoding of the message payload shown in
    <xref target="fig:as-info-payload"/>.</t>

    <figure title="AS Request Creation Hints example encoded in CBOR"
	    anchor="fig:as-info-cbor"><artwork><![CDATA[
a4                                   # map(4)
   01                                # unsigned(1) (=AS)
   78 1c                             # text(28)
      636f6170733a2f2f61732e657861
      6d706c652e636f6d2f746f6b656e   # "coaps://as.example.com/token"
   05                                # unsigned(5) (=audience)
   76                                # text(22)
      636f6170733a2f2f72732e657861
      6d706c652e636f6d               # "coaps://rs.example.com"
   09                                # unsigned(9) (=scope)
   66                                # text(6)
      7254656d7043                   # "rTempC"
   18 27                             # unsigned(39) (=cnonce)
   45                                # bytes(5)
      e0a156bb3f                     # 
      ]]></artwork></figure>

    <section anchor="cnonceParam" title="The Client-Nonce Parameter">
      <t>If the RS does not synchronize its clock with the AS, it could be
      tricked into accepting old access tokens, that are either expired or have
      been compromised.  In order to ensure some level of token freshness
      in that case, the RS can use the "cnonce" (client-nonce) parameter.
      The processing requirements for this parameter are as follows:
      <list style="symbols">
	<t>An RS sending a "cnonce" parameter in an "AS Request Creation
	Hints" message MUST store information to validate that a given
	cnonce is fresh.  How this is implemented internally is out of scope
	for this specification.  Expiration of client-nonces should be based
	roughly on the time it would take a client to obtain an access token
	after receiving the "AS Request Creation Hints" message, with some
	allowance for unexpected delays.</t>
	
	<t>A client receiving a "cnonce" parameter in an "AS Request Creation
	Hints" message MUST include this in the parameters when requesting
	an access token at the AS, using the "cnonce" parameter from
	<xref target="cnonceParamToken"/>.</t>
	
	<t>If an AS grants an access token request containing a "cnonce"
	parameter, it MUST include this value in the access token, using the
	"cnonce" claim specified in <xref target="accessToken"/>.</t>

	<t>An RS that is using the client-nonce mechanism and that receives an
	access token MUST verify that this token contains a cnonce claim, with
	a client-nonce value that is fresh according to the information stored
	at the first step above.  If the cnonce claim is not present or if the
	cnonce claim value is not fresh, the RS MUST discard the access token.  
	If this was an interaction with the authz-info endpoint the RS MUST also
	respond with an error message using a response code equivalent to the
	CoAP code 4.01 (Unauthorized).</t>	
      </list>
      </t>
    </section>
  </section><!--AS information-->

<section anchor="authorizationGrants" title="Authorization Grants">
  <t>To request an access token, the client obtains authorization from the
  resource owner or uses its client credentials as a grant.  The authorization
  is expressed in the form of an authorization grant.</t>

  <t>The OAuth framework <xref target="RFC6749"/> defines four grant types. The grant types can
  be split up into two groups, those granted on behalf of the resource
  owner (password, authorization code, implicit) and those for the client
  (client credentials). Further grant types have been added later, such as <xref target="RFC7521"/> defining an assertion-based authorization grant.</t>

  <t>The grant type is selected depending on the use case.  In cases where
  the client acts on behalf of the resource owner, the authorization code
  grant is recommended.  If the client acts on behalf of the resource owner,
  but does not have any display or has very limited interaction possibilities, it is
  recommended to use the device code grant defined in
  <xref target="RFC8628"/>.  In cases where the client
  acts autonomously the client credentials grant is recommended.</t>

  <t>For details on the different grant types, see section 1.3 of <xref
  target="RFC6749"/>. The OAuth 2.0 framework provides an extension
  mechanism for defining additional grant types, so profiles of this framework
  MAY define additional grant types, if needed.</t>
</section> <!--Grants-->

<section anchor="clientCredentials" title="Client Credentials">
  <t>Authentication of the client is mandatory independent of the grant type
  when requesting an access token from the token endpoint. In the case of
  the client credentials grant type, the authentication and grant coincide.</t>

  <t>Client registration and provisioning of client credentials to the client
  is out of scope for this specification.</t>

  <t>The OAuth framework defines one client credential type in section 2.3.1 of
  <xref target="RFC6749"/>: client id and client secret. <xref
  target="I-D.erdtman-ace-rpcc"/> adds raw-public-key and pre-shared-key to the
  client credentials types.  Profiles of this framework MAY extend with
  an additional client credentials type using client certificates.</t>
</section> <!--Client Credentials-->

<section anchor="ASAuthentication" title="AS Authentication">
  <t>The client credential grant does not, by default, authenticate the AS that the client
  connects to. In classic OAuth, the AS is authenticated with a TLS server
  certificate.</t>

  <t>Profiles of this framework MUST specify how clients authenticate the AS
  and how communication security is implemented. By default, server side TLS
  certificates, as defined by OAuth 2.0, are required.</t>
</section> <!--AS Authentication-->

<section anchor="authorizeEndpoint" title="The Authorization Endpoint">
  <t>The OAuth 2.0 authorization endpoint is used to interact with the resource owner
  and obtain an authorization grant, in certain grant flows.  The primary use
  case for the ACE-OAuth framework is for machine-to-machine interactions that do not involve
  the resource owner in the authorization flow; therefore, this endpoint is
  out of scope here.  Future profiles may define constrained adaptation
  mechanisms for this endpoint as well.  Non-constrained clients interacting
  with constrained resource servers can use the specification in section 3.1
  of <xref target="RFC6749"/> and the attack countermeasures suggested in
  section 4.2 of <xref target="RFC6819"/>.</t>
</section> <!--The 'Authorize' Endpoint-->

<section anchor="tokenEndpoint" title="The Token Endpoint">
  <t>In standard OAuth 2.0, the AS provides the token endpoint for submitting
  access token requests.  This framework extends the functionality of the
  token endpoint, giving the AS the possibility to help the client and RS to
  establish shared keys or to exchange their public keys.  Furthermore,
  this framework defines encodings using CBOR, as a substitute for JSON.</t>

  <t>The endpoint may also be exposed over HTTPS as in classical OAuth or
  even other transports.  A profile MUST define the details of the mapping
  between the fields described below, and these transports.  If HTTPS is used,
  the semantics of Sections 4.1.3 and 4.1.4 of the OAuth 2.0 specification MUST
  be followed (with additions as described below). If the CoAP is some other
  transport with CBOR payload format is supported, the semantics described in
  this section MUST be followed.</t> 

   <t>For the AS to be able to issue a token, the client MUST be authenticated
  and present a valid grant for the scopes requested.  Profiles of this
  framework MUST specify how the AS authenticates the client and how the
  communication between client and AS is protected, fulfilling the
  requirements specified in <xref target="oauthProfile"/>.</t>

  <t>The default name of this endpoint in an url-path SHOULD be '/token'.
  However, implementations are not required to use this name and can define
  their own instead.</t>

  <t>The figures of this section use CBOR diagnostic
  notation without the integer abbreviations for the parameters or their
  values for illustrative purposes. Note that implementations MUST use the
  integer abbreviations and the binary CBOR encoding, if the CBOR encoding is used.</t>

  <section anchor="tokenRequest" title="Client-to-AS Request">
    <t>The client sends a POST request to the token endpoint
    at the AS. The profile MUST specify how the communication is protected.
    The content of the request consists of the parameters specified
    in the relevant subsection of section 4 of the OAuth 2.0 specification
    <xref target="RFC6749"/>, depending on the grant type, with the following
    exceptions and additions:

    <list style="symbols">
      <t>The parameter "grant_type" is OPTIONAL in the context of this
      framework (as opposed to REQUIRED in RFC6749).  If that parameter is
      missing, the default value "client_credentials" is implied.</t>
      <t>The "audience" parameter from <xref target="RFC8693"/> is OPTIONAL to
      request an access token bound to a specific audience.</t>
      <t>The "cnonce" parameter defined in <xref target="cnonceParamToken"/> is
      REQUIRED if the RS provided a client-nonce in the "AS Request Creation
      Hints" message <xref target="asInfo"/></t>
      <t>The "scope" parameter MAY be encoded as a byte string instead of
      the string encoding specified in section 3.3 of <xref target="RFC6749"/>,
      in order allow compact encoding of complex scopes.  The syntax of
      such a binary encoding is explicitly not specified here and left
      to profiles or applications. Note specifically that a binary encoded
      scope does not necessarily use the space character '0x20' to delimit
      scope-tokens.</t>
      <t>The client can send an empty (null value) "ace_profile" parameter to
      indicate that it wants the AS to include the "ace_profile" parameter in
      the response.  See <xref target="paramProfile"/>.</t>
      <t>A client MUST be able to use the parameters from <xref
      target="I-D.ietf-ace-oauth-params"/> in an access token request to the
      token endpoint and the AS MUST be able to process these additional
      parameters.</t>
    </list></t>

    <t>The default behavior, is that the AS generates a symmetric
    proof-of-possession key for the client. In order to use an asymmetric key
    pair or to re-use a key previously established with the RS, the client is
    supposed to use the "req_cnf" parameter from <xref
    target="I-D.ietf-ace-oauth-params"/>.
    </t>
    
    <t>If CoAP is used then these parameters MUST be provided in a CBOR map,
    see <xref target="fig:cborTokenParameters"/>.</t>

    <t>When HTTP is used as a transport then the client makes a 
    request to the token endpoint, the parameters MUST be encoded as defined 
    in Appendix B of <xref target="RFC6749"/>.</t>

    <t>The following examples illustrate different types of requests
    for proof-of-possession tokens. </t>

    <t><xref target="fig:symmATreq"/> shows a request for a token
    with a symmetric proof-of-possession key.  The content is displayed in
    CBOR diagnostic notation, without abbreviations for better readability.
    
    <figure align="center" anchor="fig:symmATreq"
            title="Example request for an access token bound to a
		   symmetric key.">
        <artwork align="left"><![CDATA[
Header: POST (Code=0.02)
Uri-Host: "as.example.com"
Uri-Path: "token"
Content-Format: "application/ace+cbor"
Payload:
{
  "client_id" : "myclient",
  "audience" : "tempSensor4711"
}
        ]]></artwork>
    </figure></t>

    <t><xref target="fig:asymmATreq"/> shows a request for a token with an
    asymmetric proof-of-possession key.  Note that in this example OSCORE
    <xref target="RFC8613"/> is used
    to provide object-security, therefore the Content-Format is
    "application/oscore" wrapping the "application/ace+cbor" type content.
    The OSCORE option has a decoded interpretation appended in parentheses
    for the reader's convenience.  Also note that in this example the audience
    is implicitly known by both client and AS. Furthermore note that this
    example uses the "req_cnf" parameter from <xref
    target="I-D.ietf-ace-oauth-params"/>.

    <figure align="center" anchor="fig:asymmATreq"
            title="Example token request bound to an asymmetric key.">
        <artwork align="left"><![CDATA[
Header: POST (Code=0.02)
Uri-Host: "as.example.com"
Uri-Path: "token"
OSCORE: 0x09, 0x05, 0x44, 0x6C
  (h=0, k=1, n=001, partialIV= 0x05, kid=[0x44, 0x6C])
Content-Format: "application/oscore"
Payload:
  0x44025d1 ... (full payload omitted for brevity) ... 68b3825e
  
Decrypted payload:
{
  "client_id" : "myclient",
  "req_cnf" : {
    "COSE_Key" : {
      "kty" : "EC",
      "kid" : h'11',
      "crv" : "P-256",
      "x" : b64'usWxHK2PmfnHKwXPS54m0kTcGJ90UiglWiGahtagnv8',
      "y" : b64'IBOL+C3BttVivg+lSreASjpkttcsz+1rb7btKLv8EX4'
    }
  }
}
        ]]></artwork>
    </figure></t>

    <t><xref target="fig:kidATreq"/> shows a request for a token
    where a previously communicated proof-of-possession key is only
    referenced using the "req_cnf" parameter from
    <xref target="I-D.ietf-ace-oauth-params"/>.

    <figure align="center" anchor="fig:kidATreq"
            title="Example request for an access token bound to a
		   key reference.">
        <artwork align="left"><![CDATA[
Header: POST (Code=0.02)
Uri-Host: "as.example.com"
Uri-Path: "token"
Content-Format: "application/ace+cbor"
Payload:
{
  "client_id" : "myclient",
  "audience" : "valve424",
  "scope" : "read",
  "req_cnf" : {
    "kid" : b64'6kg0dXJM13U'
  }
}
       ]]></artwork>
    </figure></t>

    <t>Refresh tokens are typically not stored as securely as
    proof-of-possession keys in requesting clients.  Proof-of-possession based
    refresh token requests MUST NOT request different proof-of-possession keys
    or different audiences in token requests.  Refresh token requests can only
    use to request access tokens bound to the same proof-of-possession key and
    the same audience as access tokens issued in the initial token request.</t>
  </section>

  <section anchor="tokenResponse" title="AS-to-Client Response">
    <t>If the access token request has been successfully verified by the
    AS and the client is authorized to obtain an access token corresponding
    to its access token request, the AS sends a response with the response
    code equivalent to the CoAP response code 2.01 (Created).  If client
    request was invalid, or not authorized, the AS returns an error response as
    described in <xref
    target="errorsToken"/>.</t>

    <t>Note that the AS decides which token type and profile to use when
    issuing a successful response.  It is assumed that the AS has prior
   knowledge of the capabilities of the client and the RS (see <xref
   target="app:registration"/>).  This prior knowledge may, for example, be set
   by the use of a dynamic client registration protocol exchange
   <xref target="RFC7591"/>.  If the client has requested a specific
   proof-of-possession key using the "req_cnf" parameter from
   <xref target="I-D.ietf-ace-oauth-params"/>, this may also influence which
   profile the AS selects, as it needs to support the use of the key type
   requested the client.</t>

    <t>The content of the successful reply is the Access Information. 
    When using CoAP, the payload MUST be encoded as a CBOR map, when using
    HTTP the encoding is a JSON map as specified in section 5.1 of <xref
    target="RFC6749"/>.  In both cases the parameters specified in Section 5.1
    of <xref target="RFC6749"/> are used, with the following additions and
    changes:

    <list style="hanging">
	<t hangText="ace_profile:"><vspace blankLines="0"/>
	OPTIONAL unless the request included an empty ace_profile parameter
	in which case it is MANDATORY.  This indicates the profile that the
	client MUST use	towards the RS. See <xref target="paramProfile"/> for
	the formatting of this parameter.  If this parameter is absent, the AS
	assumes that the client implicitly knows which profile to use towards
	the RS.</t>

	<t hangText="token_type:"><vspace blankLines="0"/>
	This parameter is OPTIONAL, as opposed to 'required' in
	<xref target="RFC6749"/>. By default implementations of this framework
	SHOULD assume that the token_type is "PoP".  If a specific use case
	requires another token_type (e.g., "Bearer") to be used then this
	parameter is REQUIRED.
	</t>
      </list>
    </t>

    <t>Furthermore <xref target="I-D.ietf-ace-oauth-params"/> defines
    additional parameters that the AS MUST be able to use when responding to a
    request to the token endpoint.</t>
    
    <t><xref target="fig:rsinfo"/> summarizes the parameters that
    can currently be part of the Access Information. Future extensions
    may define additional parameters.

      <figure align="center" anchor="fig:rsinfo"
              title="Access Information parameters">
      <artwork align="left"><![CDATA[
        /-------------------+-------------------------------\
        | Parameter name    | Specified in                  |
        |-------------------+-------------------------------|
        | access_token      |  RFC 6749                     |
        | token_type        |  RFC 6749                     |
        | expires_in        |  RFC 6749                     |
        | refresh_token     |  RFC 6749                     |
        | scope             |  RFC 6749                     |
        | state             |  RFC 6749                     |
        | error             |  RFC 6749                     |
        | error_description |  RFC 6749                     |
        | error_uri         |  RFC 6749                     |
        | ace_profile       | [this document]               |
        | cnf               | [I-D.ietf-ace-oauth-params]   |
        | rs_cnf            | [I-D.ietf-ace-oauth-params]   |
        \-------------------+-------------------------------/
      ]]></artwork></figure>

    </t>

    <t><xref target="fig:symmATres"/> shows a response containing a token
    and a "cnf" parameter with a symmetric proof-of-possession key, which
    is defined in <xref target="I-D.ietf-ace-oauth-params"/>.  Note that
    the key identifier 'kid' is only used to simplify indexing and
    retrieving the key, and no assumptions should be made that it is
    unique in the domains of either the client or the RS.

    <figure align="center" anchor="fig:symmATres"
            title="Example AS response with an access token bound to a
		   symmetric key.">
      <artwork align="left"><![CDATA[
Header: Created (Code=2.01)
Content-Format: "application/ace+cbor"
Payload:
{
  "access_token" : b64'SlAV32hkKG ...
   (remainder of CWT omitted for brevity;
   CWT contains COSE_Key in the "cnf" claim)',
  "ace_profile" : "coap_dtls",
  "expires_in" : "3600",
  "cnf" : {
    "COSE_Key" : {
      "kty" : "Symmetric",
      "kid" : b64'39Gqlw',
      "k" : b64'hJtXhkV8FJG+Onbc6mxCcQh'
    }
  }
}
      ]]></artwork>
    </figure></t>
  </section>

  <section anchor="errorsToken" title="Error Response">
    <t>The error responses for interactions with the AS are generally
    equivalent to the ones defined in Section 5.2 of <xref target="RFC6749"/>,
    with the following exceptions:

      <list style="symbols">
        <t>When using CoAP the payload MUST be encoded as a CBOR map, with
	the Content-Format "application/ace+cbor".  When using HTTP the
        payload is encoded in JSON as specified in section 5.2 of <xref
        target="RFC6749"/>.</t>

        <t>A response code equivalent to the CoAP code 4.00 (Bad Request) MUST
	be used for all error responses, except for invalid_client where a
	response code equivalent to the CoAP code 4.01 (Unauthorized) MAY be
	used under the same conditions as specified in Section 5.2 of
	<xref target="RFC6749"/>.</t>



	<t>The parameters "error", "error_description" and "error_uri" MUST
	be abbreviated using the codes specified in <xref
	target="fig:cborTokenParameters"/>, when a CBOR encoding is used.</t>

	<t>The error code (i.e., value of the "error" parameter) MUST be
	abbreviated as specified in <xref
	target="fig:cborErrorCodes"/>, when a CBOR encoding is used.</t>
      </list>

      <figure align="center" anchor="fig:cborErrorCodes"
              title="CBOR abbreviations for common error codes">
        <artwork align="left"><![CDATA[
     /---------------------------+--------+--------------------------\
     |                           | CBOR   | Original                 |
     | Name                      | Values | Specification            |
     |---------------------------+--------+--------------------------|
     | invalid_request           |    1   | section 5.2 of [RFC6749] |
     | invalid_client            |    2   | section 5.2 of [RFC6749] |
     | invalid_grant             |    3   | section 5.2 of [RFC6749] |
     | unauthorized_client       |    4   | section 5.2 of [RFC6749] |
     | unsupported_grant_type    |    5   | section 5.2 of [RFC6749] |
     | invalid_scope             |    6   | section 5.2 of [RFC6749] |
     | unsupported_pop_key       |    7   | [this document]          |
     | incompatible_ace_profiles |    8   | [this document]          |
     \---------------------------+--------+--------------------------/
        ]]></artwork>
      </figure>
    </t>

    <t>In addition to the error responses defined in OAuth 2.0, the following
    behavior MUST be implemented by the AS:

    <list style="symbols">
      <t>If the client submits an asymmetric key in the token request that the
      RS cannot process, the AS MUST reject that request with a response code
      equivalent to the CoAP code 4.00 (Bad Request) including the error code
      "unsupported_pop_key" specified in
      <xref target="fig:cborErrorCodes"/>.</t>

      <t>If the client and the RS it has requested an access token for do
      not share a common profile, the AS MUST reject that request with a
      response code equivalent to the CoAP code 4.00 (Bad Request) including
      the error code "incompatible_ace_profiles" specified in
      <xref target="fig:cborErrorCodes"/>.</t>
    </list></t>
  </section>

  <section anchor="tokenParams"
	   title="Request and Response Parameters">
    <t>This section provides more detail about the new parameters that can be
    used in access token requests and responses, as well as abbreviations for
    more compact encoding of existing parameters and common parameter
    values.</t>

    <section anchor="paramGrantType" title="Grant Type">
      <t>The abbreviations specified in the registry defined in
      <xref target="IANAGrantTypeMappings"/> MUST be
      used in CBOR encodings instead of the string values defined
      in <xref target="RFC6749"/>, if CBOR payloads are used.

      <figure align="center" anchor="fig:grant_types"
              title="CBOR abbreviations for common grant types ">
        <artwork align="left"><![CDATA[
        /--------------------+------------+------------------------\
        | Name               | CBOR Value | Original Specification |
        |--------------------+------------+------------------------|
        | password           |      0     |  s. 4.3.2 of [RFC6749] |
        | authorization_code |      1     |  s. 4.1.3 of [RFC6749] |
        | client_credentials |      2     |  s. 4.4.2 of [RFC6749] |
        | refresh_token      |      3     |  s. 6 of [RFC6749]     |
        \--------------------+------------+------------------------/
        ]]></artwork>
      </figure></t>
    </section>

    <section anchor="paramTokenType" title="Token Type">
      <t>The "token_type" parameter, defined in section 5.1 of <xref
      target="RFC6749"/>, allows the AS to indicate to the client which type of
      access token it is receiving (e.g., a bearer token). </t>

      <t>This document registers the new value "PoP" for the OAuth Access
        Token Types registry,  specifying a proof-of-possession token.  How the
      proof-of-possession by the client to the RS is performed MUST be specified by the profiles.</t>

      <t>The values in the "token_type" parameter MUST use the CBOR
      abbreviations defined in the registry specified by
      <xref target="IANATokenTypeMappings"/>, if a CBOR encoding is used. </t>

      <t>In this framework the "pop" value for the "token_type" parameter is
      the default. The AS may, however, provide a different value from those
      registered in <xref target="IANA.OAuthAccessTokenTypes"/>.</t>
    </section>

    <section anchor="paramProfile" title="Profile">

      <t>Profiles of this framework MUST define the communication
      protocol and the communication security protocol between the client
      and the RS.  The security protocol MUST provide encryption, integrity and
      replay protection. It MUST also provide a binding between requests and
      responses.  Furthermore profiles MUST define a list of
      allowed proof-of-possession methods, if they support proof-of-possession
      tokens.</t>

      <t>A profile MUST specify an identifier that MUST be used to uniquely
      identify itself in the "ace_profile" parameter. The textual
      representation of the profile identifier is intended for human
      readability and for JSON-based interactions, it MUST NOT be used for
      CBOR-based interactions.  Profiles MUST register their identifier in the
      registry defined in <xref target="IANAProfile"/>.
      </t>

      <t>Profiles MAY define additional parameters for both the token request
      and the Access Information in the access token response in order to
      support negotiation or signaling of profile specific parameters.
      </t>

      <t>Clients that want the AS to provide them with the "ace_profile"
      parameter in the access token response can indicate that by sending a
      ace_profile parameter with a null value for CBOR-based interactions, 
      or an empty string if CBOR is not used, in the access token
      request.</t>
    </section>

    <section anchor="cnonceParamToken" title="Client-Nonce">
      <t>This parameter MUST be sent from the client to the AS,
      if it previously received a "cnonce" parameter in the "AS Request
      Creation Hints" <xref target="asInfo"/>.  The parameter
      is encoded as a byte string for CBOR-based interactions, and as a
      string (Base64 encoded binary) if CBOR is not used.
      It MUST copy the value from the cnonce parameter in the "AS Request
      Creation Hints".</t>
    </section>
  </section> <!--Parameters -->

  <section anchor="tokenCborParams" title="Mapping Parameters to CBOR">
    <t>If CBOR encoding is used, all OAuth parameters in access token requests
    and responses MUST be mapped to CBOR types as specified in the registry
    defined by <xref target="IANAOAuthParameterMappingsRegistry"/>, using the
    given integer abbreviation for the map keys.</t>
    <t>Note that we have aligned the abbreviations corresponding to claims
    with the abbreviations defined in <xref target="RFC8392"/>.</t>

    <t>Note also that abbreviations from -24 to 23 have a 1 byte encoding
    size in CBOR. We have thus chosen to assign abbreviations in that
    range to parameters we expect to be used most frequently in constrained
    scenarios.</t>

    <t>
      <figure align="center" anchor="fig:cborTokenParameters"
              title="CBOR mappings used in token requests and responses">
        <artwork align="left"><![CDATA[
  /-------------------+----------+---------------------+---------------\
  |                   |          |                     | Original      |
  | Name              | CBOR Key | Value Type          | Specification |
  |-------------------+----------+---------------------+---------------|
  | access_token      | 1        | byte string         | [RFC6749]     |
  | expires_in        | 2        | unsigned integer    | [RFC6749]     |
  | audience          | 5        | text string         | [RFC8693]     |
  | scope             | 9        | text or byte string | [RFC6749]     |
  | client_id         | 24       | text string         | [RFC6749]     |
  | client_secret     | 25       | byte string         | [RFC6749]     |
  | response_type     | 26       | text string         | [RFC6749]     |
  | redirect_uri      | 27       | text string         | [RFC6749]     |
  | state             | 28       | text string         | [RFC6749]     |
  | code              | 29       | byte string         | [RFC6749]     |
  | error             | 30       | integer             | [RFC6749]     |
  | error_description | 31       | text string         | [RFC6749]     |
  | error_uri         | 32       | text string         | [RFC6749]     |
  | grant_type        | 33       | unsigned integer    | [RFC6749]     |
  | token_type        | 34       | integer             | [RFC6749]     |
  | username          | 35       | text string         | [RFC6749]     |
  | password          | 36       | text string         | [RFC6749]     |
  | refresh_token     | 37       | byte string         | [RFC6749]     |
  | ace_profile       | 38       | integer             |[this document]|
  | cnonce            | 39       | byte string         |[this document]|
  \-------------------+----------+---------------------+---------------/
      ]]></artwork>
    </figure>
  </t>
  </section>
</section><!-- Token endpoint -->

<section anchor="introspectionEndpoint" title="The Introspection Endpoint">
  <t>Token introspection <xref target="RFC7662"/> MAY be implemented by the AS,
  and the RS. When implemented, it MAY be used by the RS and to query the AS
  for metadata about a given token, e.g., validity or scope. Analogous to the
  protocol defined in <xref target="RFC7662"/> for HTTP and JSON, this
  section defines adaptations to more constrained  environments using CBOR and
  leaving the choice of the application protocol to the profile.</t>

  <t>Communication between the requesting entity and the introspection endpoint
  at the AS MUST be integrity protected and encrypted.  The communication
  security protocol MUST also provide a binding between requests and
  responses.  Furthermore, the two interacting parties MUST perform mutual
  authentication.  Finally, the AS SHOULD verify that the requesting entity has
  the right to access introspection information about the provided token.
  Profiles of this framework that support introspection MUST specify how
  authentication and communication security between the requesting
  entity and the AS is implemented.</t>

  <t> The default name of this endpoint in an url-path SHOULD be '/introspect'.
  However, implementations are not required to use this name and can define
  their own instead.</t>

  <t>The figures of this section use the CBOR diagnostic
  notation without the integer abbreviations for the parameters and their
  values for better readability.
  </t>

  <section anchor="introReq" title="Introspection Request">
    <t>The requesting entity sends a POST request to the introspection endpoint
    at the AS.  The profile MUST specify how the communication is protected.
    If CoAP is used, the payload MUST be encoded as a CBOR map with a "token"
    entry containing the access token.  Further optional parameters
    representing additional context that is known by the requesting entity to
    aid the AS in its response MAY be included.</t>

    <t>For CoAP-based interaction, all messages MUST use the content type
    "application/ace+cbor". For HTTP the encoding defined in section 2.1
    of <xref target="RFC7662"/> is used.</t>
    
    <t>The same parameters are required and optional as in Section 2.1
    of <xref target="RFC7662"/>.</t>

    <t>For example, <xref target="fig:introReq"/> shows an RS calling the token
    introspection endpoint at the AS to query about an OAuth 2.0
    proof-of-possession token.  Note that object security based on OSCORE
    <xref target="RFC8613"/> is assumed in this example,
    therefore the Content-Format is "application/oscore". <xref
    target="fig:introReq-payl"/> shows the decoded payload.

    <figure align="center" anchor="fig:introReq"
            title="Example introspection request.">
        <artwork align="left"><![CDATA[
Header: POST (Code=0.02)
Uri-Host: "as.example.com"
Uri-Path: "introspect"
OSCORE: 0x09, 0x05, 0x25
Content-Format: "application/oscore"
Payload:
... COSE content ...
       ]]></artwork>
    </figure>
    <figure align="center" anchor="fig:introReq-payl"
            title="Decoded payload.">
        <artwork align="left"><![CDATA[
{
  "token" : b64'7gj0dXJQ43U',
  "token_type_hint" : "PoP"
}
       ]]></artwork>
    </figure></t>
	
  </section>

  <section anchor="introRes" title="Introspection Response">
    <t>If the introspection request is authorized and successfully processed,
    the AS sends a response with the response code equivalent to the CoAP code
    2.01 (Created).  If the introspection request was invalid, not authorized
    or couldn't be processed the AS returns an error response as described in
    <xref target="errorsIntro"/>.</t>

    <t>In a successful response, the AS encodes the response parameters in
    a map.  If CoAP is used, this MUST be encoded as a CBOR map, if HTTP is
    used the JSON encoding specified in section 2.2 of <xref target="RFC7662"/>
    is used.  The map containing the response payload  includes the same
    required and optional parameters as in Section 2.2 of
    <xref target="RFC7662"/> with the following additions:

    <list style="hanging">
        <t hangText="ace_profile">
	OPTIONAL.  This indicates the profile that the RS MUST use with the
	client.  See <xref target="paramProfile"/> for more details on the
	formatting of this parameter. If this parameter is absent, the AS
	assumes that the RS implicitly knows which profile to use towards
	the client.</t>
	<t hangText="cnonce">
	  OPTIONAL.  A client-nonce provided to the AS by the client.
	  The RS MUST verify that this corresponds to the client-nonce
	  previously provided to the client in the "AS Request Creation
	  Hints". See <xref target="asInfo"/> and
	  <xref target="cnonceParamToken"/>.
	</t>
	<t hangText="cti">
	  OPTIONAL. The "cti" claim associated to this access token. This
	  parameter has the same meaning and processing rules as the "jti"
	  parameter defined in section 3.1.2 of <xref target="RFC7662"/> 
	  except that the value is a byte string.
	</t>
	<t hangText="exi">
	  OPTIONAL. The "expires-in" claim associated to this access token.
	  See <xref target="tokenExpiration"/>.
	</t>
    </list>
    </t>
 
   

    <t>Furthermore <xref target="I-D.ietf-ace-oauth-params"/> defines
    more parameters that the AS MUST be able to use when responding to a
    request to the introspection endpoint.</t>
    
    <t>For example, <xref target="fig:introRes"/> shows an AS
    response to the introspection request in <xref target="fig:introReq"/>.
    Note that this example contains the "cnf" parameter defined in
    <xref target="I-D.ietf-ace-oauth-params"/>.

    <figure align="center" anchor="fig:introRes"
            title="Example introspection response.">
      <artwork align="left"><![CDATA[
Header: Created (Code=2.01)
Content-Format: "application/ace+cbor"
Payload:
{
  "active" : true,
  "scope" : "read",
  "ace_profile" : "coap_dtls",
  "cnf" : {
    "COSE_Key" : {
      "kty" : "Symmetric",
      "kid" : b64'39Gqlw',
      "k" : b64'hJtXhkV8FJG+Onbc6mxCcQh'
    }
  }
}
      ]]></artwork>
    </figure></t>
  </section>

  <section anchor="errorsIntro" title="Error Response">
    <t>The error responses for CoAP-based interactions with the AS
    are equivalent to the ones for HTTP-based interactions as defined in
    Section 2.3 of <xref target="RFC7662"/>, with the following differences:

    <list style="symbols">
      <t>If content is sent and CoAP is used the payload MUST be encoded as a
      CBOR map and the Content-Format "application/ace+cbor" MUST be used.
      For HTTP the encoding defined in section 2.3 of <xref target="RFC6749"/>
      is used.</t>

      <t>If the credentials used by the requesting entity (usually the RS)
      are invalid the AS MUST respond with the response code equivalent to the
      CoAP code 4.01 (Unauthorized) and use the required and optional
      parameters from Section 2.3 in <xref target="RFC7662"/>.</t>

      <t>If the requesting entity does not have the right to perform this
      introspection request, the AS MUST respond with a response code
      equivalent to the CoAP code 4.03 (Forbidden).  In this case no payload is
      returned.</t>

      <t>The parameters "error", "error_description" and "error_uri" MUST
      be abbreviated using the codes specified in <xref
      target="fig:cborTokenParameters"/>.</t>

      <t>The error codes MUST be abbreviated using the codes specified in
      the registry defined by <xref target="IANAErrorCBORMappings"/>.</t>
    </list>
    </t>

    <t>Note that a properly formed and authorized query for an inactive or
    otherwise invalid token does not warrant an error response by this
    specification.  In these cases, the authorization server MUST instead
    respond with an introspection response with the "active" field set to
    "false".</t>
  </section>


  <section anchor="introParamsCbor"
	   title="Mapping Introspection Parameters to CBOR">
    <t>If CBOR is used, the introspection request and response parameters MUST
    be mapped to CBOR types as specified in the registry defined by <xref
    target="IANAIntrospectionEndpointCBORMappingsRegistry"/>, using the given
    integer abbreviation for the map key.</t>

    <t>Note that we have aligned abbreviations that correspond to a
    claim with the abbreviations defined in <xref target="RFC8392"/>
    and the abbreviations of parameters with the same name from
    <xref target="tokenCborParams"/>.
    
    <figure align="center" anchor="fig:cborIntrospectionParameters"
            title="CBOR mappings for Token Introspection Parameters.">
      <artwork align="left"><![CDATA[
    /-------------------+----------+-------------------+---------------\
    |                   |          |                   | Original      |
    | Parameter name    | CBOR Key | Value Type        | Specification |
    |-------------------+----------+-------------------+---------------|
    | iss               | 1        | text string       | [RFC7662]     |
    | sub               | 2        | text string       | [RFC7662]     |
    | aud               | 3        | text string       | [RFC7662]     |
    | exp               | 4        | integer or        | [RFC7662]     |
    |                   |          |   floating-point  |               |
    |                   |          |   number          |               |
    | nbf               | 5        | integer or        | [RFC7662]     |
    |                   |          |   floating-point  |               |
    |                   |          |   number          |               |
    | iat               | 6        | integer or        | [RFC7662]     |
    |                   |          |   floating-point  |               |
    |                   |          |   number          |               |
    | scope             | 9        | text or           |               |
    |                   |          |   byte string     | [RFC7662]     |
    | active            | 10       | True or False     | [RFC7662]     |
    | token             | 11       | byte string       | [RFC7662]     |
    | client_id         | 24       | text string       | [RFC7662]     |
    | error             | 30       | integer           | [RFC7662]     |
    | error_description | 31       | text string       | [RFC7662]     |
    | error_uri         | 32       | text string       | [RFC7662]     |
    | token_type_hint   | 33       | text string       | [RFC7662]     |
    | token_type        | 34       | integer           | [RFC7662]     |
    | username          | 35       | text string       | [RFC7662]     |
    | ace_profile       | 38       | integer           |[this document]|
    | cnonce            | 39       | byte string       |[this document]| 
    | exi               | 40       | unsigned integer  |[this document]|
    \-------------------+----------+-------------------+---------------/
        ]]></artwork>
      </figure>
    </t>
  </section>

</section><!-- introspection endpoint -->

<section anchor="accessToken" title="The Access Token">
  <t>In this framework the use of CBOR Web Token (CWT) as
    specified in <xref target="RFC8392"/> is RECOMMENDED.
  </t>

  <t>In order to facilitate offline processing of access tokens,
  this document uses the "cnf" claim from <xref
  target="RFC8747"/> and the "scope" claim from <xref target="RFC8693"/> for
  JWT- and CWT-encoded tokens.  In addition to string encoding specified for
  the "scope" claim, a binary encoding MAY be used.  The syntax of such an
  encoding is explicitly not specified here and left to profiles or
  applications, specifically note that a binary encoded scope does not
  necessarily use the space character '0x20' to delimit scope-tokens.</t>

  <t>If the AS needs to convey a hint to the RS about which profile it
  should use to communicate with the client, the AS MAY include an
  "ace_profile" claim in the access token, with the same syntax and semantics
  as defined in <xref target="paramProfile"/>.</t>

  <t>If the client submitted a client-nonce parameter in the access token
  request <xref target="cnonceParamToken"/>, the AS MUST include the value of
  this parameter in the "cnonce" claim specified here.  The "cnonce" claim
  uses binary encoding.</t>
  

  <section anchor="tokenAuthInfoEndpoint"
	   title="The Authorization Information Endpoint">
  <t>The access token, containing authorization information and information
  about the proof-of-possession method used by the client, needs to be
  transported to the RS so that the RS can authenticate and authorize the
  client request.</t>

  <t>This section defines a method for transporting the access token to the RS
  using a RESTful protocol such as CoAP. Profiles of this framework MAY define
  other methods for token transport.
  </t>

  <t>The method consists of an authz-info endpoint, implemented by the
  RS.  A client using this method MUST make a POST request to the authz-info
  endpoint at the RS with the access token in the payload.  The CoAP 
  Content-Format or HTTP Media Type MUST reflect the format of the token,
  e.g. application/cwt for CBOR Web Tokens, if no Content-Format or Media
  Type is defined for the token format, application/octet-stream MUST be
  used.</t>

  <t>The RS receiving the token MUST verify the validity of the token.  If the
  token is valid, the RS MUST respond to the POST request with a response code
  equivalent to CoAP's 2.01 (Created).
  <xref target="verifyToken"/> outlines how an RS MUST proceed to verify the
  validity of an access token.</t>
  
  <t>The RS MUST be prepared to store at least one access token for future
  use. This is a difference to how access tokens are handled in OAuth 2.0,
  where the access token is typically sent along with each request, and
  therefore not stored at the RS.</t>

  <t>When using this framework it is RECOMMENDED that an RS stores only one
  token per proof-of-possession key.  This means that an additional token linked
  to the same key will supersede any existing token at the RS, by replacing
  the corresponding authorization information.  The reason is that
  this greatly simplifies (constrained) implementations, with respect to
  required storage and resolving a request to the applicable token.  The use of
  multiple access tokens for a single client increases the strain on the
  resource server as it must consider every access token and calculate the
  actual permissions of the client.  Also, tokens may contradict each other
  which may lead the server to enforce wrong permissions.  If one of the access
  tokens expires earlier than others, the resulting permissions may offer
  insufficient protection.
  </t>
  
  <t>If the payload sent to the authz-info endpoint does not parse
  to a token, the RS MUST respond with a response code equivalent to the CoAP
  code 4.00 (Bad Request).</t>
  
  <t>The RS MAY make an introspection request to validate the token before
  responding to the POST request to the authz-info endpoint, e.g. if the
  token is an opaque reference.  Some transport protocols may provide a way to
  indicate that the RS is busy and the client should retry after an interval;
  this type of status update would be appropriate while the RS is waiting for
  an introspection response.
  </t>

  <t>Profiles MUST specify whether the authz-info endpoint is protected,
  including whether error responses from this endpoint are protected.  Note that
  since the token contains information that allow the client and the RS to
  establish a security context in the first place, mutual authentication may
  not be possible at this point.</t>

  <t>The default name of this endpoint in an url-path is '/authz-info',
  however implementations are not required to use this name and can define
  their own instead.</t>

  <section anchor="verifyToken" title="Verifying an Access Token">
    <t>When an RS receives an access token, it MUST verify it before storing
    it. The details of token verification depends on various aspects, including 
    the token encoding, the type of token, the security protection applied to
    the token, and the claims.  The token encoding matters since the security
    protection differs between the token encodings. For example, a CWT token
    uses COSE while a JWT token uses JOSE.  The type of token also has an
    influence on the verification procedure since tokens may be self-contained
    whereby token verification may happen locally at the RS while a 
    token-by-reference requires further interaction with the authorization
    server, for example using token introspection, to obtain the claims
    associated with the token reference.  Self-contained tokens MUST, at 
    least be integrity protected but they MAY also be encrypted.</t> 
	
    <t>For self-contained tokens the RS MUST process the security
    protection of the token first, as specified by the respective token format.
    For CWT the description can be found in <xref target="RFC8392"/> and for
    JWT the relevant specification is <xref target="RFC7519"/>.  This MUST
    include a verification that security protection (and thus the token) was
    generated by an AS that has the right to issue access tokens for this
    RS.</t>
	
    <t>In case the token is communicated by reference the RS needs to obtain
    the claims first. When the RS uses token introspection the relevant
    specification is <xref target="RFC7662"/> with CoAP transport specified in
    <xref target="introspectionEndpoint"/>. </t> 
 	
	<t>Errors may happen during this initial processing stage:
	<list style="symbols">
	
	  <t>If the verification of the security wrapper fails, or the token
	  was issued by an AS that does not have the right to issue tokens
	  for the receiving RS, the RS MUST discard the token
	  and, if this was an interaction with authz-info, return an error
	  message with a response code equivalent to the CoAP code 4.01
	  (Unauthorized).</t>
	
	  <t>If the claims cannot be obtained the RS MUST discard the token and,
	  in case of an interaction via the authz-info endpoint, return an error
	  message with a response code equivalent to the CoAP code 4.00 (Bad
	  Request).</t>
	</list> 
	</t>
	
	<t>Next, the RS MUST verify claims, if present, contained in the access
	token. Errors are returned when claim checks fail, in the order of
	priority of this list:

    <list style="hanging">
      <t hangText="iss">The issuer claim (if present) must identify the AS that
      has produced the security protection for the access token.  If that is
      not the case the RS MUST discard the token.  If this was an interaction
      with authz-info, the RS MUST also respond with a response code equivalent
      to the CoAP code 4.01 (Unauthorized).</t>
      <t hangText="exp">The expiration date must be in the future.  
      If that is not the case the RS MUST discard the token.  If this was an
      interaction with authz-info the RS MUST also respond with a response code
      equivalent to the CoAP code 4.01 (Unauthorized). Note that the RS has to
      terminate access rights to the protected resources at the time when the
      tokens expire. </t>
      <t hangText="aud">The audience claim must refer to an audience that
      the RS identifies with. If that is not the case the RS MUST discard the
      token.  If this was an interaction with authz-info, the RS MUST also
      respond with a response code equivalent to the CoAP code 4.03
      (Forbidden).</t>
      <t hangText="scope">The RS must recognize value of the scope claim.
      If that is not the case the RS MUST discard the token.  If this was an
      interaction with authz-info, the RS MUST also respond with a response code
      equivalent to the CoAP code 4.00 (Bad Request).  The RS MAY provide
      additional information in the error response, to clarify what
      went wrong.</t>
    </list></t>

    <t>Additional processing may be needed for other claims in a way
    specific to a profile or the underlying application.</t>

    <t>Note that the Subject (sub) claim cannot always be verified when
    the token is submitted to the RS since the client may not have
    authenticated yet. Also note that a counter for the expires_in (exi) claim
    MUST be initialized when the RS first verifies this token.</t>

    <t>Also note that profiles of this framework may define access token
    transport mechanisms that do not allow for error responses.  Therefore the
    error messages specified here only apply if the token was sent to the
    authz-info endpoint.</t>
    
    <t>When sending error responses, the RS MAY use the error codes from
    Section 3.1 of <xref target="RFC6750"/>, to provide additional
    details to the client.</t>
  </section>

  <section anchor="protAuthzInfo" title="Protecting the Authorization
					 Information Endpoint">
    <t>As this framework can be used in RESTful environments, it is important
    to make sure that attackers cannot perform unauthorized requests on the
    authz-info endpoints, other than submitting access tokens.</t>

    <t>Specifically it SHOULD NOT be possible to perform GET, DELETE or
    PUT on the authz-info endpoint.</t>

    <t>The RS SHOULD implement rate limiting measures to mitigate attacks aiming
    to overload the processing capacity of the RS by repeatedly submitting
    tokens. For CoAP-based communication the RS could use the mechanisms from
    <xref target="RFC8516"/> to indicate that it is overloaded.</t>
  </section>
  
</section>

<section anchor="requestC2RS" title="Client Requests to the RS">
  <t>Before sending a request to an RS, the client MUST verify that the keys
  used to protect this communication are still valid. See <xref
  target="keyExpiration"/> for details on how the client determines the
  validity of the keys used.</t>
  
  <t>If an RS receives a request from a client, and the target resource
  requires authorization, the RS MUST first verify that it has an access token
  that authorizes this request, and that the client has performed the
  proof-of-possession binding that token to the request.</t>
  
  <t>The response code MUST be 4.01 (Unauthorized) in case the client has
  not performed the proof-of-possession, or if RS has no valid access token for
  the client. If RS has an access token for the client but the token does not
  authorize access for the resource that was requested, RS MUST reject the
  request with a 4.03 (Forbidden). If RS has an access token for the client but
  it does not cover the action that was requested on the resource, RS MUST
  reject the request with a 4.05 (Method Not Allowed).</t>

  <t>Note: The use of the response codes 4.03 and 4.05 is intended to prevent
  infinite loops where a dumb client optimistically tries to access a
  requested resource with any access token received from AS. As malicious
  clients could pretend to be C to determine C's privileges, these detailed
  response codes must be used only when a certain level of security is
  already available which can be achieved only when the client is
  authenticated.</t>

  <t>Note: The RS MAY use introspection for timely validation of an
  access token, at the time when a request is presented.</t>

  <t>Note: Matching the claims of the access token (e.g., scope) to a specific
  request is application specific.</t>
  
  <t>If the request matches a valid token and the client has performed the
  proof-of-possession for that token, the RS continues to process the request
  as specified by the underlying application.</t>
</section>

<section anchor="tokenExpiration" title="Token Expiration">
  <t>Depending on the capabilities of the RS, there are various ways in
    which it can verify the expiration of a received access token.  Here follows
    a list of the possibilities including what functionality they require of the
    RS.</t>

  <t><list style="symbols">
    <t>The token is a CWT and includes an "exp" claim and possibly the
    "nbf" claim.  The RS verifies these by comparing them to values from
    its internal clock as defined in <xref target="RFC7519"/>.  In this
    case the RS's internal clock must reflect the current date and time, or
    at least be synchronized with the AS's clock.  How this clock
    synchronization would be performed is out of scope for this
    specification.</t>

    <t>The RS verifies the validity of the token by performing an
    introspection request as specified in <xref
    target="introspectionEndpoint"/>.  This requires the RS to have a
    reliable network connection to the AS and to be able to handle two
    secure sessions in parallel (C to RS and RS to AS).</t>

    <t>In order to support token expiration for devices that have no reliable
    way of synchronizing their internal clocks, this specification defines the
    following approach: The claim "exi" ("expires in") can be used, to provide
    the RS with the lifetime of the token in seconds from the time the RS first
    receives the token.  This mechanism only works for self-contained tokens,
    i.e. CWTs and JWTs. For CWTs this parameter is encoded as unsigned integer,
    while JWTs encode this as JSON number.</t>

    <t> Processing this claim requires that the RS does the following:
    <list style="symbols">
      <t>For each token the RS receives, that contains an "exi" claim:
      Keep track of the time it received that token and revisit that list
      regularly to expunge expired tokens.</t>
      <t>Keep track of the identifiers of tokens containing the "exi"
      claim that have expired (in order to avoid accepting them again).
      In order to avoid an unbounded memory usage growth, this MUST be
      implemented in the following way when the "exi" claim is used:
      <list style="symbols">
	<t>When creating the token, the AS MUST add a 'cti' claim (
	or 'jti' for JWTs) to the access token.  The value of this claim
	MUST be created as the binary representation of the concatenation
	of the identifier of the RS with a sequence number counting the
	tokens containing an 'exi' claim, issued by this AS for the
	RS.</t>
	<t>The RS MUST store the highest sequence number of an expired
	token containing the "exi" claim that it has seen, and treat
	tokens with lower sequence numbers as expired.  Note that
        this could lead to discarding valid tokens with lower sequence numbers,
        if the AS where to issue tokens of different validity time for the same
	RS.  The assumption is that typically tokens in such a scenario would
	all have the same validity time.</t>
      </list></t>
    </list></t>
  </list></t>

  <t>If a token that authorizes a long running request such as a CoAP
  Observe <xref target="RFC7641"/> expires, the RS MUST send an error
  response with the response code equivalent to the CoAP code 4.01
  (Unauthorized) to the client and then terminate processing the long running
  request.</t>
</section>

<section anchor="keyExpiration" title="Key Expiration">
  <t>The AS provides the client with key material that the RS uses. This can
  either be a common symmetric PoP-key, or an asymmetric key used by the RS to
  authenticate towards the client.  Since there is currently no expiration
  metadata associated to those keys, the client has no way of knowing if these
  keys are still valid.  This may lead to situations where the client sends
  requests containing sensitive information to the RS using a key that is
  expired and possibly in the hands of an attacker, or accepts responses from
  the RS that are not properly protected and could possibly have been forged by
  an attacker. 
  </t>

  <t>In order to prevent this, the client must assume that those keys are
  only valid as long as the related access token is.  Since the access token
  is opaque to the client, one of the following methods MUST be used to
  inform the client about the validity of an access token:

  <list style="symbols">
    <t>The client knows a default validity time for all tokens it is
    using (i.e. how long a token is valid after being issued).  This
    information could be provisioned to the client when it is registered at the
    AS, or published by the AS in a way that the client can query.</t>
    <t>The AS informs the client about the token validity using the
    "expires_in" parameter in the Access Information.</t>
  </list>
  </t>

  <t>A client that is not able to obtain information about the expiration of a
  token MUST NOT use this token.</t>
</section>

</section><!-- access token -->

</section> <!--Framework-->

<section anchor="security" title="Security Considerations">

  <t>Security considerations applicable to authentication and authorization
  in RESTful environments provided in OAuth 2.0 <xref target="RFC6749"/> apply
  to this work.  Furthermore <xref target="RFC6819"/>
  provides additional security considerations for OAuth which apply to IoT
  deployments as well.  If the introspection endpoint is used,
  the security considerations from <xref target="RFC7662"/> also apply.</t>

  <t>The following subsections address issues specific to this document and
  it's use in constrained environments.</t>
  
   <section anchor="tokenProtection" title="Protecting Tokens">
      <t>A large range of threats can be mitigated by protecting the contents
      of the access token by using a digital signature or a keyed message
      digest (MAC) or an Authenticated Encryption with Associated Data (AEAD)
      algorithm.  Consequently, the token integrity protection MUST be applied
      to prevent the token from being modified, particularly since it contains
      a reference to the symmetric key or the asymmetric key used for
      proof-of-possession.  If the access token contains the symmetric key,
      this symmetric key MUST be encrypted by the authorization server so that
      only the resource server can decrypt it.  Note that using an AEAD
      algorithm is preferable over using a MAC unless the token needs to be
      publicly readable.</t>
      
      <t>If the token is intended for multiple recipients (i.e. an audience
      that is a group), integrity protection of the token with a symmetric key,
      shared between the AS and the recipients, is not sufficient, since any of
      the recipients could modify the token undetected by the other recipients.
      Therefore a token with a multi-recipient audience MUST be protected with
      an asymmetric signature.
      </t>

      <t>It is important for the authorization server to include the identity
      of the intended recipient (the audience), typically a single resource
      server (or a list of resource servers), in the token.  The same
      shared secret MUST NOT be used as proof-of-possession key with multiple
      resource servers since the benefit from using the proof-of-possession
      concept is then significantly reduced.</t>

     <t>If clients are capable of doing so, they should frequently request
      fresh access tokens, as this allows the AS to keep the lifetime of the
      tokens short. This allows the AS to use shorter proof-of-possession key
      sizes, which translate to a performance benefit for the client and for
      the resource server.  Shorter keys also lead to shorter messages
      (particularly with asymmetric keying material).</t>

      <t>When authorization servers bind symmetric keys to access tokens,
      they SHOULD scope these access tokens to a specific permission.</t>

      <t>In certain situations it may be necessary to revoke an access
      token that is still valid.  Client-initiated revocation is specified
      in <xref target="RFC7009"/> for OAuth 2.0.  Other revocation mechanisms
      are currently not specified, as the underlying assumption in OAuth
      is that access tokens are issued with a relatively short lifetime.
      This may not hold true for disconnected constrained devices, needing
      access tokens with relatively long lifetimes, and would therefore
      necessitate further standardization work that is out of scope for
      this document.</t>
    </section><!--token protection-->

    <section anchor="commSec" title="Communication Security">
      
      <t>Communication with the authorization server MUST use confidentiality
      protection.  This step is extremely important since the client or the
      RS may obtain the proof-of-possession key from the authorization server
      for use with a specific access token.  Not using confidentiality
      protection exposes this secret (and the access token) to an eavesdropper
      thereby completely negating proof-of-possession security.
      The requirements for communication security of profiles are specified
      in <xref target="oauthProfile"/>.</t>

      <t>Additional protection for the access token can be applied by
      encrypting it, for example encryption of CWTs is specified in Section 5.1
      of <xref target="RFC8392"/>.  Such additional protection can be necessary
      if the token is later transferred over an insecure connection
      (e.g. when it is sent to the authz-info endpoint).</t>

      <t>Care must by taken by developers to prevent leakage of the PoP 
      credentials (i.e., the private key or the symmetric key).  An
      adversary in possession of the PoP credentials bound to the access
      token will be able to impersonate the client.  Be aware that this is a
      real risk with many constrained environments, since adversaries may
      get physical access to the devices and can therefore use physical
      extraction techniques to gain access to memory contents.  This risk can 
      be mitigated to some extent by making sure that keys are refreshed
      frequently, by using software isolation techniques and by using hardware security.</t>
    </section><!--communication security-->

    <section anchor="keys" title="Long-Term Credentials">
      <t>Both clients and RSs have long-term credentials that are used to
      secure communications, and authenticate to the AS.  These credentials
      need to be protected against unauthorized access.  In constrained
      devices, deployed in publicly accessible places, such protection can
      be difficult to achieve without specialized hardware (e.g. secure
      key storage memory).</t>

      <t>If credentials are lost or compromised, the operator of the affected
      devices needs to have procedures to invalidate any access these
      credentials give and to revoke tokens linked to such credentials.  The
      loss of a credential linked to a specific device MUST NOT lead to a
      compromise of other credentials not linked to that device, therefore
      secret keys used for authentication MUST NOT be shared between more than
      two parties.</t>

      <t>Operators of clients or RS SHOULD have procedures in place to
      replace credentials that are suspected to have been compromised or that
      have been lost.</t>

      <t>Operators also SHOULD have procedures for decommissioning devices,
      that include securely erasing credentials and other security critical
      material in the devices being decommissioned.</t>
    </section><!--credential livecycle-->
 
    <section anchor="unprotected-as-information"
	       title="Unprotected AS Request Creation Hints">

	<t>Initially, no secure channel exists to protect the communication
	between C and RS. Thus, C cannot determine if the "AS Request
	Creation Hints" contained in an unprotected response from RS to an
	unauthorized request (see <xref target="asInfo"/>) are authentic. C
	therefore MUST determine if an AS is authorized to provide access
	tokens for a certain RS. How this determination is implemented is out
	of scope for this document and left to the applications.</t>
    </section>

    <section anchor="minimalCommSecReq" title="Minimal Security Requirements
						 for Communication">
	<t>This section summarizes the minimal requirements for the
	communication security of the different protocol interactions.

	<list style="hanging">
	  <t hangText="C-AS">All communication between the client and the
	  Authorization Server MUST be encrypted, integrity and replay
	  protected. Furthermore responses from the AS to the client MUST be
	  bound to the client's request to avoid attacks where the attacker
	  swaps the intended response for an older one valid for a previous
	  request.  This requires that the client and the Authorization Server
	  have previously exchanged either a shared secret or their public
	  keys in order to negotiate a secure communication. Furthermore the
	  client MUST be able to determine whether an AS has the authority
	  to issue access tokens for a certain RS.  This can for example be
	  done through pre-configured lists, or through an online lookup
	  mechanism that in turn also must be secured.
	  </t>

	  <t hangText="RS-AS">The communication between the Resource
	  Server and the Authorization Server via the introspection endpoint
	  MUST be encrypted, integrity and replay protected. Furthermore
	  responses from the AS to the RS MUST be bound to the RS's request.
	  This requires that the RS and the Authorization Server
	  have previously exchanged either a shared secret, or their public
	  keys in order to negotiate a secure communication. Furthermore the
	  RS MUST be able to determine whether an AS has the authority
	  to issue access tokens itself.  This is usually configured out of
	  band, but could also be performed through an online lookup mechanism
	  provided that it is also secured in the same way.</t>

	  <t hangText="C-RS">The initial communication between the client
	  and the Resource Server can not be secured in general, since
	  the RS is not in possession of on access token for that client,
	  which would carry the necessary parameters.  If both parties
	  support DTLS without client authentication it is RECOMMEND to use
	  this mechanism for protecting the initial communication.
	  After the client has successfully transmitted the access token to the
	  RS, a secure communication protocol MUST be established between
	  client and RS for the actual resource request.  This protocol MUST
	  provide confidentiality, integrity and replay protection as well as a
	  binding between requests and responses.  This requires that the
	  client learned either the RS's public key or received a symmetric
	  proof-of-possession key bound to the access token from the AS.
	  The RS must have learned either the client's public key or a shared
	  symmetric key from the claims in the token or an introspection
	  request.  Since ACE does not provide profile negotiation between
	  C and RS, the client MUST have learned what profile the RS
	  supports (e.g. from the AS or pre-configured) and initiate the
	  communication accordingly.</t>
	</list></t>
    </section>
    <section anchor="nonce" title="Token Freshness and Expiration">
	<t>An RS that is offline faces the problem of clock drift. Since it
	cannot synchronize its clock with the AS, it may be tricked
	into accepting old access tokens that are no longer valid or have been
	compromised.  In order to prevent this, an RS may use the nonce-based
	mechanism (cnonce) defined in <xref target="asInfo"/> to ensure
	freshness of an	Access Token subsequently presented to this RS.</t>

	<t>Another problem with clock drift is that evaluating the
	standard token expiration claim "exp" can give unpredictable results.
	</t>

	<t>Acceptable ranges of clock drift are highly dependent on the
	concrete application.  Important factors are how long access tokens
	are valid, and how critical timely expiration of access token is.</t>

	<t>The expiration mechanism implemented by the "exi" claim, based on
	the first time the RS sees the token was defined to provide a more
	predictable alternative.  The "exi" approach has some drawbacks that
	need to be considered:
	<list>
	  <t>A malicious client may hold back tokens with the "exi" claim in
	  order to prolong their lifespan.</t>
	  <t>If an RS loses state (e.g. due to an unscheduled reboot), it
	  may lose the current values of counters tracking the "exi" claims of
	  tokens it is storing.</t>
	</list>
	The first drawback is inherent to the deployment scenario and the "exi"
	solution.  It can therefore not be mitigated without requiring the
	RS be online at times.  The second drawback can be mitigated by
	regularly storing the value of "exi" counters to persistent memory.</t>
    </section>

    <section anchor="mixnmatch" title="Combining Profiles">
      <t>There may be use cases where different transport and security
      protocols are allowed for the different interactions, and, if that is
      not explicitly covered by an existing profile, it corresponds to
      combining profiles into a new one.  For example, a new profile could
      specify that a previously-defined MQTT-TLS profile is used between
      the client and the RS in combination with a previously-defined
      CoAP-DTLS profile for interactions between the client and the AS. The
      new profile that combines existing profiles MUST specify how the
      existing profiles' security properties are achieved. Any profile
      therefore MUST clearly specify its security requirements and MUST
      document if its security depends on the combination of various
      protocol interactions.</t>
    </section>
    
    <section anchor="infoLeak" title="Unprotected Information">
	<t>Communication with the authz-info endpoint, as well as the
	various error responses defined in this framework, all potentially
	include sending information over an unprotected channel.
	These messages may leak information to an adversary, or may be
	manipulated by active attackers to induce incorrect behavior.  For
	example	error responses for requests to the Authorization Information
	endpoint can reveal information about an otherwise opaque access token
	to an adversary who has intercepted this token.</t>

	<t>As far as error messages are concerned, this framework is written
	under the assumption that, in general, the benefits of detailed error
	messages outweigh the risk due to information leakage. For particular
	use cases, where this assessment does not apply, detailed error
	messages can be replaced by more generic ones.</t>

	<t>In some scenarios it may be possible to protect the
	communication with the authz-info endpoint (e.g. through
	DTLS with only server-side authentication). In cases where
	this is not possible, it is RECOMMENDED to use encrypted
	CWTs or tokens that are opaque references and need to be subjected to
	introspection by the RS.</t>

	<t>If the initial unauthorized resource request message (see <xref
	target="rreq"/>) is used, the client MUST make sure that it is
	not sending sensitive content in this request. While GET and DELETE
	requests only reveal the target URI of the resource, POST and PUT
	requests would reveal the whole payload of the intended operation.</t>

	<t>Since the client is not authenticated at the point when
	it is submitting an access token to the authz-info endpoint,
	attackers may be pretending to be a client and trying to trick
	an RS to use an obsolete profile that in turn specifies a
	vulnerable security mechanism via the authz-info endpoint.  Such an
	attack would require a valid access token containing an "ace_profile"
	claim requesting the use of said obsolete profile.  Resource Owners
	should update the configuration of their RS's to prevent them from
	using such obsolete profiles.</t>
    </section>

    <section anchor="audience" title="Identifying Audiences">
	<t>The audience claim as defined in <xref target="RFC7519"/>
	and the equivalent "audience" parameter from
	<xref target="RFC8693"/> are intentionally vague
	on how to match the audience value to a specific RS.  This is intended
	to allow application specific semantics to be used.  This section
	attempts to give some general guidance for the use of audiences in
	constrained environments.</t>

	<t>URLs are not a good way of identifying mobile devices that can
	switch networks and thus be associated with new URLs.  If the
	audience represents a single RS, and asymmetric keys are used,
	the RS can be uniquely identified by a hash of its public key.
	If this approach is used it is RECOMMENDED to apply the
	procedure from section 3 of <xref target="RFC6920"/>.</t>

	<t>If the audience addresses a group of resource servers, the mapping
	of group identifier to individual RS has to be provisioned to each RS
	before the group-audience is usable.  Managing dynamic groups could be
	an issue, if any RS is not always reachable when the groups' memberships
	change. Furthermore, issuing access tokens bound to symmetric
	proof-of-possession keys that apply to a group-audience is problematic,
	as an RS that is in possession of the access token can impersonate the
	client towards the other RSs that are part of the group.  It is
	therefore NOT RECOMMENDED to issue access tokens bound to a group
	audience and symmetric proof-of possession keys.</t>

	<t>Even the client must be able to determine the correct values to put
	into the "audience" parameter, in order to obtain a token for the
	intended RS.  Errors in this process can lead to the client
	inadvertently obtaining a token for the wrong RS.  The correct values
	for "audience" can either be provisioned to the client as part of its
	configuration, or dynamically looked up by the client in some
	directory. In the latter case the integrity and	correctness of the
	directory data must be assured.  Note that the "audience" hint
	provided by the RS as part of the "AS Request Creation Hints" <xref
	target="asInfo"/> is not typically source authenticated and integrity
	protected, and should therefore not be treated a trusted value.</t>
    </section>
     
    <section anchor="introDos" title="Denial of Service Against or with
					Introspection">
	<t>
	The optional introspection mechanism provided by OAuth and supported
	in the ACE framework allows for two types of attacks that need
	to be considered by implementers.</t>
	
	<t>First, an attacker could perform a denial of service attack against
	the introspection endpoint at the AS in order to prevent validation of
	access tokens.  To maintain the security of the system, an RS that is
	configured to use introspection MUST NOT allow access based on a token
	for which it couldn't reach the introspection endpoint.</t>

	<t>Second, an attacker could use the fact that an RS performs
	introspection to perform a denial of service attack against that RS by
	repeatedly sending tokens to its authz-info endpoint that require an
	introspection call. RS can mitigate such attacks by implementing rate
	limits on how many introspection requests they perform in a given time
	interval for a certain client IP address submitting tokens to
	/authz-info.  When that limit has been reached, incoming requests from
	that address are rejected for a certain	amount of time.  A general rate
	limit on the introspection requests should also be considered, to
	mitigate distributed attacks.</t>
	
    </section>
</section>

<section anchor="privacy" title="Privacy Considerations">
      <t>Implementers and users should be aware of the privacy implications
      of the different possible deployments of this framework.</t>

      <t>The AS is in a very central position and can potentially learn sensitive
      information about the clients requesting access tokens.  If the client
      credentials grant is used, the AS can track what kind of access
      the client intends to perform.  With other grants this can be prevented
      by the Resource Owner.  To do so, the resource owner needs to bind the
      grants it issues to anonymous, ephemeral credentials that do not allow
      the AS to link different grants and thus different access token requests
      by the same client.</t>

      <t>The claims contained in a token can reveal privacy sensitive
      information about the client and the RS to any party having access to
      them (whether by processing the content of a self-contained token or by
      introspection).  The AS SHOULD be configured to minimize the information
      about clients and RSs disclosed in the tokens it issues.</t>

      <t>If tokens are only integrity protected and not encrypted, they
      may reveal information to attackers listening on the wire, or able to
      acquire the access tokens in some other way.  In the case of CWTs
      the token may, e.g., reveal the audience, the scope and the confirmation
      method used by the client.  The latter may reveal the identity of the
      device or application running the client.  This may be linkable to
      the identity of the person using the client (if there is a person and
      not a machine-to-machine interaction).</t>

      <t>Clients using asymmetric keys for proof-of-possession should be aware
      of the consequences of using the same key pair for proof-of-possession
      towards different RSs.  A set of colluding RSs or an attacker able to
      obtain the access tokens will be able to link the requests, or even
      to determine the client's identity.</t>

      <t>An unprotected response to an unauthorized request (see 
      <xref target="asInfo"/>) may disclose information about RS and/or its
      existing relationship with C. It is advisable to include as little
      information as possible in an unencrypted response. Even the absolute URI of the AS may reveal sensitive information about the service that RS provides. Developers must ensure that the RS does not disclose information that has an impact on the privacy of the stakeholders in the "AS Request Creation Hints". They may choose to use a different mechanism for the discovery of the AS if necessary. If means of encrypting
      communication between C and RS already exist, more detailed information
      may be included with an error response to provide C with sufficient
      information to react on that particular error.</t>

</section>

<section anchor="iana" title="IANA Considerations">
  <t>This document creates several registries with a registration policy of
  "Expert Review"; guidelines to the experts are given in
  <xref target="IANAinstructions"/>.</t>
 
  <section anchor="IANAASInformation"
	   title="ACE Authorization Server Request Creation Hints">
    <t>This specification establishes the IANA "ACE Authorization Server
    Request Creation Hints" registry. The registry has been created to use the
    "Expert Review" registration procedure <xref target="RFC8126"/>.
    It should be noted that, in addition to the expert review, some portions of
    the registry require a specification, potentially a Standards Track RFC, be
    supplied as well.</t>
        
    <t>The columns of the registry are:
    
    <list style='hanging'>
      <t hangText='Name'>The name of the parameter</t>
      
      <t hangText='CBOR Key'>CBOR map key for the parameter.  Different ranges
      of values use different registration policies <xref target="RFC8126"/>.
      Integer values from -256 to 255 are designated as Standards
      Action.  Integer values from -65536 to -257 and from 256 to 65535
      are designated as Specification Required.  Integer values greater than
      65535 are designated as Expert Review.  Integer values less than -65536
      are marked as Private Use.</t>
      
      <t hangText='Value Type'>The CBOR data types allowable for the values of
      this parameter.</t>
      
      <t hangText='Reference'>This contains a pointer to the public
      specification of the request creation hint abbreviation, if one
      exists.</t>
    </list></t>
    
    <t>This registry will be initially populated by the values in
    <xref target="fig:asinfo"/>. The Reference column for all of
    these entries will be this document.</t>    
  </section>

  <section anchor="IANAcoreRT" title="CoRE Resource Type Registry">
    <t>IANA is requested to register a new Resource Type (rt=) Link Target
    Attribute in the "Resource Type (rt=) Link Target Attribute Values"
    subregistry under the "Constrained RESTful Environments (CoRE)
    Parameters" <xref target="IANA.CoreParameters"/> registry:</t>
    
    <t><?rfc subcompact="yes"?>
    <list style='symbols'>
      <t>Value: <spanx style="verb">ace.ai</spanx></t>
      <t>Description: ACE-OAuth authz-info endpoint resource.</t>
      <t>Reference: [this document]</t>
    </list></t>
    <t>Specific ACE-OAuth profiles can use this common resource type for
   defining their profile-specific discovery processes.</t>
  </section>
   
  <section anchor="IANAOAuthErrorCodes"
	   title="OAuth Extensions Error Registration">
    <t>This specification registers the following error values in the OAuth
    Extensions Error registry
    <xref target="IANA.OAuthExtensionsErrorRegistry"/>.</t>

    <t><?rfc subcompact="yes"?>
    <list style='symbols'>
      <t>Error name: <spanx style="verb">unsupported_pop_key</spanx></t>
      <t>Error usage location: token error response</t>
      <t>Related protocol extension: [this document]</t>
      <t>Change Controller: IETF</t>
      <t>Specification document(s): <xref target="errorsToken"/> of
      [this document]</t>
    </list></t>
    
    <t><?rfc subcompact="yes"?>
    <list style='symbols'>
      <t>Error name: <spanx style="verb">incompatible_ace_profiles</spanx></t>
      <t>Error usage location: token error response</t>
      <t>Related protocol extension: [this document]</t>
      <t>Change Controller: IETF</t>
      <t>Specification document(s): <xref target="errorsToken"/> of
      [this document]</t>
    </list></t>
  </section>
  <section anchor="IANAErrorCBORMappings"
	   title="OAuth Error Code CBOR Mappings Registry">
    <t>This specification establishes the IANA "OAuth Error Code
    CBOR Mappings" registry.  The registry has been created to use the "Expert
    Review" registration procedure <xref target="RFC8126"/>, except
    for the value range designated for private use.</t>
    
    <t>The columns of the registry are:
   
    <list style='hanging'>
      <t hangText='Name'>The OAuth Error Code name, refers to the name in
      Section 5.2. of <xref target="RFC6749"/>, e.g., "invalid_request".</t>
      
      <t hangText='CBOR Value'>CBOR abbreviation for this error code.  Integer
      values less than -65536 are marked as "Private Use", all other values use
      the registration policy "Expert Review" <xref target="RFC8126"/>.</t>
      
      <t hangText='Reference'>This contains a pointer to the public
      specification of the error code abbreviation, if one exists.</t>

      <t hangText='Original Specification'>This contains a pointer to
      the public specification of the error code, if one exists.</t>
    </list></t>
    
    <t>This registry will be initially populated by the values in
    <xref target="fig:cborErrorCodes"/>. The Reference column for all of
    these entries will be this document.</t>	  
  </section>

  <section anchor="IANAGrantTypeMappings"
	   title="OAuth Grant Type CBOR Mappings">
    <t>This specification establishes the IANA "OAuth Grant Type CBOR Mappings"
    registry.  The registry has been created to use the "Expert Review"
    registration procedure <xref target="RFC8126"/>, except for the value range
    designated for private use. </t>
    
    <t>The columns of this registry are:
    
    <list style='hanging'>
      <t hangText='Name'>The name of the grant type as specified in
      Section 1.3 of <xref target="RFC6749"/>.</t>

      <t hangText='CBOR Value'>CBOR abbreviation for this grant type.  Integer
      values less than -65536 are marked as "Private Use", all other values use
      the registration policy "Expert Review" <xref target="RFC8126"/>.</t>
            
      <t hangText='Reference'>This contains a pointer to the public
      specification of the grant type abbreviation, if one exists.</t>
	  
      <t hangText='Original Specification'>This contains a pointer to
      the public specification of the grant type, if one exists.</t>
    </list></t>
    
    <t>This registry will be initially populated by the values in
    <xref target="fig:grant_types"/>. The Reference column for all of
    these entries will be this document.</t> 
  </section>

   <section anchor="IANAOAuthTokenType" title="OAuth Access Token Types">
    <t>This section registers the following new token type in the
    "OAuth Access Token Types" registry <xref
    target="IANA.OAuthAccessTokenTypes"/>.</t>
    <t><?rfc subcompact="yes"?>
    <list style='symbols'>
      <t>Type name: <spanx style="verb">PoP</spanx></t>
      <t>Additional Token Endpoint Response Parameters: "cnf", "rs_cnf"
      see section 3.1 of <xref target="RFC8747"/> and section 3.1 of 
      <xref target="I-D.ietf-ace-oauth-params"/>.</t>
      <t>HTTP Authentication Scheme(s): N/A</t>
      <t>Change Controller: IETF</t>
      <t>Specification document(s): [this document]</t>
    </list></t>
   </section>

   <section anchor="IANATokenTypeMappings"
	   title="OAuth Access Token Type CBOR Mappings">
     <t>This specification established the IANA "OAuth Access Token Type CBOR
     Mappings" registry.  The registry has been created to use the "Expert
     Review" registration procedure <xref target="RFC8126"/>, except for the
     value range designated for private use. </t>

    <t>The columns of this registry are:
    
    <list style='hanging'>
      <t hangText='Name'>The name of token type as registered in the
      OAuth Access Token Types registry, e.g., "Bearer".</t>
	  
      <t hangText='CBOR Value'>CBOR abbreviation for this token type.  Integer
      values less than -65536 are marked as "Private Use", all other values use
      the registration policy "Expert Review" <xref target="RFC8126"/>.</t>
      
      <t hangText='Reference'>This contains a pointer to the public
      specification of the OAuth token type abbreviation, if one exists.</t>
	  
      <t hangText='Original Specification'>This contains a pointer to
      the public specification of the OAuth token type, if one exists.</t>
    </list></t>
	
    <section anchor="IANATokenTypeMappingsInitial" title="Initial Registry Contents">
      <t>
        <?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Name: <spanx style="verb">Bearer</spanx></t>
          <t>Value:  1</t>
          <t>Reference:  [this document]</t>
	  <t>Original Specification:  <xref target="RFC6749"/></t>
        </list>
      </t>
      <t>
        <?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Name: <spanx style="verb">PoP</spanx></t>
          <t>Value: 2</t>
          <t>Reference: [this document]</t>
	  <t>Original Specification:  [this document]</t>
        </list>
      </t>
    </section>
  </section>

 <section anchor="IANAProfile"
	   title="ACE Profile Registry">
   <t>This specification establishes the IANA "ACE Profile" registry.  The
   registry has been created to use the "Expert Review" registration
   procedure <xref target="RFC8126"/>.  It should be noted that, in addition to
   the expert review, some portions of the registry require a specification,
   potentially a Standards Track RFC, be supplied as well.</t>

   <t>The columns of this registry are:
    
    <list style='hanging'>
      <t hangText='Name'> The name of the profile, to be used as value of
      the profile attribute.</t>
      
      <t hangText='Description'> Text giving an overview of the profile and
      the context it is developed for.</t>

      <t hangText='CBOR Value'>CBOR abbreviation for this profile name.
      Different ranges of values use different registration policies <xref
      target="RFC8126"/>.  Integer values from -256 to 255 are designated as
      Standards Action.  Integer values from -65536 to -257 and from 256 to
      65535 are designated as Specification Required.  Integer values greater
      than 65535 are designated as "Expert Review".  Integer values less than
      -65536 are marked as Private Use.</t>      
      
      <t hangText='Reference'>This contains a pointer to the public
      specification of the profile abbreviation, if one exists.</t>
   </list></t>

   <t>This registry will be initially empty and will be populated by the
   registrations from the ACE framework profiles.</t>
  </section>
  
  <section anchor="IANAOAuthParameter"
	   title="OAuth Parameter Registration">
    <t>This specification registers the following parameter in the "OAuth
    Parameters" registry <xref target="IANA.OAuthParameters"/>:</t>
    <t><?rfc subcompact="yes"?>
    <list style='symbols'>
      <t>Name: <spanx style="verb">ace_profile</spanx></t>
      <t>Parameter Usage Location: token response</t>
      <t>Change Controller: IETF</t>
      <t>Reference: <xref target="tokenResponse"/> and
      <xref target="paramProfile"/> of [this document]</t>
    </list></t>  
  </section>

  <section anchor="IANAOAuthParameterMappingsRegistry"
	   title="OAuth Parameters CBOR Mappings Registry">
    <t>This specification establishes the IANA "OAuth Parameters CBOR Mappings"
    registry.  The registry has been created to use the "Expert Review"
    registration procedure <xref target="RFC8126"/>, except for the value range
    designated for private use.</t>
    
    <t>The columns of this registry are:
    
    <list style='hanging'>
      <t hangText='Name'>The OAuth Parameter name, refers to the name in
      the OAuth parameter registry, e.g., "client_id".</t>
      
      <t hangText='CBOR Key'>CBOR map key for this parameter.  Integer
      values less than -65536 are marked as "Private Use", all other values use
      the registration policy "Expert Review" <xref target="RFC8126"/>.</t>
      
      <t hangText='Value Type'>The allowable CBOR data types for values
      of this parameter.</t>
      
      <t hangText='Reference'>This contains a pointer to the public
      specification of the OAuth parameter abbreviation, if one exists.</t>
     
      <t hangText='Original Specification'>This contains a pointer to
      the public specification of the OAuth parameter, if one exists.</t>
    </list></t>
    
    <t>This registry will be initially populated by the values in
    <xref target="fig:cborTokenParameters"/>. The Reference column for all of
    these entries will be this document.</t>
  </section>
  
  <section anchor="IANAOAuthIntrospectionResponseParameterRegistration"
	   title="OAuth Introspection Response Parameter Registration">
    <t>This specification registers the following parameters in the OAuth
    Token Introspection Response registry <xref
    target="IANA.TokenIntrospectionResponse"/>.</t>
    <t>
      <?rfc subcompact="yes"?>
      <list style='symbols'>
        <t>Name: <spanx style="verb">ace_profile</spanx></t>
        <t>Description: The ACE profile used between client and RS.</t>
        <t>Change Controller: IETF</t>
        <t>Reference: <xref target="introRes"/> of [this document]</t>
      </list>
    </t>
    <t>
      <?rfc subcompact="yes"?>
      <list style='symbols'>
        <t>Name: <spanx style="verb">cnonce</spanx></t>
        <t>Description: "client-nonce". A nonce previously provided
	to the AS by the RS via the client.  Used to verify token freshness
	when the RS cannot synchronize its clock with the AS.</t>
        <t>Change Controller: IETF</t>
        <t>Reference: <xref target="introRes"/> of [this document]</t>
      </list>
    </t>
    <t>
      <?rfc subcompact="yes"?>
      <list style='symbols'>
        <t>Name: <spanx style="verb">cti</spanx></t>
        <t>Description: "CWT ID". The identifier of a CWT as defined
         in <xref target="RFC8392"/>.</t>
        <t>Change Controller: IETF</t>
        <t>Reference: <xref target="introRes"/> of [this document]</t>
      </list>
    </t>
    <t>
      <?rfc subcompact="yes"?>
      <list style='symbols'>
        <t>Name: <spanx style="verb">exi</spanx></t>
        <t>Description: "Expires in". Lifetime of the token in seconds
	from the time the RS first sees it.  Used to implement a weaker from of
	token expiration for devices that cannot synchronize their internal
	clocks.</t>
        <t>Change Controller: IETF</t>
        <t>Reference: <xref target="introRes"/> of [this document]</t>
      </list>
    </t>
  </section>
  
  <section anchor="IANAIntrospectionEndpointCBORMappingsRegistry"
	   title="OAuth Token Introspection Response CBOR Mappings Registry">
    <t>This specification establishes the IANA "OAuth Token Introspection
    Response CBOR Mappings" registry.  The registry has been created to use the
    "Expert Review" registration procedure <xref target="RFC8126"/>, except for
    the value range designated for private use.</t> 

    <t>The columns of this registry are:
    
    <list style='hanging'>
      <t hangText='Name'>The OAuth Parameter name, refers to the name in
      the OAuth parameter registry, e.g., "client_id".</t>
      
      <t hangText='CBOR Key'>CBOR map key for this parameter.  Integer
      values less than -65536 are marked as "Private Use", all other values use
      the registration policy "Expert Review" <xref target="RFC8126"/>.</t>
      
      <t hangText='Value Type'>The allowable CBOR data types for values
      of this parameter.</t>
      
      <t hangText='Reference'>This contains a pointer to the public
      specification of the introspection response parameter abbreviation, if
      one exists.</t>

      <t hangText='Original Specification'>This contains a pointer to
      the public specification of OAuth Token Introspection parameter, 
      if one exists.</t>
    </list></t>
    
    <t>This registry will be initially populated by the values in
    <xref target="fig:cborIntrospectionParameters"/>. The Reference column for
    all of these entries will be this document.</t>

    <t>Note that the mappings of parameters corresponding to claim names
    intentionally coincide with the CWT claim name mappings from <xref
    target="RFC8392"/>.</t>
  </section>

 <section anchor="IANAJWTClaims" title="JSON Web Token Claims">
   <t>This specification registers the following new claims in the JSON
   Web Token (JWT) registry of JSON Web Token Claims <xref
   target="IANA.JsonWebTokenClaims"/>:</t>
   
    <t><?rfc subcompact="yes"?>
    <list style='symbols'>
      <t>Claim Name: <spanx style="verb">ace_profile</spanx></t>
      <t>Claim Description: The ACE profile a token is supposed to be used
      with.</t>
      <t>Change Controller: IETF</t>
      <t>Reference: <xref target="accessToken"/> of [this document]</t>
    </list></t>

    <t><?rfc subcompact="yes"?>
    <list style='symbols'>
      <t>Claim Name: <spanx style="verb">cnonce</spanx></t>
      <t>Claim Description: "client-nonce". A nonce previously provided
      to the AS by the RS via the client.  Used to verify token freshness
      when the RS cannot synchronize its clock with the AS.</t>
      <t>Change Controller: IETF</t>
      <t>Reference: <xref target="accessToken"/> of [this document]</t>
    </list></t>
    
    <t><?rfc subcompact="yes"?>
    <list style='symbols'>
      <t>Claim Name: <spanx style="verb">exi</spanx></t>
      <t>Claim Description: "Expires in". Lifetime of the token in seconds
      from the time the RS first sees it.  Used to implement a weaker from of
      token expiration for devices that cannot synchronize their internal
      clocks.</t>
      <t>Change Controller: IETF</t>
      <t>Reference: <xref target="tokenExpiration"/> of [this document]</t>
    </list></t>
 
 </section>
  
  <section anchor="IANACWTClaims" title="CBOR Web Token Claims">
    <t>This specification registers the following new claims in the "CBOR
    Web Token (CWT) Claims" registry <xref
    target="IANA.CborWebTokenClaims"/>.</t>
       
    <t><?rfc subcompact="yes"?>
    <list style='symbols'>
      <t>Claim Name: <spanx style="verb">ace_profile</spanx></t>
      <t>Claim Description: The ACE profile a token is supposed to be used
      with.</t>
      <t>JWT Claim Name: ace_profile</t>
      <t>Claim Key: TBD (suggested: 38)</t>
      <t>Claim Value Type(s): integer</t>
      <t>Change Controller: IETF</t>
      <t>Specification Document(s): <xref target="accessToken"/> of [this
      document]</t>
    </list></t>

    <t><?rfc subcompact="yes"?>
    <list style='symbols'>
      <t>Claim Name: <spanx style="verb">cnonce</spanx></t>
      <t>Claim Description: The client-nonce sent to the AS by the
      RS via the client.</t>
      <t>JWT Claim Name: cnonce</t>
      <t>Claim Key: TBD (suggested: 39)</t>
      <t>Claim Value Type(s): byte string</t>
      <t>Change Controller: IETF</t>
      <t>Specification Document(s): <xref target="accessToken"/> of [this
      document]</t>
    </list></t>
    
    <t><?rfc subcompact="yes"?>
    <list style='symbols'>
      <t>Claim Name: <spanx style="verb">exi</spanx></t>
      <t>Claim Description: The expiration time of a token measured from
      when it was received at the RS in seconds.</t>
      <t>JWT Claim Name: exi</t>
      <t>Claim Key: TBD (suggested: 40)</t>
      <t>Claim Value Type(s): integer</t>
      <t>Change Controller: IETF</t>
      <t>Specification Document(s): <xref target="tokenExpiration"/> of [this
      document]</t>
    </list></t>

     <t><?rfc subcompact="yes"?>
    <list style='symbols'>
      <t>Claim Name: <spanx style="verb">scope</spanx></t>
      <t>Claim Description: The scope of an access token as
      defined in <xref target="RFC6749"/>.</t>
      <t>JWT Claim Name: scope</t>
      <t>Claim Key: TBD (suggested: 9)</t>
      <t>Claim Value Type(s): byte string or text string</t>
      <t>Change Controller: IETF</t>
      <t>Specification Document(s): Section 4.2 of
      <xref target="RFC8693"/></t>
     </list></t>
     
  </section>

  <section anchor="IANAmediaType" title="Media Type Registrations">
    <t>This specification registers the 'application/ace+cbor' media type for
    messages of the protocols defined in this document carrying parameters
    encoded in CBOR.  This registration follows the procedures specified in
    <xref target="RFC6838"/>.</t>

    <t>Type name: application</t>
    
    <t>Subtype name: ace+cbor</t>
      
    <t>Required parameters: N/A</t>

    <t>Optional parameters: N/A</t>

    <t>Encoding considerations: Must be encoded as CBOR map containing
    the protocol parameters defined in [this document].</t>

    <t>Security considerations: See <xref target="security"/> of [this
    document]</t>

    <t>Interoperability considerations: N/A</t>
    
    <t>Published specification: [this document]</t>
      
    <t>Applications that use this media type: The type is used by
    authorization servers, clients and resource servers that support the ACE
    framework with CBOR encoding as specified in [this document].</t>

    <t>Fragment identifier considerations: N/A </t>

    <t>Additional information: N/A</t>
    
    <t>Person &amp; email address to contact for further information: 
    &lt;iesg@ietf.org&gt;</t>
    
    <t>Intended usage: COMMON</t>
      
    <t>Restrictions on usage: none</t>
    
    <t>Author: Ludwig Seitz &lt;ludwig.seitz@combitech.se&gt;</t>
    
    <t>Change controller: IETF</t>
  </section>
    
  <section anchor="IANAcoapContentFormat" title="CoAP Content-Format Registry">
    <t>This specification registers the following entry to the "CoAP
    Content-Formats"
    registry:</t>
    <t>Media Type: application/ace+cbor</t>
    <t>Encoding: -</t>
    <t>ID: TBD (suggested: 19)</t>
    <t>Reference: [this document]</t>
  </section>

  <section anchor="IANAinstructions" title="Expert Review Instructions">
    <t>All of the IANA registries established in this document are defined
   to use a registration policy of Expert Review.  This section gives some general guidelines for
   what the experts should be looking for, but they are being designated
   as experts for a reason, so they should be given substantial
    latitude.</t>

    <t>Expert reviewers should take into consideration the following points:
    <list style="symbols">
      <t>Point squatting should be discouraged.  Reviewers are encouraged
      to get sufficient information for registration requests to ensure
      that the usage is not going to duplicate one that is already
      registered, and that the point is likely to be used in deployments.  The
      zones tagged as private use are intended for testing purposes and closed
      environments; code points in other ranges should not be assigned for
      testing.</t>

      <t>Specifications are needed for the first-come, first-serve range if
      they are expected to be used outside of closed environments in an
      interoperable way.  When specifications are not provided, the description
      provided needs to have sufficient information to identify what the point
      is being used for.</t>
      
      <t>Experts should take into account the expected usage of fields when
      approving point assignment.  The fact that there is a range for
      standards track documents does not mean that a standards track
      document cannot have points assigned outside of that range.  The
      length of the encoded value should be weighed against how many
      code points of that length are left, the size of device it will be
      used on.</t>

      <t>Since a high degree of overlap is expected between these registries
      and the contents of the OAuth parameters <xref
      target="IANA.OAuthParameters"/> registries, experts should require new
      registrations to maintain alignment with parameters from OAuth that have
      comparable functionality.  Deviation from this alignment should only
      be allowed if there are functional differences, that are motivated by
      the use case and that cannot be easily or efficiently addressed by
      comparable OAuth parameters.</t>
    </list></t>
  </section>
  
</section><!-- IANA considerations -->

<section anchor="Acknowledgments" title="Acknowledgments">
  <t>This document is a product of the ACE working group of the IETF.</t>
  
  <t>Thanks to Eve Maler for her contributions to the use of
  OAuth 2.0 and UMA in IoT scenarios, Robert Taylor for his discussion
  input, and Malisa Vucinic for his input on the predecessors of this
  proposal.</t>
  
  <t>Thanks to the authors of draft-ietf-oauth-pop-key-distribution, from where
  parts of the security considerations where copied.</t>
  
  <t>Thanks to Stefanie Gerdes, Olaf Bergmann, and Carsten
  Bormann for contributing their work on AS discovery from
  draft-gerdes-ace-dcaf-authorize (see <xref target="asDiscovery"/>) and
  the considerations on multiple access tokens.</t>

  <t>Thanks to Jim Schaad and Mike Jones for their comprehensive reviews.</t>

  <t>Thanks to Benjamin Kaduk for his input on various questions related to
  this work.</t>

  <t>Thanks to Cigdem Sengul for some very useful review comments.</t>

  <t>Thanks to Carsten Bormann for contributing the text for the CoRE Resource
  Type registry.</t>

  <t>Thanks to Roman Danyliw for suggesting the <xref target="app:diffOAuth"/>
  (including its contents).</t>

  <t>Ludwig Seitz and Goeran Selander worked on this document as part of
  the CelticPlus project CyberWI, with funding from Vinnova. Ludwig Seitz
  was also received further funding for this work by Vinnova in the context of
  the CelticNext project Critisec.</t>
</section>
    
    <!-- Possibly a 'Contributors' section ... -->
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &RFC2119;
      &RFC3986;
      &RFC6347;
      &RFC6749;    
      &RFC6750;
      &RFC6838;
      &RFC6920;
      &RFC8949;
      &RFC7252;
      &RFC7519;  
      &RFC7662;
      &RFC8126;
      &RFC8152;    
      &RFC8174;
      &RFC8392;
      &RFC8693;
      &RFC8747;
      &I-D.ietf-ace-oauth-params;

      <reference anchor="IANA.OAuthAccessTokenTypes" target="https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#token-types">
	<front>
	  <title>OAuth Access Token Types</title>
	  <author>
	    <organization>IANA</organization>
	  </author>
	  <date/>
	</front>
      </reference>
      
      <reference anchor="IANA.OAuthParameters" target="https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#parameters">
	<front>
	  <title>OAuth Parameters</title>
	  <author>
	    <organization>IANA</organization>
	  </author>
	  <date/>
	</front>
      </reference>
      
      <reference anchor="IANA.TokenIntrospectionResponse" target="https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#token-introspection-response">
	<front>
	  <title>OAuth Token Introspection Response</title>
	  <author>
	    <organization>IANA</organization>
	  </author>
	  <date/>
	</front>
      </reference>
      
      <reference anchor="IANA.JsonWebTokenClaims" target="https://www.iana.org/assignments/jwt/jwt.xhtml#claims">
	<front>
	  <title>JSON Web Token Claims</title>
	  <author>
	    <organization>IANA</organization>
	  </author>
	  <date/>
	</front>
      </reference>
      
      <reference anchor="IANA.CborWebTokenClaims" target="https://www.iana.org/assignments/cwt/cwt.xhtml#claims-registry">
	<front>
	  <title>CBOR Web Token (CWT) Claims</title>
	  <author>
	    <organization>IANA</organization>
	  </author>
	  <date/>
	</front>
      </reference>

      <reference anchor="IANA.OAuthExtensionsErrorRegistry" target="https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#extensions-error">
	<front>
	  <title>OAuth Extensions Error Registry</title>
	  <author>
	    <organization>IANA</organization>
	  </author>
  <date/>
	</front>
      </reference>

      <reference anchor="IANA.CoreParameters"
		 target="https://www.iana.org/assignments/core-parameters/core-parameters.xhtml">
	<front>
	  <title>Constrained RESTful Environments (CoRE) Parameters</title>
	  <author>
	    <organization>IANA</organization>
	  </author>
	  <date/>
	</front>
      </reference>
      
    </references>

    <references title="Informative References">
      &RFC4949;
      &RFC6690;
      &RFC6819;
      &RFC7009;
      &RFC7228;
      &RFC7231;
      &RFC7521;
      &RFC7540;
      &RFC7591;  
      &RFC7641;
      &RFC7744;
      &RFC7959;
      &RFC8252;
      &RFC8259;
      &RFC8414;
      &RFC8446;
      &RFC8516;
      &RFC8613;
      &RFC8628;
      &I-D.ietf-tls-dtls13;
      &I-D.erdtman-ace-rpcc;
      &I-D.ietf-quic-transport;
      &I-D.ietf-ace-oscore-profile;
      &I-D.ietf-ace-dtls-authorize;
      <reference anchor="Margi10impact">
        <front>
          <title>Impact of Operating Systems on Wireless Sensor Networks
	  (Security) Applications and Testbeds</title>
            <author initials="C. B." surname="Margi"/>
            <author initials="B.T." surname="de Oliveira"/>
	    <author initials="G.T." surname="de Sousa"/>
	    <author initials="M.A." surname="Simplicio Jr"/>
	    <author initials="P.S.L.M." surname="Barreto"/>
	    <author initials="T.C.M.B." surname="Carvalho"/>
	    <author initials="M." surname="Naeslund"/>
	    <author initials="R." surname="Gold"/>
            <date year="2010" month="August" />
        </front>
        <seriesInfo name="Proceedings of the" value="19th International Conference on Computer Communications and Networks (ICCCN)"/>
      </reference>
      <reference anchor="MQTT5.0" target="https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html">
	 <front>
          <title>MQTT Version 5.0</title>
            <author initials="A." surname="Banks"/>
            <author initials="E." surname="Briggs"/>
	    <author initials="K." surname="Borgendale"/>
	    <author initials="R." surname="Gupta"/>
            <date year="2019" month="March"/>
        </front>
        <seriesInfo name="OASIS" value="Standard"/>
      </reference>
      <reference anchor="BLE" target="https://www.bluetooth.com/specifications/bluetooth-core-specification/">
	 <front>
          <title>Bluetooth Core Specification v5.1</title>
            <author initials="" surname="Bluetooth SIG"/>
	    <date year="2019" month="January"/>
        </front>
        <seriesInfo name="Section" value="4.4"/>
      </reference>
      
      

    </references>

    <section title="Design Justification" anchor="constraints">     
     <t>This section provides further insight into the design decisions
     of the solution documented in this document.  <xref target="overview"/>
     lists several building blocks and briefly summarizes their importance.
     The justification for offering some of those building blocks, as opposed
     to using OAuth 2.0 as is, is given below.</t>

     <t>Common IoT constraints are:

        <list style="hanging">

          <t hangText="Low Power Radio:"><vspace blankLines="1"/>
          Many IoT devices are equipped with a small battery which needs
          to last for a long time.  For many constrained wireless devices, the
          highest energy cost is associated to transmitting or receiving
          messages (roughly by a factor of 10 compared to AES)
	  <xref target="Margi10impact"/>.  It is therefore important to keep
	  the total communication overhead low, including minimizing the number
	  and size of messages sent and received, which has an impact of choice
	  on the message format and protocol.  By using CoAP over UDP and CBOR
	  encoded messages, some of these aspects are addressed.  Security
	  protocols contribute to the communication overhead and can, in some
	  cases, be optimized.  For example, authentication and key
	  establishment may, in certain cases where security requirements
	  allow, be replaced by provisioning of security context by a trusted
	  third party, using transport or application-layer security.
	  <vspace blankLines="0"/>
          </t>

          <t hangText="Low CPU Speed:"><vspace blankLines="1"/>
          Some IoT devices are equipped with processors that are significantly
          slower than those found in most current devices on the Internet.
          This typically has implications on what timely cryptographic
          operations a device is capable of performing, which in turn impacts,
          e.g., protocol latency.  Symmetric key cryptography may be used
          instead of the computationally more expensive public key cryptography
          where the security requirements so allow, but this may also require
          support for trusted-third-party-assisted secret key establishment
          using transport- or application-layer security.
	  <vspace blankLines="0"/></t>

          <t hangText="Small Amount of Memory:"> <vspace blankLines="1"/>
          Microcontrollers embedded in IoT devices are often equipped with
          only a small amount of RAM and flash memory, which places limitations on what
          kind of processing can be performed and how much code can be put on
          those devices.  To reduce code size, fewer and smaller protocol
          implementations can be put on the firmware of such a device.  In
          this case, CoAP may be used instead of HTTP,  symmetric-key
          cryptography instead of public-key cryptography, and CBOR instead of
          JSON.  An authentication and key establishment protocol, e.g., the DTLS
          handshake,  in comparison with assisted key establishment, also has
          an impact on memory and code footprints.<vspace blankLines="0"/>
          </t>

          <t hangText="User Interface Limitations:"> <vspace blankLines="1"/>
          Protecting access to resources is both an important security as well
          as privacy feature.  End users and enterprise customers may not want
          to give access to the data collected by their IoT device or to
          functions it may offer to third parties.  Since the classical
          approach of requesting permissions from end users via a rich user
          interface does not work in many IoT deployment scenarios, these
          functions need to be delegated to user-controlled devices that are
          better suitable for such tasks, such as smart phones and tablets.
	  <vspace blankLines="1"/></t>

          <t hangText="Communication Constraints:"> <vspace blankLines="1"/>
          In certain constrained settings an IoT device may not be able to
          communicate with a given device at all times.  Devices may be
          sleeping, or just disconnected from the Internet because of general
          lack of connectivity in the area, for cost reasons, or for security
          reasons, e.g., to avoid an entry point for Denial-of-Service attacks.

          <vspace blankLines="1"/>
          The communication interactions this framework builds upon (as shown
          graphically in <xref target="fig:protocolFlow"/>) may be accomplished
          using a variety of different protocols, and not all parts of the
          message flow are used in all applications due to the communication
          constraints.  Deployments making use of CoAP are expected, but this framework is not
          limited to them.  Other protocols such as HTTP, or even protocols
          such as Bluetooth Smart communication that do not
          necessarily use IP, could also be used.  The latter raises the need
          for application-layer security over the various interfaces.</t>
        </list>
      </t>

      <t>In the light of these constraints we have made the following design
      decisions:

        <list style="hanging">

          <t hangText="CBOR, COSE, CWT:"><vspace blankLines="1"/>
	  When using this framework, it is RECOMMENDED to use CBOR 
	  <xref target="RFC8949"/> as data format.  Where CBOR data needs to be
	  protected, the use of COSE <xref target="RFC8152"/> is RECOMMENDED. 
	  Furthermore, where self-contained tokens are needed, it is RECOMMENDED
	  to use of CWT <xref target="RFC8392"/>.  These measures aim at reducing
	  the size of messages sent over the wire, the RAM size of data objects
	  that need to be kept in memory and the size of libraries that devices
	  need to support.
	  <vspace blankLines="1"/></t>

	  <t hangText="CoAP:"><vspace blankLines="1"/>
	  When using this framework, it is RECOMMENDED to use of CoAP 
	  <xref target="RFC7252"/> instead of HTTP.  This does not preclude the
	  use of other protocols specifically aimed at constrained devices, like,
	  e.g., Bluetooth Low Energy (see <xref target="coap"/>).  This aims
	  again at reducing the size of messages sent over the wire, the RAM size
	  of data objects that need to be kept in memory and the size of 
	  libraries that devices need to support.
	  <vspace blankLines="1"/></t>
	  
	  <t hangText="Access Information:"><vspace blankLines="1"/>
	  This framework defines the name "Access Information" for data
	  concerning the RS that the AS returns to the client in an access
	  token response (see  <xref target="tokenResponse"/>).  This aims at
	  enabling scenarios where a powerful client, supporting multiple
	  profiles, needs to interact with an RS for which it does not know the
	  supported profiles and the raw public key.
	  <vspace blankLines="1"/></t>	  
	  
	  <t hangText="Proof-of-Possession:"><vspace blankLines="1"/>
	  This framework makes use of proof-of-possession tokens, using
	  the "cnf" claim <xref target="RFC8747"/>.  A request
	  parameter "cnf" and a Response parameter "cnf", both having a
	  value space semantically and syntactically identical to the "cnf"
	  claim, are defined for the token endpoint, to allow requesting and
	  stating confirmation keys.  This aims at making token theft harder.
	  Token theft is specifically relevant in constrained use cases, as
	  communication often passes through middle-boxes, which could be able
	  to steal bearer tokens and use them to gain unauthorized access.
	  <vspace blankLines="1"/> </t>

	  <t hangText="Authz-Info endpoint:"><vspace blankLines="1"/>
	  This framework introduces a new way of providing access tokens
	  to an RS by exposing a authz-info endpoint, to which access tokens
	  can be POSTed.  This aims at reducing the size of the request
	  message and the code complexity at the RS.  The size of the request
	  message is problematic, since many constrained protocols have severe
	  message size limitations at the physical layer (e.g., in the order of
	  100 bytes). This means that larger packets get fragmented, which in
	  turn combines badly with the high rate of packet loss, and the
	  need to retransmit the whole message if one packet gets lost.
	  Thus separating sending of the request and sending of the access
	  tokens helps to reduce fragmentation.
	  <vspace blankLines="1"/></t>
	  
	  <t hangText="Client Credentials Grant:"><vspace blankLines="1"/>
	  In this framework the use of the client credentials grant is
	  RECOMMENDED for machine-to-machine communication use cases, where 
	  manual intervention of the resource owner to produce a grant token is
	  not feasible.  The intention is that the resource owner would instead
	  pre-arrange authorization with the AS, based on the client's own
	  credentials.  The client can then (without manual intervention) obtain
	  access tokens from the AS.
	  <vspace blankLines="1"/></t>

	  <t hangText="Introspection:"><vspace blankLines="1"/>
	  In this framework the use of access token introspection is RECOMMENDED
	  in cases where the client is constrained in a way that it can not
	  easily obtain new access tokens (i.e. it has connectivity issues
	  that prevent it from communicating with the AS). In that case
	  it is RECOMMENDED to use a long-term token, that could be a simple
	  reference.  The RS is assumed to be able to communicate
	  with the AS, and can therefore perform introspection, in order to
	  learn the claims associated with the token reference.  The advantage
	  of such an approach is that the resource owner can change the claims
	  associated to the token reference without having to be in contact
	  with the client, thus granting or revoking access rights.
	  <vspace blankLines="1"/></t>
 
	</list>
      </t>
      
    </section>

    <section anchor="app:rolesAndResponsibilities" title="Roles and Responsibilities">
      <t><list style="hanging">
	<t hangText="Resource Owner">
	  <list style="symbols">
	    <t>Make sure that the RS is registered at the AS.  This includes
	    making known to the AS which profiles, token_type, scopes, and
	    key types (symmetric/asymmetric) the RS supports. Also making
	    it known to the AS which audience(s) the RS identifies itself
	    with.</t>
	    <t>Make sure that clients can discover the AS that is in charge
	    of the RS.</t>
	    <t>If the client-credentials grant is used, make sure that the AS
	    has the necessary, up-to-date, access control policies for the
	    RS.</t>
	  </list>
	  <vspace blankLines="0"/>
	</t>
	<t hangText="Requesting Party">
	  <list style="symbols">
	    <t>Make sure that the client is provisioned the necessary
	    credentials to authenticate to the AS.</t>
	    <t>Make sure that the client is configured to follow the security
	    requirements of the Requesting Party when issuing requests
	    (e.g., minimum communication security requirements, trust
	    anchors).</t>
	    <t>Register the client at the AS.  This includes making known to
	    the AS which profiles, token_types, and key types
	    (symmetric/asymmetric) the client.</t>
          </list>
	  <vspace blankLines="0"/>
        </t>
	<t hangText="Authorization Server">
	  <list style="symbols">
	    <t>Register the RS and manage corresponding security contexts.</t>
            <t>Register clients and authentication credentials.</t>
	    <t>Allow Resource Owners to configure and update access control
	    policies related to their registered RSs.</t>
	    <t>Expose the token endpoint to allow  clients to request
	    tokens.</t>
            <t>Authenticate clients that wish to request a token.</t>
	    <t>Process a token request using the authorization
	    policies configured for the RS.</t>
	    <t>Optionally:  Expose the introspection endpoint that allows
	    RS's to submit token introspection requests.</t>
	    <t>If providing an introspection endpoint: Authenticate RSs that
	    wish to get an introspection response.</t>
	    <t>If providing an introspection endpoint: Process token
	    introspection requests.</t>
	    <t>Optionally: Handle token revocation.</t>
	    <t>Optionally: Provide discovery metadata. See <xref
	    target="RFC8414"/></t>
	    <t>Optionally: Handle refresh tokens.</t>
          </list><vspace blankLines="0"/>
	</t>
        <t hangText="Client">
	  <list style="symbols">
	    <t>Discover the AS in charge of the RS that is to be targeted with
	    a request.</t>
            <t>Submit the token request (see step (A) of
	    <xref target="fig:protocolFlow"/>).
	      <list style="symbols">
		<t>Authenticate to the AS.</t>
		<t>Optionally (if not pre-configured): Specify which RS, which
		resource(s), and which action(s) the request(s) will
		target.</t>
		<t>If raw public keys (rpk) or certificates are used, make sure
		the AS has the right rpk or certificate for this client.</t>
	      </list>
	    </t>
	    <t>Process the access token and Access Information (see step (B)
	    of <xref target="fig:protocolFlow"/>).
	       <list style="symbols">
		<t>Check that the Access Information provides the necessary
		security parameters (e.g., PoP key, information on
		communication security protocols supported by the RS).</t>
		<t>Safely store the proof-of-possession key.</t>
		<t>If provided by the AS: Safely store the refresh token.</t>
	      </list>
	    </t>
	    <t>Send the token and request to the RS (see step (C) of
	    <xref target="fig:protocolFlow"/>).
	      <list style="symbols">
		<t>Authenticate towards the RS (this could coincide with the
		proof of possession process).</t>
		<t>Transmit the token as specified by the AS (default is to the
		authz-info endpoint, alternative options are specified by
		profiles).</t>
		<t>Perform the proof-of-possession procedure as specified by
		the profile in use (this may already have been taken care
		of through the authentication procedure).</t>
	      </list>
	    </t>
	    <t>Process the RS response (see step (F) of
	    <xref target="fig:protocolFlow"/>) of the RS.</t>
          </list><vspace blankLines="0"/>
	</t>
	<t hangText="Resource Server">
	  <list style="symbols">
	    <t>Expose a way to submit access tokens. By default this is
	    the authz-info endpoint.</t>
            <t>Process an access token.
	      <list style="symbols">
		<t>Verify the token is from a recognized AS.</t>
		<t>Check the token's integrity.</t>
		<t>Verify that the token applies to this RS.</t>
		<t>Check that the token has not expired (if the token provides
		expiration information).</t>
		<t>Store the token so that it can be retrieved in the context
		of a matching request.</t>
	      </list>
	      Note: The order proposed here is not normative, any process
	      that arrives at an equivalent result can be used.  A noteworthy
	      consideration is whether one can use cheap operations early on to
	      quickly discard non-applicable or invalid tokens, before
	      performing expensive cryptographic operations (e.g. doing an
	      expiration check before verifying a signature).
	      <vspace blankLines="0"/>
	    </t>
	    <t>Process a request.
	     <list style="symbols">
	        <t>Set up communication security with the client.</t>
		<t>Authenticate the client.</t>
		<t>Match the client against existing tokens.</t>
		<t>Check that tokens belonging to the client actually
		authorize the requested action.</t>
		<t>Optionally: Check that the matching tokens are still valid,
		using introspection (if this is possible.)</t>
	      </list>
	    </t>
	    <t>Send a response following the agreed upon communication
	    security mechanism(s).</t>
	    <t>Safely store credentials such as raw public keys for
	    authentication or proof-of-possession keys linked to access
	    tokens.</t>
          </list>
	</t>
      </list></t>
    </section>

<!-- ***************************************************** -->
<section anchor="app:profileRequirements" title="Requirements on Profiles">
  <t>This section lists the requirements on profiles of this framework,
  for the convenience of profile designers.

  <list style="symbols">
    <t>Optionally define new methods for the client to discover the
    necessary permissions and AS for accessing a resource, different from
    the one proposed in <xref target="asDiscovery"/>. <xref target="specs"/>
    </t>

    <t>Optionally specify new grant types.
    <xref target="authorizationGrants"/></t>

    <t>Optionally define the use of client certificates as client credential
    type. <xref target="clientCredentials"/></t>
    
    <t>Specify the communication protocol the client and RS the must use
    (e.g., CoAP). <xref target="oauthProfile"/> and <xref
    target="paramProfile"/></t>

    <t>Specify the security protocol the client and RS must use to protect
    their communication (e.g., OSCORE or DTLS).  This must provide
    encryption, integrity and replay protection. <xref
    target="paramProfile"/></t>

    <t>Specify how the client and the RS mutually authenticate. <xref
    target="specs"/></t>

    <t>Specify the proof-of-possession protocol(s) and how to select one,
    if several are available.  Also specify which key types
    (e.g., symmetric/asymmetric) are supported by a specific proof-of-possession
    protocol. <xref target="paramTokenType"/></t>

    <t>Specify a unique ace_profile identifier. <xref
    target="paramProfile"/></t>

    <t>If introspection is supported: Specify the communication and security
    protocol for introspection. <xref target="introspectionEndpoint"/></t>

    <t>Specify the communication and security protocol for interactions between
    client and AS. This must provide encryption, integrity protection,
    replay protection and a binding between requests and responses. <xref
    target="oauthProfile"/> and <xref target="tokenEndpoint"/></t>

    <t>Specify how/if the authz-info endpoint is protected, including
    how error responses are protected. <xref
    target="tokenAuthInfoEndpoint"/></t>

    <t>Optionally define other methods of token transport than the authz-info
    endpoint. <xref target="tokenAuthInfoEndpoint"/></t>

  </list>

  </t>


</section>

<section anchor="app:registration"
	 title="Assumptions on AS Knowledge about C and RS">

 <t>This section lists the assumptions on what an AS should know about a
 client and an RS in order to be able to respond to requests to the token
 and introspection endpoints.  How this information is established is out of
 scope for this document.

  <list style="symbols">
    <t>The identifier of the client or RS.</t>
    <t>The profiles that the client or RS supports.</t>
    <t>The scopes that the RS supports.</t>
    <t>The audiences that the RS identifies with.</t>
    <t>The key types (e.g., pre-shared symmetric key, raw public key,
    key length, other key parameters) that the client or RS supports.</t>
    <t>The types of access tokens the RS supports (e.g., CWT).</t>
    <t>If the RS supports CWTs, the COSE parameters for the crypto wrapper
    (e.g., algorithm, key-wrap algorithm, key-length) that the RS supports.</t>
    <t>The expiration time for access tokens issued to this RS
    (unless the RS accepts a default time chosen by the AS).</t>
    <t>The symmetric key shared between client and AS (if any).</t>
    <t>The symmetric key shared between RS and AS (if any).</t>
    <t>The raw public key of the client or RS (if any).</t>
    <t>Whether the RS has synchronized time (and thus is able to use the 'exp'
    claim) or not.</t>
  </list>
 </t>
</section>

<section anchor="app:diffOAuth" title="Differences to OAuth 2.0">
  <t>This document adapts OAuth 2.0 to be suitable for constrained environments.  
  This sections lists the main differences from the normative requirements of
  OAuth 2.0.

      <list style="symbols">
	<t>Use of TLS -- OAuth 2.0 requires the use of TLS both to protect the
	communication between AS and client when requesting an access token;
	between client and RS when accessing a resource and between AS and RS if
	introspection is used.  This framework requires similar security
	properties, but does not require that they be realized with TLS.  
	See <xref target="oauthProfile"/>.</t>

	<t>Cardinality of "grant_type" parameter -- In client-to-AS requests 
	using OAuth 2.0, the "grant_type" parameter is required (per 
	<xref target="RFC6749"/>).  In this framework, this parameter is
	optional.  See <xref target="tokenRequest"/>.</t>

	<t>Encoding of "scope" parameter -- In client-to-AS requests using OAuth
	2.0, the "scope" parameter is string encoded (per 
	<xref target="RFC6749"/>).  In this framework, this parameter may also be
	encoded as a byte string.  See <xref target="tokenRequest"/>.</t>

	<t>Cardinality of "token_type" parameter -- in AS-to-client responses
	using OAuth 2.0, the token_type parameter is required (per 
	<xref target="RFC6749"/>).  In this framework, this parameter is
	optional.  See <xref target="tokenResponse"/>.</t>
	
	<t>Access token retention -- in OAuth 2.0, the access token may be sent with
	every request to the RS. The exact use of access tokens depends on the semantics 
	of the application and the session management concept it uses. In this framework, 
	the RS must be able to store these tokens for later use.  See
        <xref target="tokenAuthInfoEndpoint"/>.</t> 
      </list>
   </t>
</section>

<!-- ***************************************************** -->
      <section anchor="app:options" title="Deployment Examples">
        <t>There is a large variety of IoT deployments, as is indicated in
        <xref target="constraints"/>, and this section highlights a few common
        variants.  This section is not normative but illustrates how the
        framework can be applied.
        </t>

        <t>For each of the deployment variants, there are a number of possible
        security setups between clients, resource servers and authorization
        servers.  The main focus in the following subsections is on how
        authorization of a client request for a resource hosted by an RS is
        performed.  This requires the security of the requests and
        responses between the clients and the RS to be considered.
        </t>

        <t>Note: CBOR diagnostic notation is used for examples of requests
          and responses.</t>

<!-- ************************** -->


 <!-- ************************** -->
<section anchor="localTokenValidation" title="Local Token Validation">
  <t>In this scenario, the case where the resource server is offline is considered,
i.e., it is not connected to the AS at the time of the access request.
This access procedure involves steps A, B, C, and F of <xref target="fig:protocolFlow"/>.
  </t>

  <t>Since the resource server must be able to verify the access token locally,
  self-contained access tokens must be used.</t>

    <t>This example shows the interactions between a client, the
    authorization server and a temperature sensor acting as a resource server.  Message
    exchanges A and B are shown in <xref target="fig:RSOffline"/>.</t>

    <t><list style="hanging">
      <t>A: The client first generates a public-private key pair used for
      communication security with the RS.</t>

      <t>The client sends a CoAP POST request to the token endpoint at the AS.  The security
        of this request can be transport or application layer. It is up the
        communication security profile to define. In the example it is
	assumed that both client and AS have performed mutual authentication
	e.g. via DTLS.  The request contains the public key of the client and
	the Audience parameter set to "tempSensorInLivingRoom", a value that
	the temperature sensor identifies itself with.  The AS evaluates the
	request and authorizes the client to access the resource.</t>

	<t>B: The AS responds with a 2.05 Content response containing the
	Access Information, including the access token.
      The PoP access token contains the public key of the client, and the
      Access Information  contains the public key of the RS.  For communication
      security this example uses DTLS RawPublicKey between the client and the
      RS. The issued token will have a short validity time, i.e., "exp" close
      to "iat", in order to mitigate attacks using stolen client credentials.
      The token includes the claim such as "scope" with the authorized access
      that an owner of the temperature device can enjoy.  In this example, the
      "scope" claim, issued by the AS, informs the RS that the owner of the
      token, that can prove the possession of a key is authorized to make a GET
      request against the /temperature resource and a POST request on the
      /firmware resource.  Note that the syntax and semantics of the scope claim
      are application specific.</t>

      <t>Note: In this example it is assumed that the client knows what resource it
      wants to access, and is therefore able to request specific
      audience and scope claims for the access token.</t>
    </list></t>

    <t><figure align="center" anchor="fig:RSOffline"
               title="Token Request and Response Using Client Credentials.">
        <artwork align="left"><![CDATA[
         Authorization
  Client    Server
    |         |
    |<=======>| DTLS Connection Establishment
    |         |   and mutual authentication
    |         |
A:  +-------->| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"token"
    |         | Content-Format: application/ace+cbor
    |         | Payload: <Request-Payload>
    |         |
B:  |<--------+ Header: 2.05 Content
    |  2.05   | Content-Format: application/ace+cbor
    |         | Payload: <Response-Payload>
    |         |
        ]]></artwork>
    </figure></t>

    <t>The information contained in the Request-Payload and the
    Response-Payload is shown in <xref target="fig:RSOfflineReq"/>
    Note that the parameter "rs_cnf" from
    <xref target="I-D.ietf-ace-oauth-params"/> is used to inform
    the client about the resource server's public key.

     <figure align="center" anchor="fig:RSOfflineReq"
             title="Request and Response Payload Details.">
      <artwork align="left"><![CDATA[
Request-Payload :
{
  "audience" : "tempSensorInLivingRoom",
  "client_id" : "myclient",
  "req_cnf" : {
    "COSE_Key" : {
      "kid" : b64'1Bg8vub9tLe1gHMzV76e8',
      "kty" : "EC",
      "crv" : "P-256",
      "x" : b64'f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU',
      "y" : b64'x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0'
    }
  }
}

Response-Payload :
{
  "access_token" : b64'0INDoQEKoQVNKkXfb7xaWqMTf6 ...',
  "rs_cnf" : {
    "COSE_Key" : {
      "kid" : b64'c29tZSBwdWJsaWMga2V5IGlk',
      "kty" : "EC",
      "crv" : "P-256",
      "x"   : b64'MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4',
      "y"   : b64'4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM'
    }
  }
}
        ]]></artwork>
    </figure></t>

    <t>The content of the access token is shown
    in <xref target="fig:BothcborMappingValueAsymmetricCWT"/>.</t>

    <t><figure align="center"
               anchor="fig:BothcborMappingValueAsymmetricCWT"
               title="Access Token including Public Key of the client.">
        <artwork align="left"><![CDATA[
{
  "aud" : "tempSensorInLivingRoom",
  "iat" : "1563451500",
  "exp" : "1563453000",
  "scope" :  "temperature_g firmware_p",
  "cnf" : {
    "COSE_Key" : {
      "kid" : b64'1Bg8vub9tLe1gHMzV76e8',
      "kty" : "EC",
      "crv" : "P-256",
      "x" : b64'f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU',
      "y" : b64'x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0'
    }
  }
}
        ]]></artwork>
    </figure></t>

    <t>Messages C and F are shown in
    <xref target="fig:RSOfflinePostAccessTokenAsymmetric"/> -
    <xref target="fig:RSOfflineDTLSRequestAndResponse"/>.

    <list style="hanging">
      <t>C: The client then sends the PoP access token to the authz-info endpoint at
      the RS.  This is a plain CoAP POST request, i.e., no transport or application-layer security is used between client and RS since the token is integrity protected
      between the AS and RS.  The RS verifies that the PoP access token was created by a
      known and trusted AS, that it applies to this RS, and that it is valid.  The RS caches
      the security context together with authorization information about this client
      contained in the PoP access token.</t>

    <t><figure align="center" anchor="fig:RSOfflinePostAccessTokenAsymmetric"
               title="Access Token provisioning to RS">
      <artwork align="left"><![CDATA[
           Resource
 Client     Server
    |         |
C:  +-------->| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"authz-info"
    |         | Payload: 0INDoQEKoQVN ...
    |         |
    |<--------+ Header: 2.04 Changed
    |  2.04   |
    |         |
]]></artwork>
    </figure></t>

      <t>The client and the RS runs the DTLS handshake using the raw
      public keys established in step B and C.</t>

      <t>The client sends a CoAP GET request to /temperature on RS over
      DTLS.  The RS verifies that the request is authorized, based on
      previously established security context.</t>

      <t>F: The RS responds over the same DTLS channel with a CoAP 2.05 Content response, containing a resource representation as payload.</t>
    </list></t>

    <t><figure align="center" anchor="fig:RSOfflineDTLSRequestAndResponse"
               title="Resource Request and Response protected by DTLS.">
      <artwork align="left"><![CDATA[
           Resource
 Client     Server
    |         |
    |<=======>| DTLS Connection Establishment
    |         |   using Raw Public Keys
    |         |
    +-------->| Header: GET (Code=0.01)
    | GET     | Uri-Path: "temperature"
    |         |
    |         |
    |         |
F:  |<--------+ Header: 2.05 Content
    | 2.05    | Payload: <sensor value>
    |         |
      ]]></artwork>
    </figure></t>
</section>


 <!-- ************************** -->

<section anchor="introspectionAidedTokenValidation" title="Introspection Aided Token Validation">

  <t>In this deployment scenario it is assumed that a client is not able to
  access the AS at the time of the access request, whereas the RS is assumed
  to be connected to the back-end infrastructure. Thus the RS can make use of
  token introspection.  This access procedure involves steps A-F of
  <xref target="fig:protocolFlow"/>, but assumes steps A and B have been
  carried out during a phase when the client had connectivity to AS.
  </t>

  <t>Since the client is assumed to be offline, at least for a certain period of
  time, a pre-provisioned access token has to be long-lived.  Since the client
  is constrained, the token will not be self contained (i.e. not a CWT) but
  instead just a reference.  The resource server uses its connectivity to
  learn about the claims associated to the access token by using introspection,
  which is shown in the example below.</t>

    <t>In the example interactions between an offline client
    (key fob), an RS (online lock), and an AS is shown.  It is
    assumed that there is a provisioning step where the client has access to the
    AS.  This corresponds to message exchanges A and B which are shown in
    <xref target="fig:cOffline"/>.
    </t>
    <t>Authorization consent from the resource owner can be pre-configured,
    but it can also be provided via an interactive flow with the resource
    owner.  An example of this for the key fob case could be that the
    resource owner has a connected car, he buys a generic key that he
    wants to use with the car.  To authorize the key fob he connects it
    to his computer that then provides the UI for the device.  After
    that OAuth 2.0 implicit flow can used to authorize the key for
    his car at the car manufacturers AS.</t>

    <t>Note: In this example the client does not know the exact door it
    will be used to access since the token request is not send at the
    time of access. So the scope and audience parameters are set quite
    wide to start with, while tailored values narrowing down the claims to
    the specific RS being accessed can be provided to that RS during
    an introspection step.</t>

    <t>
      <list style="hanging">
        <t>A: The client sends a CoAP POST request to the token endpoint at
	AS.  The request contains the Audience parameter set to  "PACS1337"
	(PACS, Physical Access System), a value the that identifies the
	physical access control system to which the individual doors are
	connected.  The AS generates an access token as	an opaque string, which
	it can match to the specific client and the targeted audience. It
	furthermore generates a symmetric proof-of-possession key. The
	communication security and authentication between client and AS
	is assumed to have been	provided at transport layer (e.g. via DTLS)
	using a pre-shared security context (psk, rpk or certificate).</t>

        <t>B: The AS responds with a CoAP 2.05 Content response, containing as
	payload the Access Information, including the access token and the
	symmetric proof-of-possession key.  Communication security between C
        and RS will be DTLS and PreSharedKey.  The PoP key is used as the
        PreSharedKey.
        </t>
      </list>
    </t>
	    
    <t>Note: In this example we are using a symmetric key for a multi-RS
    audience, which is not recommended normally (see <xref target="audience"/>).
    However in this case the risk is deemed to be acceptable, since
    all the doors are part of the same physical access control system,
    and therefore the risk of a malicious RS impersonating the client towards
    another RS is low.</t>
    
    <t><figure align="center" anchor="fig:cOffline"
               title="Token Request and Response using Client Credentials.">
      <artwork align="left"><![CDATA[

         Authorization
 Client     Server
    |         |
    |<=======>| DTLS Connection Establishment
    |         |   and mutual authentication
    |         |
A:  +-------->| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"token"
    |         | Content-Format: application/ace+cbor
    |         | Payload: <Request-Payload>
    |         |
B:  |<--------+ Header: 2.05 Content
    |         | Content-Format: application/ace+cbor
    |  2.05   | Payload: <Response-Payload>
    |         |
    ]]></artwork>
    </figure></t>

    <t>The information contained in the Request-Payload and the
    Response-Payload is shown in <xref target="fig:cOfflineReq"/>.

     <figure align="center" anchor="fig:cOfflineReq"
             title="Request and Response Payload for C offline">
      <artwork align="left"><![CDATA[
Request-Payload:
{
  "client_id" : "keyfob",
  "audience" : "PACS1337"
}

Response-Payload:
{
  "access_token" : b64'VGVzdCB0b2tlbg==',
  "cnf" : {
    "COSE_Key" : {
      "kid" : b64'c29tZSBwdWJsaWMga2V5IGlk',
      "kty" : "oct",
      "alg" : "HS256",
      "k": b64'ZoRSOrFzN_FzUA5XKMYoVHyzff5oRJxl-IXRtztJ6uE'
    }
  }
}
      ]]></artwork>
    </figure></t>

    <t>The access token in this case is just an opaque byte string referencing
   the authorization information at the AS.</t>

    <t><list style="hanging">
        <t>C: Next, the client POSTs the access token to the authz-info
        endpoint in the RS.  This is a plain CoAP request, i.e., no
        DTLS between client and RS.  Since the token is an opaque string,
        the RS cannot verify it on its own, and thus defers to respond the
        client with a status code until after step E.</t>

        <t>D: The RS sends the token to the introspection
        endpoint on the AS using a CoAP POST request.  In this example RS and
	AS are assumed to have performed mutual authentication using a pre
	shared security context (psk, rpk or certificate) with the RS acting as
	DTLS client.
        </t>

        <t>E: The AS provides the introspection response (2.05 Content)
	containing parameters about the token.  This includes the confirmation
	key (cnf) parameter that allows the RS to verify the client's proof of
	possession in step F. Note that our example in <xref
	target="fig:cOfflineIntroReq"/>	assumes a pre-established key (e.g. one
	used by the client and the RS for a previous token) that is now only
	referenced by its key-identifier 'kid'.
	</t>

        <t>After receiving message E, the RS responds to the client's POST in
        step C with the CoAP response code 2.01 (Created).</t>

        <t><figure align="center" anchor="fig:cOfflineIntrospection"
            title="Token Introspection for C offline">
            <artwork align="left"><![CDATA[
           Resource
  Client    Server
    |         |
C:  +-------->| Header: POST (T=CON, Code=0.02)
    |  POST   | Uri-Path:"authz-info"
    |         | Payload: b64'VGVzdCB0b2tlbg=='
    |         |
    |         |     Authorization
    |         |       Server
    |         |          |
    |      D: +--------->| Header: POST (Code=0.02)
    |         |  POST    | Uri-Path: "introspect"
    |         |          | Content-Format: "application/ace+cbor"
    |         |          | Payload: <Request-Payload>
    |         |          |
    |      E: |<---------+ Header: 2.05 Content
    |         |  2.05    | Content-Format: "application/ace+cbor"
    |         |          | Payload: <Response-Payload>
    |         |          |
    |         |
    |<--------+ Header: 2.01 Created
    |  2.01   |
    |         |
]]></artwork>
        </figure></t>

        <t>The information contained in the Request-Payload and the
        Response-Payload is shown in <xref target="fig:cOfflineIntroReq"/>.

        <figure align="center" anchor="fig:cOfflineIntroReq"
                title="Request and Response Payload for Introspection">
          <artwork align="left"><![CDATA[
Request-Payload:
{
  "token" : b64'VGVzdCB0b2tlbg==',
  "client_id" : "FrontDoor",
}

Response-Payload:
{
  "active" : true,
  "aud" : "lockOfDoor4711",
  "scope" : "open, close",
  "iat" : 1563454000,
  "cnf" : {
    "kid" : b64'c29tZSBwdWJsaWMga2V5IGlk'
  }
}
          ]]></artwork>
        </figure></t>
      </list>
  </t>

<t>
    <list style="hanging">
        <t>
            The client uses the symmetric PoP key to establish a DTLS
            PreSharedKey secure connection to the RS. The CoAP request PUT is
            sent to the uri-path /state on the RS, changing the state of the door to locked.
        </t>
        <t>
            F: The RS responds with a appropriate over the secure DTLS channel.
        </t>
    </list>
</t>
        <t><figure align="center" anchor="fig:cOfflineDTLSRequestAndResponse"
            title="Resource request and response protected by OSCORE">
            <artwork align="left"><![CDATA[
           Resource
  Client    Server
    |         |
    |<=======>| DTLS Connection Establishment
    |         |   using Pre Shared Key
    |         |
    +-------->| Header: PUT (Code=0.03)
    | PUT     | Uri-Path: "state"
    |         | Payload: <new state for the lock>
    |         |
F:  |<--------+ Header: 2.04 Changed
    | 2.04    | Payload: <new state for the lock>
    |         |
            ]]></artwork>
        </figure></t>
    </section>

</section>
  </back>
</rfc>
