<?xml version="1.0" encoding="utf-8"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->

<!ENTITY RFC2119 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC4949 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949.xml">
<!ENTITY RFC5246 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml">
<!ENTITY RFC6347 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6347.xml">
<!ENTITY RFC6690 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6690.xml">
<!ENTITY RFC6749 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6749.xml">
<!ENTITY RFC6819 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6819.xml">
<!ENTITY RFC7049 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7049.xml">
<!ENTITY RFC7159 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7159.xml">
<!ENTITY RFC7228 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7228.xml">
<!ENTITY RFC7231 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7231.xml">
<!ENTITY RFC7252 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7252.xml">
<!ENTITY RFC7521 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7521.xml">
<!ENTITY I-D.ietf-oauth-device-flow SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-device-flow.xml">
<!ENTITY I-D.ietf-oauth-native-apps SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-native-apps.xml">
<!ENTITY RFC7519 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.7519.xml">
<!ENTITY RFC7591 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.7591.xml">
<!ENTITY RFC7641 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.7641.xml">
<!ENTITY RFC7662 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7662.xml">
<!ENTITY RFC7744 SYSTEM
"http://xml.resource.org/public/rfc/bibxml/reference.RFC.7744.xml">
<!ENTITY I-D.ietf-ace-actors SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ace-actors.xml">
<!ENTITY I-D.ietf-core-object-security SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-core-object-security.xml">
<!ENTITY I-D.ietf-ace-cbor-web-token SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ace-cbor-web-token.xml">
 <!ENTITY I-D.jones-ace-cwt-proof-of-possession SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.jones-ace-cwt-proof-of-possession.xml">
 <!ENTITY I-D.erdtman-ace-rpcc SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.erdtman-ace-rpcc.xml">
<!ENTITY RFC7959 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7959.xml">
<!ENTITY RFC8152 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.8152.xml">
<!ENTITY I-D.ietf-core-resource-directory SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-core-resource-directory.xml">
<!ENTITY RFC3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY I-D.ietf-oauth-discovery SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-discovery.xml">

]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-ace-oauth-authz-07" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
        full title is longer than 39 characters -->

<title abbrev="ACE">Authentication and Authorization for Constrained Environments (ACE)</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Ludwig Seitz" initials="L." surname="Seitz">
      <organization>RISE SICS</organization>

      <address>
        <postal>
          <street>Scheelevaegen 17</street>
          <code>223 70</code> <city>Lund</city>
          <country>Sweden</country>
        </postal>
        <email>ludwig.seitz@ri.se</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Goeran Selander" initials="G." surname="Selander">
      <organization>Ericsson</organization>

      <address>
        <postal>
          <street>Faroegatan 6</street>
          <code>164 80</code> <city>Kista</city>
          <country>Sweden</country>
        </postal>
        <email>goran.selander@ericsson.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Erik Wahlstroem" initials="E." surname="Wahlstroem">
      <organization>(no affiliation)</organization>

      <address>
        <postal>
          <street></street>
          <code></code> <city></city>
          <country>Sweden</country>
        </postal>
        <email>erik@wahlstromtekniska.se</email>
      </address>
    </author>

    <author fullname="Samuel Erdtman" initials="S." surname="Erdtman">
      <organization>Spotify AB</organization>

      <address>
        <postal>
          <street>Birger Jarlsgatan 61, 4tr</street>
          <code>113 56</code> <city>Stockholm</city>
          <country>Sweden</country>
        </postal>
        <email>erdtman@spotify.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig">
      <organization>ARM Ltd.</organization>

      <address>
        <postal>
          <street></street>
          <code>6060</code> <city>Hall in Tirol</city>
          <country>Austria</country>
        </postal>
        <email>Hannes.Tschofenig@arm.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>
    <date year="2017" />



    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill
         in the current day for you. If only the current year is specified, xml2rfc will fill
	 in the current day and month for you. If the year is not the current one, it is necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the purpose of calculating the expiry date).  With drafts it is normally sufficient to specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>Security</area>

    <workgroup>ACE Working Group</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>CoAP, OAuth 2.0, Access Control, Authorization, Internet of Things</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>This specification defines a framework for authentication and authorization
        in Internet of Things (IoT) environments. The framework is based on
        a set of building blocks including OAuth 2.0 and CoAP, thus making a well-known and
      widely used authorization solution suitable for IoT devices.  Existing specifications
      are used where possible, but where the constraints of IoT devices require it,
      extensions are added and profiles are defined.
      </t>
    </abstract>
  </front>

<middle>

<!-- ***************************************************** -->

<section anchor="intro" title="Introduction">

   <t>Authorization is the process for granting approval to an entity to
   access a resource <xref target="RFC4949"/>. The authorization task itself can
   best be described as granting access to a
   requesting client, for a resource hosted on a device, the resource
   server (RS).  This exchange is mediated by one or multiple
   authorization servers (AS). Managing authorization for
   a large number of devices and users can be a complex task. </t>

   <t>While prior work on authorization solutions for the Web and for the mobile
   environment also applies to the Internet of Things (IoT) environment, many
   IoT devices are constrained, for example, in terms of processing
   capabilities, available memory, etc. For web applications on constrained
   nodes, this specification RECOMMENDS the use of CoAP
   <xref target="RFC7252"/> as replacement for HTTP.</t>

   <t>A detailed treatment of constraints can be found in <xref target="RFC7228"/>, and the
   different IoT deployments present a
   continuous range of device and network capabilities.  Taking energy
   consumption as an example: At one end there are energy-harvesting or
   battery powered devices which have a tight power budget, on the other
   end there are mains-powered devices, and all levels in between.</t>

   <t>Hence, IoT devices may be very different in terms of available processing
   and message exchange capabilities and there is a need to support many
     different authorization use cases <xref target="RFC7744"/>.</t>

   <t>This specification describes a framework for authentication and authorization
   in constrained environments (ACE) built on re-use of OAuth 2.0
   <xref target="RFC6749"/>, thereby extending authorization to Internet of Things
   devices.  This specification contains the necessary building blocks
   for adjusting OAuth 2.0 to IoT environments.</t>

   <t>More detailed, interoperable specifications can be found in profiles.
   Implementations may claim conformance with a specific profile,
   whereby implementations utilizing the same profile interoperate while
   implementations of different profiles are not expected to be interoperable.
   Some devices, such as mobile phones and tablets, may implement multiple
   profiles and will therefore be able to interact with a wider range of low end devices.
   Requirements on profiles are described at contextually appropriate places
   throughout this specification, and also summarized in
   <xref target="app:profileRequirements"/>.
   </t>



</section>

<!-- ***************************************************** -->

<section anchor="terminology" title="Terminology">
  <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
"OPTIONAL" in this document are to be interpreted as described in <xref
target="RFC2119"/>.  </t>

  <t>Certain security-related terms such as "authentication",
"authorization", "confidentiality", "(data) integrity", "message
authentication code", and "verify" are taken from <xref
target="RFC4949"/>.
  </t>

  <t>Since exchanges in this specification are described as RESTful protocol
    interactions, HTTP <xref target="RFC7231"/> offers useful terminology.
  </t>

  <t>Terminology for entities in the architecture is defined in OAuth
2.0 <xref target="RFC6749"/> and <xref target="I-D.ietf-ace-actors"/>,
such as client (C), resource server (RS), and authorization server
(AS).</t>

<t>Note that the term "endpoint" is used here following its OAuth
definition, which is to denote resources such as token and
introspection at the AS and authz-info at the RS (see <xref target="tokenAuthInfoEndpoint"/> for a definition of the authz-info endpoint).
The CoAP <xref target="RFC7252"/> definition, which is "An entity
participating in the CoAP protocol" is not used in this specification.</t>

<t>
Since this specification focuses on the problem of access control to resources,
the actors has been simplified by assuming that the client authorization server (CAS)
functionality is not stand-alone but subsumed by either the authorization
server or the client (see section 2.2 in <xref target="I-D.ietf-ace-actors"/>).
</t>

<t>The specifications in this document is called the "framework" or "ACE framework".
When referring to "profiles of this framework" it refers to additional specifications that
define the use of this specification with concrete transport, and communication
security protocols (e.g., CoAP over DTLS).
</t>

<t>We use the term "RS Information" for parameters describing characteristics of the RS (e.g. public key) that the AS provides to the client.</t>

</section>

<!-- ***************************************************** -->

<section anchor="overview" title="Overview">

  <t>This specification defines the ACE framework for authorization in the Internet
      of Things environment. It consists of a set of building blocks.</t>

  <t>
  The basic block is the OAuth 2.0 <xref target="RFC6749"/>
  framework, which enjoys widespread deployment.  Many IoT devices can support
  OAuth 2.0 without any additional extensions, but for certain constrained
  settings additional profiling is needed.
  </t>

  <t>Another building block is the lightweight web transfer protocol CoAP
  <xref target="RFC7252"/>, for those communication environments where HTTP is
  not appropriate.  CoAP typically runs on top of UDP, which further reduces
  overhead and message exchanges. While this specification defines extensions
  for the use of OAuth over CoAP, other underlying protocols are not prohibited
  from beeing supported in the future, such as HTTP/2, MQTT, BLE and QUIC.</t>

  <t>A third building block is CBOR <xref target="RFC7049"/>, for encodings
  where JSON <xref target="RFC7159"/> is not sufficiently compact.  CBOR is a
  binary encoding designed for small code and message size, which may be used
  for encoding of self contained tokens, and also for encoding payload
  transferred in protocol messages.
  </t>

  <t>A fourth building block is the compact CBOR-based secure message format
  COSE <xref target="RFC8152"/>, which enables application layer
  security as an alternative or complement to transport layer security (DTLS
    <xref target="RFC6347"/> or TLS <xref target="RFC5246"/>). COSE is used to
    secure self-contained tokens such as proof-of-possession (PoP) tokens,
    which is an extension to the OAuth tokens, and "client tokens" which
    are defined in this framework (see <xref target="clientToken"/>). The
    default token format is defined in CBOR web token (CWT)
    <xref target="I-D.ietf-ace-cbor-web-token"/>.
    Application layer security for CoAP using COSE can be provided with OSCOAP
    <xref target="I-D.ietf-core-object-security"/>.</t>

  <t>With the building blocks listed above, solutions satisfying various
  IoT device and network constraints are possible.  A list of constraints is
  described in detail in RFC 7228 <xref target="RFC7228"/> and a description
  of how the building blocks mentioned above relate to the various constraints
  can be found in <xref target="constraints"/>.</t>

  <t>Luckily, not every IoT device suffers from all constraints.  The ACE
  framework nevertheless takes all these aspects into account and allows
  several different deployment variants to co-exist, rather than mandating a
  one-size-fits-all solution.  It is important to cover the wide
  range of possible interworking use cases and the different requirements from
  a security point of view.  Once IoT deployments mature, popular deployment
  variants will be documented in the form of ACE profiles.</t>

  <section anchor="oauth2Overview" title="OAuth 2.0">
    <t>The OAuth 2.0 authorization framework enables a client to obtain
    scoped access to a resource with the permission of a resource
    owner.  Authorization information, or references to it, is passed between the nodes
    using access tokens.  These access tokens are issued to clients by an
    authorization server with the approval of the resource owner.  The client
    uses the access token to access the protected resources hosted by the
    resource server.</t>

    <t>A number of OAuth 2.0 terms are used within this specification:

      <list style="hanging">
        <t hangText="The token and introspection Endpoints:"><vspace blankLines="1"/>
          The AS hosts the token endpoint that allows a client to request access tokens. The client makes a POST request to the token endpoint on the AS and
          receives the access token in the response (if the request was successful).
          <vspace blankLines="1"/>
          In some deployments, a token introspection endpoint is provied by
	  the AS, which can be used by the RS if it needs to request additional
	  information regarding a received access token.  The RS makes a POST
	  request to the introspecton endpoint on the AS and receives
	  information about the access token in the response. (See
	  "Introspection" below.)
          <vspace blankLines="1"/>
        </t>

        <t hangText="Access Tokens:"><vspace blankLines="1"/>
        Access tokens are credentials needed to access protected resources.  An
        access token is a data structure representing authorization permissions
        issued by the AS to the client.  Access tokens are generated by the AS
        and consumed by the RS.  The access token content is opaque
        to the client.
        <vspace blankLines="1"/>
        Access tokens can have different formats, and various methods
        of utilization (e.g., cryptographic properties) based on the security
        requirements of the given deployment.
        <vspace blankLines="1"/>
      </t>


      <t hangText="Proof of Possession Tokens:"><vspace blankLines="1"/>
        An access token may be bound to a
        cryptographic key, which is then used by an RS to authenticate requests
        from a client.  Such tokens are called proof-of-possession access
	tokens (or PoP access tokens).
        <vspace blankLines="1"/>
        The proof-of-possession (PoP) security concept assumes that the AS acts
        as a trusted third party that binds keys to access tokens.  These so
        called PoP keys are then used by the client to demonstrate the
        possession of the secret to the RS when accessing the resource.  The
        RS, when receiving an access token, needs to verify that the key used
        by the client matches the one bound to the access token.  When this
        specification uses the term "access token" it is assumed to be a PoP
	access token token unless specifically stated otherwise.

        <vspace blankLines="1"/>
        The key bound to the access token (the PoP key) may use either
        symmetric or asymmetric cryptography.  The appropriate
        choice of the kind of cryptography depends on the constraints of the IoT devices as
        well as on the security requirements of the use case.

        <list style="hanging">

          <t hangText="Symmetric PoP key:">
              The AS generates a random symmetric PoP key.  The key is either
              stored to be returned on introspection calls or encrypted and
              included in the access token.  The PoP key is also
              encrypted for the client and sent together with the access token
              to the client.<vspace blankLines="0"/>

          </t>
          <t hangText="Asymmetric PoP key:">
              An asymmetric key pair is generated on the client and the public
              key is sent to the AS (if it does not already have knowledge of
              the client's public key).  Information about the public key,
              which is the PoP key in this case, is either
              stored to be returned on introspection calls or included inside the
              access token and sent back to the requesting client.  The RS
              can identify the client's public key from the information in the
	      token, which allows the client to use the corresponding private
	      key for the proof of possession.
          </t>
        </list>

        <vspace blankLines="1"/> The access token is either a simple reference,
	or a structured information object (e.g., CWT <xref
        target="I-D.ietf-ace-cbor-web-token"/>), protected by a cryptographic
	wrapper (e.g., COSE <xref target="RFC8152"/>).  The choice of
	PoP key does not necessarily imply a specific credential type for the
	integrity protection of the token.<vspace blankLines="0"/>
      </t>

      <t hangText="Scopes and Permissions:"><vspace blankLines="1"/>
         In OAuth 2.0, the client specifies the type of permissions it is
         seeking to obtain (via the scope parameter) in the access token
	 request.  In turn, the AS may use the scope response parameter to
	 inform the client of the scope of the access token issued.  As the
	 client could be a constrained device as well, this specification uses
	 CBOR encoding as data formt, defined in <xref target="oauthProfile"/>, to
         request scopes and to be informed what scopes the access token
         actually authorizes.
         <vspace blankLines="1"/>
         The values of the scope parameter are expressed as a list of space-delimited,
	 case-sensitive strings, with a semantic that is well-known
	 to the AS and the RS.
         <!-- <vspace blankLines="1"/>
         A common misconception is that the requested scopes must
         also be included in the returned access token, but the requested scopes
         are only metadata about the token.  They could also be packaged in the
         token as a separate attribute, but it's more common to assert the
         requested and authorized access using claims within the access token.
         <vspace blankLines="1"/>-->
         More details about the concept of scopes is found under Section 3.3 in
         <xref target="RFC6749" />.<vspace blankLines="0"/>
      </t>


      <t hangText="Claims:"><vspace blankLines="1"/>

      Information carried in the access token or returned from introspection, called claims, is in the form of
      name-value pairs.  An access token may, for example, include a claim
      identifying the AS that issued the token (via the "iss" claim) and
      what audience the access token is intended for (via the "aud" claim).
	The audience of an access token can be a specific resource or one or
	many resource servers.  The resource owner policies influence what
	claims are put into the access token by the authorization server.
        <vspace blankLines="1"/>
        While the structure and encoding of the access token varies throughout
        deployments, a standardized format has been defined with the JSON Web
        Token (JWT) <xref target="RFC7519"/> where claims are encoded as a
	JSON object.  In <xref target="I-D.ietf-ace-cbor-web-token"/>, an
	equivalent format using CBOR encoding (CWT) has been defined.
	<vspace blankLines="0"/>
      </t>

      <t hangText="Introspection:"><vspace blankLines="1"/>
        Introspection is a method for a resource server to query the
        authorization server for the active state and content of a received
        access token.  This is particularly useful in those cases where the
        authorization decisions are very dynamic and/or where the received
        access token itself is an opaque reference rather than a self-contained
        token.   More information about introspection in OAuth 2.0 can be
        found in <xref target="RFC7662"/>.
      </t>
    </list>
  </t>
</section>

<section anchor="coap" title="CoAP">

    <t>
    CoAP is an application layer protocol similar to HTTP, but specifically
    designed for constrained environments.  CoAP typically uses
    datagram-oriented transport, such as UDP, where reordering and loss
    of packets can occur.  A security solution needs to take the latter aspects
    into account.</t>

    <t>While HTTP uses headers and query strings to convey additional
    information about a request, CoAP encodes such information into header
    parameters called 'options'.</t>

    <t>CoAP supports application-layer fragmentation of the CoAP payloads
    through blockwise transfers <xref target="RFC7959"/>.  However,
    blockwise transfer does not increase the size limits of CoAP options,
    therefore data encoded in options has to be kept small.
 </t>

  <t>Transport layer security for CoAP can be provided by DTLS 1.2
    <xref target="RFC6347"/> or TLS 1.2 <xref target="RFC5246"/>.
    CoAP defines a number of proxy operations that require transport layer
    security to be terminated at the proxy. One approach for protecting CoAP communication
    end-to-end through proxies, and also to support security for CoAP over
    a different transport in a uniform way, is to provide security at the application
    layer using an object-based security mechanism such as COSE <xref target="RFC8152"/>.
  </t>

  <t>
    One application of COSE is OSCOAP
    <xref target="I-D.ietf-core-object-security"/>, which
    provides end-to-end confidentiality, integrity and replay protection, and a
    secure binding between CoAP request and response messages. In OSCOAP, the
    CoAP messages are wrapped in COSE objects and sent using CoAP.
  </t>

  <t>This framework RECOMMENDS the use of CoAP as replacement for HTTP.</t>

</section>
</section>


<!-- ***************************************************** -->
<section anchor="specs" title="Protocol Interactions">

<t>
    The ACE framework is based on the OAuth 2.0 protocol interactions using
    the token endpoint and optionally the introspection endpoint.
    A client obtains an access token from an AS using the token endpoint and
    subsequently presents the access token to a RS to gain access to a
    protected resource. In most deployments the RS can process the access token
    locally, however in some cases the RS may present it to the AS via the
    introspection endpoint to get fresh information.  These interactions are
    shown in <xref target="fig:protocolFlow"/>.  An overview of various OAuth
    concepts is provided in <xref target="oauth2Overview"/>.
</t>

<t>The OAuth 2.0 framework defines a number of "protocol flows" via grant types, which have been extended
further with extensions to OAuth 2.0 (such as RFC 7521 <xref target="RFC7521"/> and <xref target="I-D.ietf-oauth-device-flow"/>).
What grant types works best depends on the usage scenario and RFC 7744 <xref target="RFC7744"/> describes many different IoT use cases but there are two preferred grant types, namely the Authorization Code Grant (described in Section 4.1 of <xref target="RFC7521"/>) and the Client Credentials Grant (described in Section 4.4 of <xref target="RFC7521"/>). The Authorization Code Grant is a good fit for use with apps running on smart phones and tablets that request access to IoT devices, a common scenario in the smart home environment, where users need to go through an authentication and authorization phase (at least during the initial setup phase). The native apps guidelines described in <xref target="I-D.ietf-oauth-native-apps"/> are applicable to this use case. The Client Credential Grant is a good fit for use with IoT devices where the OAuth client itself is constrained. In such a case, the resource owner has pre-arranged access rights for the client with the authorization server, which is often accomplished using a commissioning tool.</t>

<t>
    The consent of the resource owner, for giving a client access to a protected
    resource, can be provided dynamically as in the traditional OAuth flows, or it
    could be pre-configured by the resource owner as authorization policies at
    the AS, which the AS evaluates when a token request arrives.  The resource
    owner and the requesting party (i.e., client owner) are not shown in <xref
    target="fig:protocolFlow"/>.
</t>

<t>
  This framework supports a wide variety of communication security mechanisms
  between the ACE entities, such as client,
  AS, and RS. It is assumed that the client has been
  registered (also called enrolled or onboarded) to an AS using a mechanism defined outside the scope of this document.
  In practice, various techniques for onboarding have been used, such as factory-based provisioning or the use of
  commissioning tools. Regardless of the onboarding technique, this provisioning procedure implies that the client and the AS exchange credentials and
  configuration parameters.  These credentials are used to mutually authenticate each other and to protect messages exchanged between the client and the AS.</t>

 <t>It is also assumed that the RS has been registered with the AS, potentially in a similar way as the client has been registered with the AS.
 Established keying material between the AS and the RS allows the AS to apply
 cryptographic protection to the access token to ensure that its content cannot
 be modified, and if needed, that the content is confidentiality protected.</t>

<t>The keying material necessary for establishing communication security
  between C and RS is dynamically established as part of the protocol described
  in this document.
</t>

<t>
    At the start of the protocol, there is an optional discovery step where the
    client discovers the resource server and the resources this server hosts.
    In this step, the client might also determine what permissions are needed to
    access the protected resource.  A generic procedure is described in <xref
    target="asDiscovery"/>, profiles MAY define other procedures for
    discovery.</t>

    <t>In Bluetooth Low Energy, for example, advertisements are broadcasted by
    a peripheral, including information about the primary services.  In CoAP,
    as a second example, a client can make a request to "/.well-known/core" to
    obtain information about available resources, which are returned in a
    standardized format as described in <xref target="RFC6690"/>.
</t>

<t><figure align="center" anchor="fig:protocolFlow"
           title="Basic Protocol Flow.">
  <artwork align="left"><![CDATA[
+--------+                               +---------------+
|        |---(A)-- Token Request ------->|               |
|        |                               | Authorization |
|        |<--(B)-- Access Token ---------|    Server     |
|        |       + RS Information        |               |
|        |                               +---------------+
|        |                                      ^ |
|        |            Introspection Request  (D)| |
| Client |                  (optional)          | |
|        |             Response + Client Token  | |(E)
|        |                  (optional)          | v
|        |                               +--------------+
|        |---(C)-- Token + Request ----->|              |
|        |                               |   Resource   |
|        |<--(F)-- Protected Resource ---|    Server    |
|        |                               |              |
+--------+                               +--------------+
  ]]></artwork>
</figure></t>

<t>
  <list style="hanging">
    <t hangText="Requesting an Access Token (A):"><vspace blankLines="1"/>
      The client makes an access token request to the token endpoint at the AS.
      This framework assumes the use of PoP access tokens (see <xref
      target="oauth2Overview"/> for a short description) wherein the AS binds a
      key to an access token.  The client may include permissions it seeks to
      obtain, and information about the credentials it wants to use (e.g.,
      symmetric/asymmetric cryptography or a reference to a specific credential).<vspace blankLines="0"/>
    </t>

    <t hangText="Access Token Response (B):"><vspace blankLines="1"/>
      If the AS successfully processes the request from the client, it returns
      an access token.  It can also return additional parameters, referred to
      as "RS Information".  In addition to the response parameters defined by
      OAuth 2.0 and the PoP access token extension, this framework defines
      parameters that can be used to inform the client about capabilities of
      the RS. More information about these parameters can be found in <xref target="tokenParams"/>.
      <vspace blankLines="0"/>
    </t>

    <t hangText="Resource Request (C):"><vspace blankLines="1"/>
      The client interacts with the RS to request access to the protected
      resource and provides the access token.  The protocol to use
      between the client and the RS is not restricted to CoAP. HTTP, HTTP/2,
      QUIC, MQTT, Bluetooth Low Energy, etc., are also viable candidates.
      <vspace blankLines="1"/>
      Depending on the device limitations and the selected protocol, this
      exchange may be split up into two parts:

<list style="empty">
<t>(1) the client sends the access token containing, or referencing, the authorization information
      to the RS, that may be used for
      subsequent resource requests by the client, and </t>
<t>(2) the client makes the resource access request, using the communication security protocol and other
    RS Information obtained from the AS.</t>
</list>

      <vspace blankLines="1"/>
      The Client and the RS mutually authenticate using the security protocol
      specified in the profile (see step B) and the keys obtained in the access
      token or the RS Information or the client token.  The RS verifies
      that the token is integrity protected by the AS and compares the claims
      contained in the access token with the resource request. If the RS is
      online, validation can be handed over to the AS using token introspection
      (see messages D and E) over HTTP or CoAP, in  which case the different
      parts of step C may be interleaved with
      introspection.<vspace blankLines="0"/>
    </t>

    <t hangText="Token Introspection Request (D):"><vspace blankLines="1"/>
      A resource server may be configured to introspect the access token by
      including it in a request to the introspection endpoint at that AS.
      Token introspection over
      CoAP is defined in <xref target="introspectionEndpoint"/> and for HTTP in
      <xref target="RFC7662"/>.
      <vspace blankLines="1"/>
      Note that token introspection is an optional step and can be omitted if
      the token is self-contained and the resource server is prepared to
      perform the token validation on its own.<vspace blankLines="0"/>
    </t>

    <t hangText="Token Introspection Response (E):"><vspace blankLines="1"/>
      The AS validates the token and returns the most recent parameters, such
      as scope, audience, validity etc. associated with it back to the RS.  The
      RS then uses the received parameters to process the request to either
      accept or to deny it. The AS can additionally return information that the
      RS needs to pass on to the client in the form of a client token.  The
      latter is used to establish keys for mutual authentication between
      client and RS, when the client has no direct connectivity to the
      AS, see <xref target="clientToken"/> for details.<vspace blankLines="0"/>
    </t>

    <t hangText="Protected Resource (F):"><vspace blankLines="1"/>
      If the request from the client is authorized, the RS fulfills the request
      and returns a response with the appropriate response code.  The RS uses
      the dynamically established keys to protect the response, according to
      used communication security protocol.
    </t>
  </list>
  </t>
</section>



<!-- ***************************************************** -->

<section anchor="oauthProfile" title="Framework">

  <t>The following sections detail the profiling and extensions of OAuth 2.0
  for constrained environments, which constitutes the ACE framework.
  </t>

  <t>
    <list style="hanging">
      <t hangText="Credential Provisioning"><vspace blankLines="1"/>
        For IoT, it cannot be assumed that the client and RS are part of a
	common key infrastructure, so the AS provisions credentials or
	associated information to allow mutual authentication. These
	credentials need to be provided to the parties before or during the
	authentication protocol is executed, and may be re-used for subsequent
	token requests.
        <vspace blankLines="0"/>
      </t>

      <t hangText="Proof-of-Possession"><vspace blankLines="1"/>
        The ACE framework, by default, implements proof-of-possession for
	access tokens, i.e., that the token holder can prove being a holder of
	the key bound to the token.  The binding is provided by the "cnf" claim
	<xref target="I-D.jones-ace-cwt-proof-of-possession"/> indicating what
	key is used for	proof-of-possession. If a client needs to submit a new
	access token e.g., to obtain additional access rights, they can request
	that the AS binds this token to the same key as the previous one.
	<vspace blankLines="0"/>
      </t>

      <t hangText="ACE Profiles"><vspace blankLines="1"/>
        The client or RS may be limited in the encodings or protocols it
        supports.  To support a variety of different deployment settings,
        specific interactions between client and RS are defined in an ACE
        profile.  In ACE framework the AS is expected to manage the matching
	of compatible profile choices between a client and an RS.  The AS
	informs the client of the selected profile using the "profile"
	parameter in the token response.
        <vspace blankLines="0"/>
      </t>
    </list>
  </t>

  <t>OAuth 2.0 requires the use of TLS both to protect the communication
  between AS and client when requesting an access token; between client and RS
  when accessing a resource and between AS and RS
  if introspection is used.  In constrained settings TLS is not always feasible,
  or desirable.  Nevertheless it is REQUIRED that the
  data exchanged with the AS is encrypted and integrity protected.  It is
  furthermore REQUIRED that the AS and the endpoint communicating with it
  (client or RS) perform mutual authentication.</t>

  <t>Profiles MUST specify how mutual authentication is done, depending e.g.
  on the communication protocol and the credentials used by the client or the
  RS.
  </t>

  <t>In OAuth 2.0 the communication with the Token and the Introspection
  endpoints at the AS is assumed to be via HTTP and may use Uri-query
  parameters.  This framework RECOMMENDS to use CoAP instead and RECOMMENDS the
  use of the following alternative instead of Uri-query parameters: The sender
  (client or RS) encodes the parameters of its request as a CBOR map and
  submits that map as the payload  of the POST request.  The Content-format
  depends on the security applied to the content and MUST be specified by the
  profile that is used.
  </t>

  <t>The OAuth 2.0 AS uses a JSON structure in the payload of its responses
  both to client and RS.  This framework REQUIRES the use of CBOR
  <xref target="RFC7049"/> instead.  Depending on the profile, the CBOR
  payload MAY be enclosed in a non-CBOR cryptographic wrapper.</t>

<section anchor="asDiscovery" title="Discovering Authorization Servers">
  <t>In order to determine the AS in charge of a resource hosted at the RS, C
  MAY send an initial Unauthorized Resource Request message to RS.  RS then
  denies the request and sends the address of its AS back to C.</t>

  <t>Instead of the initial Unauthorized Resource Request message, C MAY
   look up the desired resource in a resource directory (cf.
  <xref target="I-D.ietf-core-resource-directory"/>).</t>

  <section anchor="rreq" title="Unauthorized Resource Request Message">
    <t>The optional Unauthorized Resource Request message is a request for a
    resource hosted by RS for which no proper authorization is granted. RS MUST
    treat any request for a protected resource as Unauthorized Resource
    Request message when any of the following holds:

      <list style="symbols">
	<t>The request has been received on an unprotected channel.</t>
	<t>RS has no valid access token for the sender of the request
	regarding the requested action on that resource.</t>
	<t>RS has a valid access token for the sender of the request, but
	this does not allow the requested action on the requested
	resource.</t>
      </list>
    </t>

    <t>Note: These conditions ensure that RS can handle requests autonomously
    once access was granted and a secure channel has been established between C
    and RS. The authz-info endpoint MUST NOT be protected as specified above,
    in order to allow clients to upload access tokens to RS (cf.
    <xref target="tokenAuthInfoEndpoint"/>).</t>

    <t>Unauthorized Resource Request messages MUST be denied with a client
    error response. In this response, the Resource Server SHOULD provide proper
    AS Information to enable the Client to request an access token from
    RS's AS as described in <xref
    target="asInfo"/>.</t>

    <t>The response code MUST be 4.01 (Unauthorized) in case the sender of the
    Unauthorized Resource Request message is not authenticated, or if RS has no
    valid access token for C. If RS has an access token for C but not for the
    resource that C has requested, RS MUST reject the request with a 4.03
    (Forbidden). If RS has an access token for C but it does not cover the
    action C requested on the resource, RS MUST reject the request with a 4.05
    (Method Not Allowed).</t>

    <t>Note: The use of the response codes 4.03 and 4.05 is intended to prevent
    infinite loops where a dumb Client optimistically tries to access a
    requested resource with any access token received from AS. As malicious
    clients could pretend to be C to determine C's privileges, these detailed
    response codes must be used only when a certain level of security is
    already available which can be achieved only when the Client is
    authenticated.</t>
  </section><!-- Unauthorized Request -->

  <section anchor="asInfo" title="AS Information">
    <t>The AS Information is sent by RS as a response to an
    Unauthorized Resource Request message (see <xref target="rreq"/>) to point
    the sender of the Unauthorized Resource Request message to RS’s AS. The AS
    information is a set of attributes containing an absolute URI (see
    Section 4.3 of <xref target="RFC3986"/>) that specifies the AS in charge of
    RS.</t>

    <t>The message MAY also contain a nonce generated by RS to ensure freshness
    in case that the RS and AS do not have synchronized clocks.</t>

    <t><xref target="fig:asinfo"/> summarizes the parameters that may be
    part of the AS Information.

      <figure align="center" anchor="fig:asinfo"
	      title="AS Information parameters">
      <artwork align="left"><![CDATA[
        /----------------+----------+-------------------\
        | Parameter name | CBOR Key | Major Type        |
        |----------------+----------+-------------------|
        | AS             |    0     |   3 (text string) |
        | nonce          |    5     |   2 (byte string) |
        \----------------+----------+-------------------/
      ]]></artwork></figure></t>

    <t><xref target="fig:as-info-payload"/> shows an example for an AS
    Information message payload using CBOR <xref target="RFC7049"/> diagnostic
    notation, using the parameter names instead of the CBOR keys for better
    human readability.</t>

    <figure title="AS Information payload example"
	    anchor="fig:as-info-payload"><artwork><![CDATA[
    4.01 Unauthorized
    Content-Format: application/ace+cbor
    {AS: "coaps://as.example.com/token",
     nonce: h'e0a156bb3f'}
]]></artwork></figure>

    <t>In this example, the attribute AS points the receiver of this message
    to the URI “coaps://as.example.com/token” to request access permissions.
    The originator of the AS Information payload (i.e., RS) uses a local clock
    that is loosely synchronized with a time scale common between RS and AS
    (e.g., wall clock time). Therefore, it has included a parameter <spanx
    style="verb">nonce</spanx> for replay attack prevention.</t>

    <t><list style="hanging">
      <t hangText='Note: There is an ongoing discussion how freshness of
		   access tokens'>
	can be achieved in constrained environments. This specification for
	now assumes that RS and AS do not have a common understanding of time
	that allows RS to achieve its security objectives without explicitly
	adding a nonce.</t>
    </list></t>

    <t><xref target="fig:as-info-cbor"/> illustrates the mandatory to use
    binary encoding of the message payload shown in
    <xref target="fig:as-info-payload"/>.</t>

    <figure title="AS Information example encoded in CBOR"
	    anchor="fig:as-info-cbor"><artwork><![CDATA[
a2                                   # map(2)
    00                               # unsigned(0) (=AS)
    78 1c                            # text(28)
       636f6170733a2f2f61732e657861
       6d706c652e636f6d2f746f6b656e  # "coaps://as.example.com/token"
    05                               # unsigned(5) (=nonce)
    45                               # bytes(5)
       e0a156bb3f
]]></artwork></figure>
  </section><!--AS information-->

</section><!-- AS discovery -->


<section anchor="authorizationGrants" title="Authorization Grants">
  <t>To request an access token, the client obtains authorization from the
  resource owner or uses its client credentials as grant.  The authorization
  is expressed in the form of an authorization grant.</t>

  <t>The OAuth framework defines four grant types. The grant types can
  be split up into two groups, those granted on behalf of the resource
  owner (password, authorization code, implicit) and those for the client
  (client credentials).</t>

  <t>The grant type is selected depending on the use case.  In cases where
  the client acts on behalf of the resource owner, authorization code
  grant is recommended.  If the client acts on behalf of the resource owner,
  but does not have any display or very limited interaction possibilities it is
  recommended to use the device code grant defined in
  <xref target="I-D.ietf-oauth-device-flow"/>.  In cases where the client
  does not act on behalf of the resource owner, client credentials grant is
  recommended.</t>

  <t>For details on the different grant types, see the OAuth 2.0 framework
  <xref target="RFC6749"/>. The OAuth 2.0 framework provides an extension
  mechanism for defining additional grant types so profiles of this framework
  MAY define additional grant types, if needed.</t>
</section> <!--Grants-->

<section anchor="clientCredentials" title="Client Credentials">
  <t>Authentication of the client is mandatory independent of the grant type
  when requesting the access token from the token endpoint. In the case of
  client credentials grant type, the authentication and grant coincide.</t>

  <t>Client registration and provisioning of client credentials to the client
  is out of scope for this specification.</t>

  <t>The OAuth framework <xref target="RFC6749"/> defines one client
  credential type, client id and client secret. <xref target="I-D.erdtman-ace-rpcc"/>
  adds raw-public-key and pre-shared-key to the client credentials types.  Profiles of
  this framework MAY extend with additional client credentials client certificates.</t>
</section> <!--Client Credentials-->

<section anchor="ASAuthentication" title="AS Authentication">
  <t>Client credential does not, by default, authenticate the AS that the client
  connects to. In classic OAuth, the AS is authenticated with a TLS server
  certificate.</t>

  <t>Profiles of this framework MUST specify how clients authenticate the AS
  and how communication security is implemented, otherwise server side TLS
  certificates, as defined by OAuth 2.0, are required.</t>
</section> <!--AS Authentication-->

<section anchor="authorizeEndpoint" title="The Authorization Endpoint">
  <t>The authorization endpoint is used to interact with the resource owner
  and obtain an authorization grant in certain grant flows.  Since it requires
  the use of a user agent (i.e., browser), it is not expected that these types
  of grant flow will be used by constrained clients.  This endpoint is
  therefore out of scope for this specification.  Implementations should use
  the definition and recommendations of <xref target="RFC6749"/> and
  <xref target="RFC6819"/>.</t>

  <t>If clients involved cannot support HTTP and TLS, profiles MAY define
  mappings for the authorization endpoint.</t>
</section> <!--The 'Authorize' Endpoint-->

<section anchor="tokenEndpoint" title="The Token Endpoint">
  <t>In standard OAuth 2.0, the AS provides the token endpoint for submitting
  access token requests.  This framework extends the functionality of the
  token endpoint, giving the AS the possibility to help the client and RS to
  establish shared keys or to exchange their public keys.  Furthermore,
  this framework defines encodings using CBOR, as a substitute for JSON.</t>

  <t>For the AS to be able to issue a token, the client MUST be authenticated and
  present a valid grant for the scopes requested.  Profiles of this framework
  MUST specify how the AS authenticates the client and how the communication
  between client and AS is protected.</t>

  <t>The figures of this section use CBOR diagnostic
  notation without the integer abbreviations for the parameters or their
  values for illustrative purposes. Note that implementations MUST use the
  integer abbreviations and the binary CBOR encoding.</t>

  <section anchor="tokenRequest" title="Client-to-AS Request">
    <t>The client sends a POST request to the token endpoint
    at the AS. The profile MUST specify the Content-Type and wrapping of the
    payload.  The content of the request consists of the parameters specified
    in section 4 of the OAuth 2.0 specification <xref
    target="RFC6749"/>, encoded as a CBOR map.</t>

    <t>In addition to these parameters, this framework defines the following
    parameters for requesting an access token from a token endpoint:

      <list style="hanging">
	<t hangText="aud"><vspace blankLines="0"/>
	OPTIONAL.  Specifies the audience for which the client is
	requesting an access token.  If this parameter is missing, it is
	assumed that the client and the AS have a pre-established understanding
	of the audience that an access token should address.  If a client
	submits a request for an access token without specifying an "aud"
	parameter, and the AS does not have an implicit understanding of
	the "aud" value for this client, then the AS MUST respond with an error
	message	using a response code equivalent to the CoAP response code 4.00
	(Bad Request).
	<vspace blankLines="1"/></t>

	<t hangText="cnf"><vspace blankLines="0"/>
	OPTIONAL.  This field contains information about the key the
	client would like to bind to the access token for proof-of-possession.
	It is RECOMMENDED that an AS reject a request containing a symmetric key
	value in the 'cnf' field, since the AS is expected to be able to
	generate better symmetric keys than a potentially constrained client.
	See <xref target="paramCnf"/> for more details on the formatting of the
	'cnf' parameter.</t>
      </list>
    </t>

    <t>The following examples illustrate different types of requests
    for proof-of-possession tokens. </t>

    <t><xref target="fig:symmATreq"/> shows a request for a token
    with a symmetric proof-of-possession key.  Note that in this example
    it is assumed that transport layer communication security is used, therefore
    the Content-Type is "application/cbor".  The content is displayed in
    CBOR diagnostic notation, without abbreviations for better readability.

    <figure align="center" anchor="fig:symmATreq"
            title="Example request for an access token bound to a
		   symmetric key.">
        <artwork align="left"><![CDATA[
Header: POST (Code=0.02)
Uri-Host: "server.example.com"
Uri-Path: "token"
Content-Type: "application/cbor"
Payload:
{
  "grant_type" : "client_credentials",
  "client_id" : "myclient",
  "aud" : "tempSensor4711"
 }
        ]]></artwork>
    </figure></t>

    <t><xref target="fig:asymmATreq"/> shows a request for a token with an
    asymmetric proof-of-possession key.  Note that in this example COSE is used
    to provide object-security, therefore the Content-Type is
    "application/cose".

    <figure align="center" anchor="fig:asymmATreq"
            title="Example token request bound to an asymmetric key.">
        <artwork align="left"><![CDATA[
Header: POST (Code=0.02)
Uri-Host: "server.example.com"
Uri-Path: "token"
Content-Type: "application/cose"
Payload:
"COSE_Encrypted" : {
   16(
      [ h'a1010a', # protected header: {"alg" : "AES-CCM-16-64-128"}
      {5 : b64'ifUvZaHFgJM7UmGnjA'},  # unprotected header, IV
      b64'WXThuZo6TMCaZZqi6ef/8WHTjOdGk8kNzaIhIQ' # ciphertext
      ]
   )
}

Decrypted payload:
{
  "grant_type" : "client_credentials",
  "client_id" : "myclient",
  "cnf" : {
    "COSE_Key" : {
      "kty" : "EC",
      "kid" : h'11',
      "crv" : "P-256",
      "x" : b64'usWxHK2PmfnHKwXPS54m0kTcGJ90UiglWiGahtagnv8',
      "y" : b64'IBOL+C3BttVivg+lSreASjpkttcsz+1rb7btKLv8EX4'
    }
  }
}
        ]]></artwork>
    </figure></t>

    <t><xref target="fig:kidATreq"/> shows a request for a token
    where a previously communicated proof-of-possession key is only
    referenced.  Note that a transport layer based communication security
    profile is assumed in this example, therefore the Content-Type is
    "application/cbor".  Also note that the client performs a password
    based authentication in this example by submitting its client_secret
    (see section 2.3.1. of <xref target="RFC6749"/>).

    <figure align="center" anchor="fig:kidATreq"
            title="Example request for an access token bound to a
		   key reference.">
        <artwork align="left"><![CDATA[
Header: POST (Code=0.02)
Uri-Host: "server.example.com"
Uri-Path: "token"
Content-Type: "application/cbor"
Payload:
{
  "grant_type" : "client_credentials",
  "client_id" : "myclient",
  "client_secret" : "mysecret234",
  "aud" : "valve424",
  "scope" : "read",
  "cnf" : {
    "kid" : b64'6kg0dXJM13U'
  }
}
       ]]></artwork>
    </figure></t>

  </section>

  <section anchor="tokenResponse" title="AS-to-Client Response">
    <t>If the access token request has been successfully verified by the
    AS and the client is authorized to obtain an access token corresponding
    to its access token request, the AS sends a response with the response
    code equivalent to the CoAP response code 2.01 (Created).  If client
    request was invalid, or not authorized, the AS returns an error response as
    described in <xref
    target="errorsToken"/>.</t>

    <t>Note that the AS decides which token type and profile to use when
    issuing a successful response.  It is assumed that the AS has prior
   knowledge of the capabilities of the client and the RS (see <xref
   target="app:registration"/>.  This prior knowledge may, for example, be set
   by the use of a dynamic client registration protocol exchange
   <xref target="RFC7591"/>.</t>

    <t>The content of the successful reply is the RS Information. It MUST be
    encoded as CBOR map, containing parameters as specified in section 5.1 of
    <xref target="RFC6749"/>.  In addition to these parameters, the following
    parameters are also part of a successful response:

    <list style="hanging">
	<t hangText="profile"><vspace blankLines="0"/>
	OPTIONAL.  This indicates the profile that the client MUST use
	towards the RS. See <xref target="paramProfile"/> for the formatting of
	this parameter.<vspace blankLines="1"/>. If this parameter is absent,
	the AS assumes that the client implicitly knows which profile to use
	towards the RS.</t>

	<t hangText="cnf"><vspace blankLines="0"/>
	REQUIRED if the token type is "pop" and a symmetric key is used.
	MUST NOT be present otherwise. This field contains the symmetric
	proof-of-possession key the client is supposed to use.  See <xref
	target="paramCnf"/> for details on the use of this parameter.</t>

	<t hangText="rs_cnf"><vspace blankLines="0"/>
	OPTIONAL if the token type is "pop" and asymmetric keys are used.
	MUST NOT be present otherwise. This field contains information about
	the public key used by the RS to authenticate.  See <xref
	target="paramCnf"/> for details on the use of this parameter. If this
	parameter is absent, the AS assumes that the client already knows
	the public key of the RS.</t>

	<t hangText="token_type"><vspace blankLines="0"/>
	OPTIONAL.  By default implementations of this framework SHOULD assume
	that the token_type is "pop".  If a specific use case requires another
	token_type (e.g., "Bearer") to be used then this parameter is REQUIRED.
	</t>
      </list>
    </t>

    <t>Note that if CBOR Web Tokens <xref
    target="I-D.ietf-ace-cbor-web-token"/> are used, the access token can also
    contain a "cnf" claim <xref
    target="I-D.jones-ace-cwt-proof-of-possession"/>.  This claim is however
    consumed by a different party.  The access token is created by the AS and
    processed by the RS (and opaque to the client) whereas the RS Information
    is created by the AS and processed by the client; it is never forwarded to
    the resource server.</t>

    <t><xref target="fig:rsinfo"/> summarizes the parameters that
    may be part of the RS Information.

      <figure align="center" anchor="fig:rsinfo"
              title="RS Information parameters">
      <artwork align="left"><![CDATA[
        /-------------------+--------------------------\
        | Parameter name    | Specified in             |
        |-------------------+--------------------------|
        | access_token      |  RFC 6749                |
        | token_type        |  RFC 6749                |
        | expires_in        |  RFC 6749                |
        | refresh_token     |  RFC 6749                |
        | scope             |  RFC 6749                |
        | state             |  RFC 6749                |
        | error             |  RFC 6749                |
        | error_description |  RFC 6749                |
        | error_uri         |  RFC 6749                |
        | profile           | [[ this specification ]] |
        | cnf               | [[ this specification ]] |
        | rs_cnf            | [[ this specification ]] |
        \-------------------+--------------------------/
      ]]></artwork></figure>

    </t>

    <t><xref target="fig:symmATres"/> shows a response containing a token
    and a "cnf" parameter with a symmetric proof-of-possession key.  Note that
    transport layer security is assumed in this example,
    therefore the Content-Type is "application/cbor".

    <figure align="center" anchor="fig:symmATres"
            title="Example AS response with an access token bound to a
		   symmetric key.">
      <artwork align="left"><![CDATA[
Header: Created (Code=2.01)
Content-Type: "application/cbor"
Payload:
{
  "access_token" : b64'SlAV32hkKG ...
   (remainder of CWT omitted for brevity;
   CWT contains COSE_Key in the "cnf" claim)',
  "profile" : "coap_dtls",
  "expires_in" : "3600",
  "cnf" : {
    "COSE_Key" : {
      "kty" : "Symmetric",
      "kid" : b64'39Gqlw',
      "k" : b64'hJtXhkV8FJG+Onbc6mxCcQh'
    }
  }
}
      ]]></artwork>
    </figure></t>
  </section>

  <section anchor="errorsToken" title="Error Response">
    <t>The error responses for CoAP-based interactions with the AS
    are equivalent to the ones for HTTP-based interactions as defined in
    section 5.2 of <xref target="RFC6749"/>, with the following differences:

      <list style="symbols">
        <t>The Content-Type MUST be specified by the communication security
	profile used between client and AS.  The raw payload before being
	processed by the communication security protocol MUST be encoded as a
	CBOR map.</t>

        <t>A response code equivalent to the CoAP code 4.00 (Bad Request) MUST
	be used for all error responses, except for invalid_client where a
	response code equivalent to the CoAP code 4.01 (Unauthorized) MAY be
	used under the same conditions as specified in section 5.2 of
	<xref target="RFC6749"/>.
	</t>

	<t>The parameters "error", "error_description" and "error_uri" MUST
	be abbreviated using the codes specified in <xref
	target="fig:cborTokenParameters"/>.</t>

	<t>The error code (i.e., value of the "error" parameter) MUST be
	abbreviated as specified in <xref
	target="fig:cborErrorCodes"/>.</t>
      </list>

      <figure align="center" anchor="fig:cborErrorCodes"
              title="CBOR abbreviations for common error codes">
        <artwork align="left"><![CDATA[
        /------------------------+-------------------\
        | error code             | CBOR Value (uint) |
        |------------------------+-------------------|
        | invalid_request        |         0         |
        | invalid_client         |         1         |
        | invalid_grant          |         2         |
        | unauthorized_client    |         3         |
        | unsupported_grant_type |         4         |
        | invalid_scope          |         5         |
        | unsupported_pop_key    |         6         |
        \------------------------+-------------------/
        ]]></artwork>
      </figure>
    </t>

    <t>In addition to the error responses defined in OAuth 2.0, the following
    behavior MUST be implemented by the AS: If the client submits an
    asymmetric key in the token request that the RS cannot process, the AS MUST
    reject that request with a response code equivalent to the CoAP code 4.00
    (Bad Request) including the error code "unsupported_pop_key" defined in
    <xref target="fig:cborErrorCodes"/>.</t>
  </section>

  <section anchor="tokenParams"
	   title="Request and Response Parameters">
    <t>This section provides more detail about the new parameters that can be
    used in access token requests and responses, as well as abbreviations for
    more compact encoding of existing parameters and common parameter
    values.</t>

    <section anchor="paramAud" title="Audience">
      <t>This parameter specifies for which audience the client is requesting
      a token.  It should be encoded as CBOR text string (major type 3).  The
      formatting and semantics of these strings are application specific.</t>
    </section>

    <section anchor="paramGrantType" title="Grant Type">
      <t>The abbreviations in <xref target="fig:grant_types"/> MUST be
      used in CBOR encodings instead of the string values defined
      in <xref target="RFC6749"/>.

      <figure align="center" anchor="fig:grant_types"
              title="CBOR abbreviations for common grant types ">
        <artwork align="left"><![CDATA[
        /--------------------+-------------------\
        | grant_type         | CBOR Value (uint) |
        |--------------------+-------------------|
        | password           |        0          |
        | authorization_code |        1          |
        | client_credentials |        2          |
        | refresh_token      |        3          |
        \--------------------+-------------------/
        ]]></artwork>
      </figure></t>
    </section>

    <section anchor="paramTokenType" title="Token Type">
      <t>The token_type parameter is defined in <xref target="RFC6749"/>,
      allowing the AS to indicate to the client which type of access token it
      is receiving (e.g., a bearer token). </t>

      <t>This document registers the new value "pop" for the OAuth Access
        Token Types registry,  specifying a Proof-of-Possession token.  How the
      proof-of-possession is performed MUST be specified by the profiles.</t>

      <t>The values in the "token_type" parameter MUST be CBOR text strings
      (major type 3).</t>

      <t>In this framework token type "pop" MUST be assumed by default if the
      AS does not provide a different value.</t>
    </section>

    <section anchor="paramProfile" title="Profile">

      <t>Profiles of this framework MUST define the communication
      protocol and the communication security protocol between the client
      and the RS.  The security protocol MUST provide encryption, integrity and
      replay protection.  Furthermore profiles MUST define proof-of-possession
      methods, if they support proof-of-possession tokens.</t>

      <t>A profile MUST specify an identifier that can be used to uniquely
      identify itself in the "profile" parameter.</t>

      <t>Profiles MAY define additional parameters for both the token request
      and the RS Information in the access token response in order to
      support negotiation or signaling of profile specific parameters.
      </t>
    </section>

    <section anchor="paramCnf" title="Confirmation">
      <t>The "cnf" parameter identifies or provides the key used for
      proof-of-possession, while the "rs_cnf" parameter provides the raw public
      key of the RS.  Both parameters use the same formatting and semantics as
      the "cnf" claim specified in
      <xref target="I-D.jones-ace-cwt-proof-of-possession"/>.</t>

      <t>In addition to the use as a claim in a CWT, the "cnf" parameter is
      used in the following contexts with the following meaning:

      <list style="symbols">
	<t>In the token request C -> AS, to indicate the
	client's raw public key, or the key-identifier of a previously
	established key between C and RS.</t>

	<t>In the token response AS -> C, to indicate the
	symmetric key generated by the AS for proof-of-possession.</t>

	<t>In the introspection response AS -> RS, to indicate
	the proof-of-possession	key bound to the introspected token.</t>

	<t> In the client token AS -> RS -> C, to indicate
	the proof-of-possession	key bound to the access token.</t>

      </list></t>

      <t>Note that the COSE_Key structure in a "cnf" claim or parameter
      may contain an "alg" or "key_ops" parameter.  If such parameters are
      present, a client MUST NOT use a key that is not compatible with
      the profile or proof-of-possession algorithm according to those
      parameters. An RS MUST reject a proof-of-possession using such a key.
      </t>
    </section>
  </section> <!--Parameters -->

  <section anchor="tokenCborParams" title="Mapping parameters to CBOR">
    <t>All OAuth parameters in access token requests and responses MUST be
    mapped to CBOR types as specified in <xref
    target="fig:cborTokenParameters"/>, using the given integer abbreviation
    for the key.</t>
    <t>Note that we have aligned these abbreviations with the claim
    abbreviations defined in <xref target="I-D.ietf-ace-cbor-web-token"/>.</t>

    <t>
      <figure align="center" anchor="fig:cborTokenParameters"
              title="CBOR mappings used in token requests">
        <artwork align="left"><![CDATA[
        /-------------------+----------+------------------\
        | Parameter name    | CBOR Key | Type             |
        |-------------------+----------+------------------|
        | aud               | 3        | text string      |
        | client_id         | 8        | text string      |
        | client_secret     | 9        | byte string      |
        | response_type     | 10       | text string      |
        | redirect_uri      | 11       | text string      |
        | scope             | 12       | text string      |
        | state             | 13       | text string      |
        | code              | 14       | byte string      |
        | error             | 15       | text string      |
        | error_description | 16       | text string      |
        | error_uri         | 17       | text string      |
        | grant_type        | 18       | unsigned integer |
        | access_token      | 19       | text string      |
        | token_type        | 20       | unsigned integer |
        | expires_in        | 21       | unsigned integer |
        | username          | 22       | text string      |
        | password          | 23       | text string      |
        | refresh_token     | 24       | text string      |
        | cnf               | 25       | map              |
        | profile           | 26       | text string      |
        | rs_cnf            | 31       | map              |
        \-------------------+----------+------------------/
      ]]></artwork>
    </figure>
  </t>
  </section>
</section><!-- Token endpoint -->

<section anchor="introspectionEndpoint" title="The 'Introspect' Endpoint">
  <t>Token introspection <xref target="RFC7662"/> can be OPTIONALLY provided by
  the AS, and is then used by the RS and potentially the client to query the AS
  for metadata about a given token e.g., validity or scope. Analogous to the
  protocol defined in RFC 7662 <xref target="RFC7662"/> for HTTP and JSON, this
  section defines adaptations to more constrained  environments using CBOR and
  leaving the choice of the application protocol to the profile.</t>

  <t>Communication between the RS and the introspection endpoint at the
  AS MUST be integrity protected and encrypted.  Furthermore AS and RS
  MUST perform mutual authentication.  Finally the AS SHOULD verify that the
  RS has the right to access introspection information about the provided
  token.  Profiles of this framework that support introspection MUST specify
  how authentication and communication security between RS and AS is
  implemented.</t>

  <t>The figures of this section uses CBOR diagnostic
  notation without the integer abbreviations for the parameters or their
  values for better readability.
  </t>

  <t>Note that supporting introspection is OPTIONAL for implementations
  of this framework.</t>

  <section anchor="introRS2AS" title="RS-to-AS Request">
    <t>The RS sends a POST request to the introspection endpoint
    at the AS, the profile MUST specify the Content-Type and
    wrapping of the payload.  The payload MUST be encoded as a CBOR map with a
    "token" parameter containing either the access token or a reference to
    the token (e.g., the cti).  Further optional parameters representing
    additional context that is known by the RS to aid the AS in its
    response MAY be included.</t>

    <t>The same parameters are required and optional as in section 2.1
    of RFC 7662 <xref target="RFC7662"/>.</t>

    <t>For example, <xref target="fig:introReq"/> shows a RS calling the token
    introspection endpoint at the AS to query about an OAuth 2.0
    proof-of-possession token.  Note that object security based on COSE is
    assumed in this example, therefore the Content-Type
    is "application/cose+cbor".

    <figure align="center" anchor="fig:introReq"
            title="Example introspection request.">
        <artwork align="left"><![CDATA[
Header: POST (Code=0.02)
Uri-Host: "server.example.com"
Uri-Path: "introspect"
Content-Type: "application/cose+cbor"
Payload:
{
  "token" : b64'7gj0dXJQ43U',
  "token_type_hint" : "pop"
}
       ]]></artwork>
    </figure></t>
  </section>

  <section anchor="introAS2RS" title="AS-to-RS Response">
    <t>If the introspection request is authorized and successfully processed,
    the AS sends a response with the response code equivalent to the CoAP code
    2.01 (Created).  If the introspection request was invalid, not authorized
    or couldn't be processed the AS returns an error response as described in
    <xref target="errorsIntro"/>.</t>

    <t>In a successful response, the AS encodes the response parameters in
    a CBOR map including with the same required and optional parameters as in
    section 2.2. of RFC 7662 <xref target="RFC7662"/> with the following
    additions:

    <list style="hanging">

      <t hangText="cnf"><vspace blankLines="0"/>
      OPTIONAL.   This field contains information about the proof-of-possession
      key that binds the client to the access token.  See <xref
      target="paramCnf"/> for more details on the use of the "cnf"
      parameter.<vspace blankLines="1"/></t>

      <t hangText="profile"><vspace blankLines="0"/>
      OPTIONAL.  This indicates the profile that the RS MUST use with the
      client.  See <xref target="paramProfile"/> for more details on the
      formatting of this parameter.
      <vspace blankLines="1"/></t>

      <t hangText="client_token"><vspace blankLines="0"/>
      OPTIONAL.  This parameter contains information that the RS
      MUST pass on to the client.  See <xref target="clientToken"/>
      for more details.</t>
    </list>
    </t>

    <t>For example, <xref target="fig:introRes"/> shows an AS
    response to the introspection request in <xref target="fig:introReq"/>.
    Note that transport layer security is assumed in this
    example, therefore the Content-Type is "application/cbor".


    <figure align="center" anchor="fig:introRes"
            title="Example introspection response.">
      <artwork align="left"><![CDATA[
Header: Created Code=2.01)
Content-Type: "application/cbor"
Payload:
{
  "active" : true,
  "scope" : "read",
  "profile" : "coap_dtls",
  "client_token" : b64'2QPhg0OhAQo ...
  (remainder of client token omitted for brevity)',
  "cnf" : {
    "COSE_Key" : {
      "kty" : "Symmetric",
      "kid" : b64'39Gqlw',
      "k" : b64'hJtXhkV8FJG+Onbc6mxCcQh'
    }
  }
}
      ]]></artwork>
    </figure></t>
  </section>

  <section anchor="errorsIntro" title="Error Response">
    <t>The error responses for CoAP-based interactions with the AS
    are equivalent to the ones for HTTP-based interactions as defined in
    section 2.3 of <xref target="RFC7662"/>, with the following differences:

    <list style="symbols">
      <t>If content is sent, the Content-Type MUST be set according to the
      specification of the communication security profile, and the content
      payload MUST be encoded as a CBOR map.</t>

      <t>If the credentials used by the RS are invalid the AS MUST respond
      with the response code equivalent to the CoAP code 4.01 (Unauthorized)
      and use the required and optional parameters from section 5.2 in RFC 6749
      <xref target="RFC6749"/>.</t>

      <t>If the RS does not have the right to perform this introspection
      request, the AS MUST respond with a response code equivalent to the
      CoAP code 4.03 (Forbidden).  In this case no payload is returned.</t>

      <t>The parameters "error", "error_description" and "error_uri" MUST
      be abbreviated using the codes specified in <xref
      target="fig:cborTokenParameters"/>.</t>

      <t>The error codes MUST be abbreviated using the codes specified in
      <xref target="fig:cborErrorCodes"/>.</t>
    </list>
    </t>

    <t>Note that a properly formed and authorized query for an inactive or
    otherwise invalid token does not warrant an error response by this
    specification.  In these cases, the authorization server MUST instead
    respond with an introspection response with the "active" field set to
    "false".</t>
  </section>

  <section anchor="clientToken" title="Client Token">
    <t>In cases where the client has limited connectivity and
    needs to get access to a previously unknown resource servers, this framework
    suggests the following OPTIONAL approach:  The client is pre-configured
    with a long-term access token, which is not self-contained (i.e. it is only
    a reference to a token at the AS) when it is commissioned.  When the client
    then tries to access a RS it transmits this access token.  The RS then
    performs token introspection to learn what access this token grants.  In
    the introspection response, the AS also relays information for the client,
    such as the proof-of-possession key, through the RS.  The RS passes on this
    Client Token to the client in response to the submission of the token.</t>
    
    <t>The client_token parameter is designed to carry such information, and is
    intended to be used as described in <xref target="fig:client_token"/>.

    <figure align="center" anchor="fig:client_token"
               title="Use of the client_token parameter.">
      <artwork align="left"><![CDATA[
                  Resource       Authorization
 Client            Server           Server
    |                |                |
    |                |                |
C:  +--------------->|                |
    |  POST          |                |
    |  Access Token  |                |
    |            D:  +--------------->|
    |                | Introspection  |
    |                |    Request     |
    |                |                |
    |            E:  +<---------------+
    |                | Introspection  |
    |                |   Response     |
    |                | + Client Token |
    |<---------------+                |
    |  2.01 Created  |                |
    | + Client Token |
    ]]></artwork>
    </figure>
    </t>

    <t>The client token is a COSE_Encrypted object, containing as payload
    a CBOR map with the following claims:

    <list style="hanging">
      <t hangText="cnf"><vspace blankLines="0"/>
      REQUIRED if the token type is "pop", OPTIONAL otherwise.  Contains
      information about the proof-of-possession key the client is to use with
      its access token.  See <xref target="paramCnf"/>.<vspace
      blankLines="1"/></t>

      <t hangText="token_type"><vspace blankLines="0"/>
      OPTIONAL. See <xref target="paramTokenType"/>.<vspace
      blankLines="1"/></t>

      <t hangText="profile"><vspace blankLines="0"/>
      REQUIRED. See <xref target="paramProfile"/>.<vspace
      blankLines="1"/></t>

      <t hangText="rs_cnf"><vspace blankLines="0"/>
      OPTIONAL. Contains information about the key that the RS uses
      to authenticate towards the client.  If the key is symmetric then
      this claim MUST NOT be part of the Client Token, since this is the
      same key as the one specified through the "cnf" claim.  This claim uses
      the same encoding as the "cnf" parameter.  See <xref
      target="paramProfile"/>.</t>
    </list>
    </t>

    <t>The AS encrypts this token using a key shared between the AS and the
    client, so that only the client can decrypt it and access its payload.
    How this key is established is out of scope of this framework, however it
    can be established at the same time at which the client's long term token
    is created.</t>

    <t>An RS that is configured to perform introspection, MUST do so
    immediately after receiving an access token, in order to be able to
    return a potential client token to the client.  This does not
    preclude the RS to perform additional introspection asynchronously,
    e.g., when the token is later used.</t>
  </section>

  <section anchor="introParamsCbor"
	   title="Mapping Introspection parameters to CBOR">
    <t>The introspection request and response parameters MUST be
    mapped to CBOR types as specified in <xref
    target="fig:cborIntrospectionParameters"/>, using the given integer
    abbreviation for the key.</t>

    <t>Note that we have aligned these abbreviatations with the claim
    abbreviations defined in <xref target="I-D.ietf-ace-cbor-web-token"/>.
    
    <figure align="center" anchor="fig:cborIntrospectionParameters"
            title="CBOR Mappings to Token Introspection Parameters.">
      <artwork align="left"><![CDATA[
          /-----------------+----------+-----------------\
          | Parameter name  | CBOR Key | Major Type      |
          |-----------------+----------+-----------------|
          | iss             | 1        | 3 (text string) |
          | sub             | 2        | 3               |
          | aud             | 3        | 3               |
          | exp             | 4        | 6 tag value 1   |
          | nbf             | 5        | 6 tag value 1   |
          | iat             | 6        | 6 tag value 1   |
          | cti             | 7        | 2 (byte string) |
          | client_id       | 8        | 3               |
          | scope           | 12       | 3               |
          | token_type      | 20       | 3               |
          | username        | 22       | 3               |
          | cnf             | 25       | 5 (map)         |
          | profile         | 26       | 0 (uint)        |
          | token           | 27       | 3               |
          | token_type_hint | 28       | 3               |
          | active          | 29       | 0               |
          | client_token    | 30       | 3               |
          | rs_cnf          | 31       | 5               |
          \-----------------+----------+-----------------/
        ]]></artwork>
      </figure>
    </t>
  </section>

</section><!-- introspection endpoint -->

<section title="The Access Token">
  <t>This framework RECOMMENDS the use of CBOR web token (CWT) as
    specified in <xref target="I-D.ietf-ace-cbor-web-token"/>.
  </t>

  <t>In order to facilitate offline processing of access tokens,
  this draft uses the "cnf" claim from <xref
  target="I-D.jones-ace-cwt-proof-of-possession"/> and specifies the "scope"
  claim for CBOR web tokens.</t>

  <t>The "scope" claim explicitly encodes the scope of a given access token.
  This claim follows the same encoding rules as defined in section 3.3 of <xref
  target="RFC6749"/>.  The meaning of a specific scope value is application
  specific and expected to be known to the RS running that application.</t>

<section anchor="tokenAuthInfoEndpoint" title="The 'Authorization Information' Endpoint">
  <t>The access token, containing authorization information and information
  about the key used by the client, needs to be transported to the RS so that
  the RS can authenticate and authorize the client request.</t>

  <t>This section defines a method for transporting the access token to the RS
  using a RESTful protocol such as CoAP. Profiles of this framework MAY define
  other methods for token transport.
  </t>

  <t>The method consists of an authz-info endpoint, implemented by the
  RS.  A client using this method MUST make a POST request to the authz-info endpoint at
  the RS with the access token in the payload. The RS receiving the token MUST
  verify the validity of the token.  If the token is valid, the RS MUST respond
  to the POST request with 2.01 (Created).  This response MAY contain the
  identifier of the token (e.g., the cti for a CWT) as a payload.</t>
  <!--FIXME: Clarify that this is a suggestion to implmenters and what it would be useful for -->

  <t>If the token is not valid, the RS MUST respond with a response code
  equivalent to the CoAP code 4.01 (Unauthorized).  If the token is valid but
  the audience of the token does not match the RS, the RS MUST respond with a
  response code equivalent to the CoAP code 4.03 (Forbidden).  If the token is
  valid but is associated to claims that the RS cannot process (e.g., an
  unknown scope) the RS MUST respond with a response code equivalent to the
  CoAP code 4.00 (Bad Request). In the latter case the RS MAY provide
  additional information in the error response, in order to clarify
  what went wrong.
  </t>

  <t>The RS MAY make an introspection request to validate the token before
  responding to the POST request to the authz-info endpoint.  If the introspection response
  contains a client token (<xref target="clientToken"/>) then this token
  SHALL be included in the payload of the 2.01 (Created) response.
  </t>

  <t>Profiles MUST specify how the authz-info endpoint is protected.  Note
  that since the token contains information that allow the client and the RS
  to establish a security context in the first place, mutual authentication
  may not be possible at this point.</t>
</section>

<section anchor="tokenValidity" title="Token Expiration">
  <t>Depending on the capabilities of the RS, there are various ways in
    which it can verify the validity of a received access token.  Here follows
    a list of the possibilities including what functionality they require of the
    RS.</t>

  <t><list style="symbols">
    <t>The token is a CWT and includes an "exp" claim and possibly the
    "nbf" claim.  The RS verifies these by comparing them to values from
    its internal clock as defined in <xref target="RFC7519"/>.  In this
    case the RS's internal clock must reflect the current date and time, or
    at least be synchronized with the AS's clock.  How this clock
    synchronization would be performed is out of scope for this specification.</t>

    <t>The RS verifies the validity of the token by performing an
    introspection request as specified in <xref
    target="introspectionEndpoint"/>.  This requires the RS to have a
    reliable network connection to the AS and to be able to handle two
    secure sessions in parallel (C to RS and AS to RS).</t>

    <t>The RS and the AS both store a sequence number linked to their common
    security association.  The AS increments this number for each access
    token it issues and includes it in the access token, which is a
    CWT.  The RS keeps track of the most recently received sequence
    number, and only accepts tokens as valid, that are in a certain range
    around this number.  This method does only require the RS to keep track
    of the sequence number.  The method does not provide timely expiration,
    but it makes sure that older tokens cease to be valid after a certain
    number of newer ones got issued.  For a constrained RS with no network
    connectivity and no means of reliably measuring time, this is the best
    that can be achieved.</t>

  </list></t>

  <t>If a token that authorizes a long running request such as a CoAP
  Observe <xref target="RFC7641"/> expires, the RS MUST send an error
  response with the response code 4.01 Unauthorized to the client and then
  terminate processing the long running request.</t>
  <!-- FIXME: rephrase above for clarity -->
</section>
</section><!-- access token -->

</section> <!--Framework-->

<section anchor="security" title="Security Considerations">

  <t>Security considerations applicable to authentication and authorization
  in RESTful environments provided in OAuth 2.0 <xref target="RFC6749"/> apply
  to this work, as well as the security considerations from
  <xref target="I-D.ietf-ace-actors"/>.  Furthermore <xref target="RFC6819"/>
  provides additional security considerations for OAuth which apply to IoT
  deployments as well.</t>

      <t>A large range of threats can be mitigated by protecting the contents
      of the access token by using a digital signature or a keyed message
      digest (MAC) or an Authenticated Encryption with Associated Data (AEAD)
      algorithm.  Consequently, the token integrity protection MUST be applied
      to prevent the token from being modified, particularly since it contains
      a reference to the symmetric key or the asymmetric key.  If the access
      token contains the symmetric key, this symmetric key MUST be encrypted by
      the authorization server so that only the resource server can decrypt it.
      Note that using an AEAD algorithm is preferable over using a MAC unless
      the message needs to be publicly readable.</t>

      <t>It is important for the authorization server to include the identity
      of the intended recipient (the audience), typically a single resource
      server (or a list of resource servers), in the token.  Using a single
      shared secret with multiple resource servers to simplify key
      management is NOT RECOMMENDED since the benefit from using the
      proof-of-possession concept is significantly reduced.</t>

      <t>The authorization server MUST offer confidentiality protection for
      any interactions with the client.  This step is extremely important
      since the client may obtain the proof-of-possession key from the
      authorization server for use with a specific access token.  Not using
      confidentiality protection exposes this secret (and the access token) to
      an eavesdropper thereby completely negating proof-of-possession security.
      Profiles MUST specify how confidentiality protection is provided,
      and additional protection can be applied by encrypting the token, for
      example encryption of CWTs is specified in section 5.1 of
      <xref target="I-D.ietf-ace-cbor-web-token"/>.</t>

      <t>Developers MUST ensure that the ephemeral credentials (i.e., the
      private key or the session key) are not leaked to third parties.  An
      adversary in possession of the ephemeral credentials bound to the access
      token will be able to impersonate the client.  Be aware that this is a
      real risk with many constrained environments, since adversaries can
      often easily get physical access to the devices.</t>

      <t>Clients can at any time request a new proof-of-possession capable
      access token.  If clients have that capability, the AS can keep the
      lifetime of the access token and the associated proof-of-possession key
      short and therefore use shorter proof-of-possession key sizes, which
      translate to a performance benefit for the client and for the resource
      server.  Shorter keys also lead to shorter messages (particularly with
      asymmetric keying material).</t>

      <t>When authorization servers bind symmetric keys to access tokens,
      they SHOULD scope these access tokens to a specific permissions.
      Furthermore access tokens using symmetric keys for proof-of-possession
      SHOULD NOT be targeted at an audience that contains more than one RS,
      since otherwise any RS in the audience that receives that access token
      can impersonate the client towards the other members of the audience.</t>

      <section anchor="unprotected-as-information"
	       title="Unprotected AS Information">

	<t>Initially, no secure channel exists to protect the communication
	between C and RS. Thus, C cannot determine if the AS information
	contained in an unprotected response from RS to an unauthorized
	request (c.f. <xref target="asInfo"/>) is authentic. It is therefore
	advisable to provide C with a (possibly hard-coded) list of trustworthy
	authorization servers. AS information responses referring to a URI not
	listed there would be ignored.</t>
      </section>

      <section anchor="nonce" title="Use of Nonces for Replay Protection">
	<t>RS may add a nonce to the AS Information message sent as a response
	to an unauthorized request to ensure freshness of an Access Token
	subsequently presented to RS. While a timestamp of some granularity
	would be sufficient to protect against replay attacks, using
	randomized nonce is preferred to prevent disclosure of information
	about RS’s internal clock characteristics.</t>
      </section>

      <section anchor="mixnmatch" title="Combining profiles">
	<t>There may exist reasonable use cases where implementers want to
	combine different profiles of this framework, e.g., using an MQTT profile
	between client and RS, while using a DTLS profile for interactions
	between client and AS. Profiles should be designed in a way that
	the security of a protocol interaction does not depend on the
	specific security mechanisms used in other protocol interactions.</t>
      </section>
      <section anchor="authzInfoLeak" title="Error responses">
	<t>The various error responses defined in this framework may leak
	information to an adversary.  For example errors responses for requests
	to the Authorization Information endpoint can reveal information about
	an otherwise opaque access token to an adversary who has intercepted
	this token.  This framework is written under the assumption that,
	in general, the benefits of detailed error messages outweigh the risk
	due to information leakage. For particular use cases, where this
	assessment does not apply, detailed error messages can be replaced by
	more generic ones.</t>
      </section>
</section>

<section anchor="privacy" title="Privacy Considerations">
      <t>Implementers and users should be aware of the privacy implications
      of the different possible deployments of this framework.</t>

      <t>The AS is in a very central position and can potentially learn sensitive
      information about the clients requesting access tokens.  If the client
      credentials grant is used, the AS can track what kind of access
      the client intends to perform.  With other grants this can be prevented
      by the Resource Owner.  To do so, the resource owner needs to bind the
      grants it issues to anonymous, ephemeral credentials that do not allow
      the AS to link different grants and thus different access token requests
      by the same client.</t>

      <t>If access tokens are only integrity protected and not encrypted, they
      may reveal information to attackers listening on the wire, or able to
      acquire the access tokens in some other way.  In the case of CWTs
      the token may e.g., reveal the audience, the scope and the confirmation
      method used by the client.  The latter may reveal the identity of the
      device or application running the client.  This may be linkable to
      the identity of the person using the client (if there is a person and
      not a machine-to-machine interaction).</t>

      <t>Clients using asymmetric keys for proof-of-possession should be aware
      of the consequences of using the same key pair for proof-of-possession
      towards different RSs.  A set of colluding RSs or an attacker able to
      obtain the access tokens will be able to link the requests, or even
      to determine the client's identity.</t>

      <t>An unprotected response to an unauthorized request (c.f.
      <xref target="asInfo"/>) may disclose information about RS and/or its
      existing relationship with C. It is advisable to include as little
      information as possible in an unencrypted response. Means of encrypting
      communication between C and RS already exist, more detailed information
      may be included with an error response to provide C with sufficient
      information to react on that particular error.</t>

</section>

<section anchor="iana" title="IANA Considerations">
      <t>This specification registers new parameters for OAuth and establishes registries for mappings to CBOR.</t>

      <section anchor="IANAOAuthIntrospectionResponseParameterRegistrationn" title="OAuth Introspection Response Parameter Registration">
      <t>This specification registers the following parameters in the OAuth introspection response parameters</t>
      <t>
        <?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Name: <spanx style="verb">cnf</spanx></t>
          <t>Description: Key to prove the right to use an access token,
	  formatted as specified in <xref
	  target="I-D.jones-ace-cwt-proof-of-possession"/>. </t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): this document</t>
        </list>
      </t>
      <t>
        <?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Name: <spanx style="verb">profile</spanx></t>
          <t>Description: The communication and communication security
   profile used between client and RS, as defined in ACE profiles.</t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): this document</t>
        </list>
      </t>
      <t>
	<?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Name: <spanx style="verb">client_token</spanx></t>
          <t>Description: Information that the RS MUST pass to the client
	  e.g., about the proof-of-possession keys.</t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): this document</t>
	</list>
      </t>
     <t>
	<?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Name: <spanx style="verb">rs_cnf</spanx></t>
          <t>Description: Describes the public key the RS uses to
	  authenticate.</t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): this document</t>
	</list>
      </t>
      </section>

      <section anchor="IANAOAuthParameterRegistration" title="OAuth Parameter Registration">
      <t>This specification registers the following parameters in the OAuth
      Parameters Registry</t>
      <t>
        <?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Parameter name: <spanx style="verb">profile</spanx></t>
          <t>Parameter usage location: token request, and token response</t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): this document</t>
        </list>
      </t>
      <t>
        <?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Name: <spanx style="verb">cnf</spanx></t>
          <t>Description: Key to prove the right to use an access token,
	  formatted as defined in <xref
	  target="I-D.jones-ace-cwt-proof-of-possession"/>. </t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): this document</t>
        </list>
      </t>
      </section>

      <section anchor="IANAOAuthTokenType" title="OAuth Access Token Types">
	<t>This specification registers the following new token type in the
	OAuth Access Token Types Registry</t>
	<t>
          <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Name: <spanx style="verb">PoP</spanx></t>
            <t>Description: A proof-of-possession token.</t>
	    <t>Change Controller: IESG</t>
            <t>Specification Document(s): this document</t>
          </list>
	</t>
      </section>

      <section anchor="IANATokenTypeMappings" title="OAuth Token Type
						     CBOR Mappings">
        <t>A new registry will be requested from IANA, entitled "Token Type Mappings".  The registry is to be created as Expert Review Required.</t>

        <section anchor="IANATokenTypeMappingsTemplate" title="Registration Template">
          <t>
            <list style='hanging'>
              <t hangText='Token Type:'>
                <vspace/>
                Name of token type as registered in the OAuth token type registry e.g., "Bearer".
              </t>
              <t hangText='Mapped value:'>
                <vspace/>
                Integer representation for the token type value.  The key value
		MUST be an integer. Integer values from -65536 to 65535 are
		designated as Specification Required.  Integer values of
		greater than 65535 designated as expert review.  Integer values
		less than -65536 are marked as private use. 
              </t>
              <t hangText='Change Controller:'>
                <vspace/>
                For Standards Track RFCs, list the "IESG". For others, give the name of the responsible party. Other details (e.g., postal address, email address, home page URI) may also be included.
              </t>
              <t hangText='Specification Document(s):'>
                <vspace/>
                Reference to the document or documents that specify the parameter,preferably including URIs that can be used to retrieve copies of the documents. An indication of the relevant sections may also be included but is not required.
              </t>
            </list>
          </t>
        </section>
        <section anchor="IANATokenTypeMappingsInitial" title="Initial Registry Contents">
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">Bearer</spanx></t>
              <t>Mapped value: 1</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">pop</spanx></t>
              <t>Mapped value: 2</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
        </section>
      </section>

      <section anchor="IANACWTClaims" title="CBOR Web Token Claims">
	<t>This specification registers the following new claims in the CBOR
	Web Token (CWT) registry:</t>
	<t>
	  <?rfc subcompact="yes"?>
          <list style='symbols'>
            <t>Claim Name: <spanx style="verb">scope</spanx></t>
            <t>Claim Description: The scope of an access token as
	    defined in <xref target="RFC6749"/>.</t>
            <t>Change Controller: IESG</t>
            <t>Specification Document(s): this document</t>
          </list>
	</t>
      </section>

      <section anchor="IANATokenEndpointCBORMappingsRegistry"
	       title="ACE OAuth Profile Registry">
        <t>A new registry will be requested from IANA, entitled "ACE Profile Registry".  The registry is to be created as Expert Review Required.</t>

        <section anchor="IANATokenEndpointCBORMappingsRegistryTemplate" title="Registration Template">
          <t>
            <list style='hanging'>
              <t hangText='Profile name:'>
                <vspace/>
                Name of the profile to be included in the profile attribute.
              </t>
              <t hangText='Profile description:'>
                <vspace/>
                Text giving an overview of the profile and the context it is developed for.
              </t>
              <t hangText='Profile ID:'>
                <vspace/>
                Integer value to identify the profile. Integer values from
		-65536 to 65535 are designated as Specification Required.
		Integer values of greater than 65535 designated as expert
		review.  Integer values	less than -65536 are marked as private
		use.</t>
              <t hangText='Change Controller:'>
                <vspace/>
                For Standards Track RFCs, list the "IESG". For others, give the name of the responsible party. Other details (e.g., postal address, email address, home page URI) may also be included.
              </t>
              <t hangText='Specification Document(s):'>
                <vspace/>
                Reference to the document or documents that specify the parameter,preferably including URIs that can be used to retrieve copies of the documents. An indication of the relevant sections may also be included but is not required.
              </t>
            </list>
          </t>
        </section>
      </section>

      <section anchor="IANAOAuthParameterMappingsRegistry"
	       title="OAuth CBOR Parameter Mappings Registry">
        <t>A new registry will be requested from IANA, entitled "Token Endpoint CBOR Mappings Registry".  The registry is to be created as Expert Review Required.</t>

        <section anchor="IANAOAuthParameterMappingsRegistryTemplate" title="Registration Template">
          <t>
            <list style='hanging'>
              <t hangText='Parameter name:'>
                <vspace/>
                OAuth Parameter name, refers to the name in the OAuth parameter registry e.g., "client_id".
              </t>
              <t hangText='CBOR key value:'>
                <vspace/>
                Key value for the claim.  The key value MUST be an integer.
		Integer values from -65536 to 65535 are designated as
		Specification Required.  Integer values of greater than 65535
		designated as expert review.  Integer values less than
		-65536 are marked as private use.</t>
              <t hangText='Change Controller:'>
                <vspace/>
                For Standards Track RFCs, list the "IESG". For others, give the name of the responsible party. Other details (e.g., postal address, email address, home page URI) may also be included.
              </t>
              <t hangText='Specification Document(s):'>
                <vspace/>
                Reference to the document or documents that specify the parameter,preferably including URIs that can be used to retrieve copies of the documents. An indication of the relevant sections may also be included but is not required.
              </t>
            </list>
          </t>
        </section>

        <section anchor="IANATokenEndpointCBORMappingsRegistryInitial"
		 title="Initial Registry Contents">
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">aud</spanx></t>
              <t>CBOR key value: 3</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">client_id</spanx></t>
              <t>CBOR key value: 8</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">client_secret</spanx></t>
              <t>CBOR key value: 9</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">response_type</spanx></t>
              <t>CBOR key value: 10</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">redirect_uri</spanx></t>
              <t>CBOR key value: 11</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">scope</spanx></t>
              <t>CBOR key value: 12</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">state</spanx></t>
              <t>CBOR key value: 13</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">code</spanx></t>
              <t>CBOR key value: 14</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">error</spanx></t>
              <t>CBOR key value: 15</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">error_description</spanx></t>
              <t>CBOR key value: 16</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">error_uri</spanx></t>
              <t>CBOR key value: 17</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">grant_type</spanx></t>
              <t>CBOR key value: 18</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">access_token</spanx></t>
              <t>CBOR key value: 19</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">token_type</spanx></t>
              <t>CBOR key value: 20</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">expires_in</spanx></t>
              <t>CBOR key value: 21</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">username</spanx></t>
              <t>CBOR key value: 22</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">password</spanx></t>
              <t>CBOR key value: 23</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">refresh_token</spanx></t>
              <t>CBOR key value: 24</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">cnf</spanx></t>
              <t>CBOR key value: 25</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">profile</spanx></t>
              <t>CBOR key value: 26</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>

        </section>
      </section>

      <section anchor="IANAIntrospectionEndpointCBORMappingsRegistry" title="Introspection Endpoint CBOR Mappings Registry">
        <t>A new registry will be requested from IANA, entitled "Introspection
	Endpoint CBOR Mappings Registry".  The registry is to be created as
	Expert Review Required.</t>

        <section anchor="IANAIntrospectionEndpointCBORMappingsRegistryTemplate" title="Registration Template">
          <t>
            <list style='hanging'>
              <t hangText='Response parameter name:'>
                <vspace/>
                Name of the response parameter as defined in the "OAuth Token Introspection Response" registry e.g., "active".
              </t>
              <t hangText='CBOR key value:'>
                <vspace/>
                Key value for the claim.  The key value MUST be an integer.
		Integer values from -65536 to 65535 are designated as
		Specification Required.  Integer values of greater than 65535
		designated as expert review.  Integer values less than
		-65536 are marked as private use.</t>
              <t hangText='Change Controller:'>
                <vspace/>
                For Standards Track RFCs, list the "IESG". For others, give the name of the responsible party. Other details (e.g., postal address, email address, home page URI) may also be included.
              </t>
              <t hangText='Specification Document(s):'>
                <vspace/>
                Reference to the document or documents that specify the parameter,preferably including URIs that can be used to retrieve copies of the documents. An indication of the relevant sections may also be included but is not required.
              </t>
            </list>
          </t>
        </section>

        <section anchor="IANAIntrospectionEndpointCBORMappingsRegistryInitial"
		 title="Initial Registry Contents">
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">iss</spanx></t>
              <t>CBOR key value: 1</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
         <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">sub</spanx></t>
              <t>CBOR key value: 2</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">aud</spanx></t>
              <t>CBOR key value: 3</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">exp</spanx></t>
              <t>CBOR key value: 4</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">nbf</spanx></t>
              <t>CBOR key value: 5</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">iat</spanx></t>
              <t>CBOR key value: 6</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">cti</spanx></t>
              <t>CBOR key value: 7</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">client_id</spanx></t>
              <t>CBOR key value: 8</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">scope</spanx></t>
              <t>CBOR key value: 12</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">token_type</spanx></t>
              <t>CBOR key value: 20</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">username</spanx></t>
              <t>CBOR key value: 22</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">cnf</spanx></t>
              <t>CBOR key value: 25</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Parameter name: <spanx style="verb">profile</spanx></t>
              <t>CBOR key value: 26</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">token</spanx></t>
              <t>CBOR key value: 27</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
	  <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">token_type_hint</spanx></t>
              <t>CBOR key value: 28</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">active</spanx></t>
              <t>CBOR key value: 29</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">client_token</spanx></t>
              <t>CBOR key value: 30</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Response parameter name: <spanx style="verb">rs_cnf</spanx></t>
              <t>CBOR key value: 31</t>
              <t>Change Controller: IESG</t>
              <t>Specification Document(s): this document</t>
            </list>
          </t>
        </section>
      </section>
      <section anchor="CoAPOptionNumberRegistration" title="CoAP Option Number Registration">
      	<t>
      	  This section registers the "Access-Token" CoAP Option Number
	  in the "CoRE Parameters" sub-registry "CoAP Option Numbers" in
	  the manner described in <xref target="RFC7252"/>.
      	</t>
        <t>
          <list style="hanging">
            <t hangText="Name"><vspace blankLines="1"/>
              Access-Token
           </t>
            <t hangText="Number"><vspace blankLines="1"/>
              TBD
            </t>
            <t hangText="Reference"><vspace blankLines="1"/>
              [This document].
            </t>
            <t hangText="Meaning in Request"><vspace blankLines="1"/>
              Contains an Access Token according to [This document]
              containing access permissions of the client.
            </t>
            <t hangText="Meaning in Response"><vspace blankLines="1"/>
              Not used in response
            </t>
            <t hangText="Safe-to-Forward"><vspace blankLines="1"/>
              Yes
            </t>
            <t hangText="Format"><vspace blankLines="1"/>
              Based on the observer the format is perceived differently.
              Opaque data to the client and CWT or reference token to the RS.
            </t>
            <t hangText="Length"><vspace blankLines="1"/>
              Less then 255 bytes
            </t>
          </list>
        </t>
      </section>
    </section>

    <section anchor="Acknowledgments" title="Acknowledgments">
        <t>This document is a product of the ACE working group of the IETF.</t>

        <t>Thanks to Eve Maler for her contributions to the use of
        OAuth 2.0 and UMA in IoT scenarios, Robert Taylor for his discussion
        input, and Malisa Vucinic for his input on the predecessors of this
	proposal.</t>

	<t>Thanks to the authors of draft-ietf-oauth-pop-key-distribution, from where
    large parts of the security considerations where copied.</t>

	<t>Thanks to Stefanie Gerdes, Olaf Bergmann, and Carsten
	Bormann for contributing their work on AS discovery from
	draft-gerdes-ace-dcaf-authorize (see <xref target="asDiscovery"/>).</t>

	<t>Ludwig Seitz and Goeran Selander worked on this document as part of
	the CelticPlus project CyberWI, with funding from Vinnova.</t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      <!--?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?-->
      &RFC8152;
      
      &I-D.ietf-ace-cbor-web-token;

      &I-D.jones-ace-cwt-proof-of-possession;

      &RFC7662;

      &RFC2119;

      &RFC6347;

      &RFC7252;

      &RFC3986;

    </references>

    <references title="Informative References">
      <!-- &I-D.ietf-ace-usecases;
      &RFC7250;

-->
      &I-D.ietf-ace-actors;

      &I-D.ietf-core-object-security;

      &I-D.erdtman-ace-rpcc;

      &RFC7959;

      &RFC4949;

      &RFC5246;

      &RFC6690;

      &RFC6749;

      &RFC6819;

      &RFC7049;

      &RFC7159;

      &RFC7228;

      &RFC7231;

      &RFC7519;

      &RFC7591;

      &RFC7744;

      &RFC7521;

      &RFC7641;

      &I-D.ietf-oauth-device-flow;

      &I-D.ietf-oauth-native-apps;

      &I-D.ietf-core-resource-directory;
      
      &I-D.ietf-oauth-discovery;      

      <reference anchor="Margi10impact">
        <front>
          <title>Impact of Operating Systems on Wireless Sensor Networks
	  (Security) Applications and Testbeds</title>
            <author initials="C. B." surname="Margi"/>
            <author initials="B.T." surname="de Oliveira"/>
	    <author initials="G.T." surname="de Sousa"/>
	    <author initials="M.A." surname="Simplicio Jr"/>
	    <author initials="P.S.L.M." surname="Barreto"/>
	    <author initials="T.C.M.B." surname="Carvalho"/>
	    <author initials="M." surname="Naeslund"/>
	    <author initials="R." surname="Gold"/>
            <date month="2010" year="August" />
        </front>
        <seriesInfo name="Proceedings of the" value="19th International Conference on Computer Communications and Networks (ICCCN)"/>
      </reference>
      
      

    </references>

    <section title="Design Justification" anchor="constraints">     
     <t>This section provides further insight into the design decisions
     of the solution documented in this document.  <xref target="overview"/>
     lists several building blocks and briefly summarizes their importance.
     The justification for offering some of those building blocks, as opposed
     to using OAuth 2.0 as is, is given below.</t>

     <t>Common IoT constraints are:

        <list style="hanging">

          <t hangText="Low Power Radio:"><vspace blankLines="1"/>
          Many IoT devices are equipped with a small battery which needs
          to last for a long time.  For many constrained wireless devices, the
          highest energy cost is associated to transmitting or receiving
          messages (roughly by a factor of 10 compared to e.g. AES)
	  <xref target="Margi10impact"/>.  It is therefore important to keep
	  the total communication overhead low, including minimizing the number
	  and size of messages sent and received, which has an impact of choice
	  on the message format and protocol.  By using CoAP over UDP and CBOR
	  encoded messages, some of these aspects are addressed.  Security
	  protocols contribute to the communication overhead and can, in some
	  cases, be optimized.  For example, authentication and key
	  establishment may, in certain cases where security requirements
	  allow, be replaced by provisioning of security context by a trusted
	  third party, using transport or application layer security.
	  <vspace blankLines="0"/>
          </t>

          <t hangText="Low CPU Speed:"><vspace blankLines="1"/>
          Some IoT devices are equipped with processors that are significantly
          slower than those found in most current devices on the Internet.
          This typically has implications on what timely cryptographic
          operations a device is capable of performing, which in turn impacts
          e.g., protocol latency.  Symmetric key cryptography may be used
          instead of the computationally more expensive public key cryptography
          where the security requirements so allows, but this may also require
          support for trusted third party assisted secret key establishment
          using transport or application layer security.
	  <vspace blankLines="0"/></t>

          <t hangText="Small Amount of Memory:"> <vspace blankLines="1"/>
          Microcontrollers embedded in IoT devices are often equipped with
          small amount of RAM and flash memory, which places limitations what
          kind of processing can be performed and how much code can be put on
          those devices.  To reduce code size fewer and smaller protocol
          implementations can be put on the firmware of such a device.  In
          this case, CoAP may be used instead of HTTP,  symmetric key
          cryptography instead of public key cryptography, and CBOR instead of
          JSON.  Authentication and key establishment protocol, e.g., the DTLS
          handshake,  in comparison with assisted key establishment also has
          an impact on memory and code.<vspace blankLines="0"/>
          </t>

          <t hangText="User Interface Limitations:"> <vspace blankLines="1"/>
          Protecting access to resources is both an important security as well
          as privacy feature.  End users and enterprise customers may not want
          to give access to the data collected by their IoT device or to
          functions it may offer to third parties.  Since the classical
          approach of requesting permissions from end users via a rich user
          interface does not work in many IoT deployment scenarios, these
          functions need to be delegated to user-controlled devices that are
          better suitable for such tasks, such as smart phones and tablets.
	  <vspace blankLines="1"/></t>

          <t hangText="Communication Constraints:"> <vspace blankLines="1"/>
          In certain constrained settings an IoT device may not be able to
          communicate with a given device at all times.  Devices may be
          sleeping, or just disconnected from the Internet because of general
          lack of connectivity in the area, for cost reasons, or for security
          reasons, e.g., to avoid an entry point for Denial-of-Service attacks.

          <vspace blankLines="1"/>
          The communication interactions this framework builds upon (as shown
          graphically in <xref target="fig:protocolFlow"/>) may be accomplished
          using a variety of different protocols, and not all parts of the
          message flow are used in all applications due to the communication
          constraints.  Deployments making use of CoAP are expected, but not
          limited to, other protocols such as HTTP, HTTP/2 or other specific
          protocols, such as Bluetooth Smart communication, that do not
          necessarily use IP could also be used.  The latter raises the need
          for application layer security over the various interfaces.</t>
        </list>
      </t>

      <t>In the light of these constraints we have made the following design
      decisions:

        <list style="hanging">

          <t hangText="CBOR, COSE, CWT:"><vspace blankLines="1"/>
	  This framework REQUIRES the use of CBOR <xref target="RFC7049"/> as
	  data format.  Where CBOR data needs to be protected, the use of COSE
	  <xref target="RFC8152"/> is RECOMMENDED.  Furthermore where
	  self-contained tokens are needed, this framework RECOMMENDS the
	  use of CWT <xref target="I-D.ietf-ace-cbor-web-token"/>.  These
	  measures aim at reducing the size of messages sent over the wire,
	  the RAM size of data objects that need to be kept in memory and
	  the size of libraries that devices need to support.
	  <vspace blankLines="1"/></t>

	  <t hangText="CoAP:"><vspace blankLines="1"/>
	  This framework RECOMMENDS the use of CoAP <xref target="RFC7252"/>
	  instead of HTTP.  This does not preclude the use of other protocols
	  specifically aimed at constrained devices, like e.g. Bluetooth Low
	  energy (see <xref target="coap"/>).  This aims again at reducing the
	  size of messages sent over the wire, the RAM size of data objects
	  that need to be kept in memory and the size of libraries that devices
	  need to support.
	  <vspace blankLines="1"/></t>
	  
	  <t hangText="RS Information:"><vspace blankLines="1"/>
	  This framework defines the name "RS Information" for data concerning
	  the RS that the AS returns to the client in an access token response
	  (see  <xref target="tokenResponse"/>).  This includes the "profile"
	  and the "rs_cnf" parameters.  This aims at enabling scenarios,
	  where a powerful client, supporting multiple profiles, needs to
	  interact with a RS for which it does not know the supported profiles
	  and the raw public key.
	  <vspace blankLines="1"/></t>	  
	  
	  <t hangText="Proof-of-Possession:"><vspace blankLines="1"/>
	  This framework makes use of proof-of-possession tokens, using
	  the "cnf" claim
	  <xref target="I-D.jones-ace-cwt-proof-of-possession"/>. A
	  semantically and syntactically identical request and response
	  parameter is defined for the token endpoint, to allow requesting
	  and stating confirmation keys.  This aims at making token theft
	  harder. Token theft is specifically relevant in constrained use cases,
	  as communication often passes through middle-boxes, which could
	  be able to steal bearer tokens and use them to gain unauthorized
	  access.
	  <vspace blankLines="1"/> </t>

	  <t hangText="Auth-Info endpoint:"><vspace blankLines="1"/>
	  This framework introduces a new way of providing access tokens
	  to a RS by exposing a authz-info endpoint, to which access tokens
	  can be POSTed.  This aims at reducing the size of the request
	  message and the code complexity at the RS.  The size of the request
	  message is problematic, since many constrained protocols have severe
	  message size limitations at the physical layer (e.g. in the order of
	  100 bytes). This means that larger packets get fragmented, which in
	  turn combines badly with the high rate of packet loss, and the
	  need to retransmit the whole message if one packet gets lost.
	  Thus separating sending of the request and sending of the access
	  tokens helps to reduce fragmentation.
	  <vspace blankLines="1"/></t>
	  
	  <t hangText="Client Credentials Grant:"><vspace blankLines="1"/>
	  This framework RECOMMENDS the use of the client credentials grant
	  for machine-to-machine communication use cases, where manual
	  intervention of the resource owner to produce a grant token is not
	  feasible.  The intention is that the resource owner would instead
	  pre-arrange authorization with the AS, based on the client's own
	  credentials.  The client can the (without manual intervention) obtain
	  access tokens from the AS.
	  <vspace blankLines="1"/></t>

	  <t hangText="Introspection:"><vspace blankLines="1"/>
	  This framework RECOMMENDS the use of access token introspection
	  in cases where the client is constrained in a way that it can not
	  easily obtain new access tokens (i.e. it has connectivity issues
	  that prevent it from communicating with the AS). In that case
	  this framework RECOMMENDS the use of a long-term token, that could
	  be a simple reference.  The RS is assumed to be able to communicate
	  with the AS, and can therefore perform introspection, in order to
	  learn the claims associated with the token reference.  The advantage
	  of such an approach is that the resource owner can change the claims
	  associated to the token reference without having to be in contact
	  with the client, thus granting or revoking access rights.
	  <vspace blankLines="1"/></t>

	  <t hangText="Client Token:"><vspace blankLines="1"/>
	  In cases where the client is constrained and does not have
	  connectivity to the AS, and furthermore does not have a previous
	  security relation to the RS that it needs to communicate with,
	  this framework proposes the use of "client tokens".  A client
	  token is a data object obtained from the AS by the RS, during access
	  token introspection.  The RS passes the client token on to the client.
	  It contains information that allows the client to perform the
	  proof of possession for its access token and to authenticate the RS
	  (e.g. with it's public key).
	  </t>	  
	</list>
      </t>
      
    </section>

    <section anchor="app:rolesAndResponsibilities" title="Roles and Responsibilities">
      <t><list style="hanging">
	<t hangText="Resource Owner">
	  <list style="symbols">
	    <t>Make sure that the RS is registered at the AS.  This includes
	    making known to the AS which profiles, token_types, scopes, and
	    key types (symmetric/asymmetric) the RS supports. Also making
	    it known to the AS which audience(s) the RS identifies itself
	    with.</t>
	    <t>Make sure that clients can discover the AS that is in charge
	    of the RS.</t>
	    <t>If the client-credentials grant is used, make sure that the AS
	    has the necessary, up-to-date, access control policies for the
	    RS.</t>
	  </list>
	  <vspace blankLines="0"/>
	</t>
	<t hangText="Requesting Party">
	  <list style="symbols">
	    <t>Make sure that the client is provisioned the necessary
	    credentials to authenticate to the AS.</t>
	    <t>Make sure that the client is configured to follow the security
	    requirements of the Requesting Party when issuing requests
	    (e.g., minimum communication security requirements, trust
	    anchors).</t>
	    <t>Register the client at the AS.  This includes making known to
	    the AS which profiles, token_types, and key types
	    (symmetric/asymmetric) the client.</t>
          </list>
	  <vspace blankLines="0"/>
        </t>
	<t hangText="Authorization Server">
	  <list style="symbols">
	    <t>Register the RS and manage corresponding security contexts.</t>
            <t>Register clients and authentication credentials.</t>
	    <t>Allow Resource Owners to configure and update access control
	    policies related to their registered RSs.</t>
	    <t>Expose the token endpoint to allow  clients to request
	    tokens.</t>
            <t>Authenticate clients that wish to request a token.</t>
	    <t>Process a token request using the authorization
	    policies configured for the RS.</t>
	    <t>Optionally:  Expose the introspection endpoint that allows
	    RS's to submit token introspection requests.</t>
	    <t>If providing an introspection endpoint: Authenticate RSs that
	    wish to get an introspection response.</t>
	    <t>If providing an introspection endpoint: Process token
	    introspection requests.</t>
	    <t>Optionally: Handle token revocation.</t>
	    <t>Optionally: Provide discovery metadta. See <xref
	    target="I-D.ietf-oauth-discovery"/></t>
          </list><vspace blankLines="0"/>
	</t>
        <t hangText="Client">
	  <list style="symbols">
	    <t>Discover the AS in charge of the RS that is to be targeted with
	    a request.</t>
            <t>Submit the token request (see step (A) of
	    <xref target="fig:protocolFlow"/>).
	      <list style="symbols">
		<t>Authenticate to the AS.</t>
		<t>Optionally (if not pre-configured): Specify which RS, which
		resource(s), and which action(s) the request(s) will
		target.</t>
		<t>If raw public keys (rpk) or certificates are used, make sure
		the AS has the right rpk or certificate for this client.</t>
	      </list>
	    </t>
	    <t>Process the access token and RS Information (see step (B)
	    of <xref target="fig:protocolFlow"/>).
	       <list style="symbols">
		<t>Check that the RS Information provides the necessary
		security parameters (e.g., PoP key, information on
		communication security protocols supported by the RS).</t>
	      </list>
	    </t>
	    <t>Send the token and request to the RS (see step (C) of
	    <xref target="fig:protocolFlow"/>).
	      <list style="symbols">
		<t>Authenticate towards the RS (this could coincide with the
		proof of possession process).</t>
		<t>Transmit the token as specified by the AS (default is to the
		authz-info endpoint, alternative options are specified by
		profiles).</t>
		<t>Perform the proof-of-possession procedure as specified by
		the profile in use (this may already have been taken care
		of through the authentication procedure).</t>
	      </list>
	    </t>
	    <t>Process the RS response (see step (F) of
	    <xref target="fig:protocolFlow"/>) of the RS.</t>
          </list><vspace blankLines="0"/>
	</t>
	<t hangText="Resource Server">
	  <list style="symbols">
	    <t>Expose a way to submit access tokens. By default this is
	    the authz-info endpoint.</t>
            <t>Process an access token.
	      <list style="symbols">
		<t>Verify the token is from a recognized AS.</t>
		<t>Verify that the token applies to this RS.</t>
		<t>Check that the token has not expired (if the token provides
		expiration information).</t>
		<t>Check the token's integrity.</t>
		<t>Store the token so that it can be retrieved in the context
		of a matching request.</t>
	      </list>
	    </t>
	    <t>Process a request.
	     <list style="symbols">
	        <t>Set up communication security with the client.</t>
		<t>Authenticate the client.</t>
		<t>Match the client against existing tokens.</t>
		<t>Check that tokens belonging to the client actually
		authorize the requested action.</t>
		<t>Optionally: Check that the matching tokens are still valid,
		using introspection (if this is possible.)</t>
	      </list>
	    </t>
	    <t>Send a response following the agreed upon communication
	    security.</t>
          </list>
	</t>
      </list></t>
    </section>

<!-- ***************************************************** -->
<section anchor="app:profileRequirements" title="Requirements on Profiles">
  <t>This section lists the requirements on profiles of this framework,
  for the convenience of profile designers.

  <list style="symbols">
    <t>Specify the communication protocol the client and RS the must use
    (e.g., CoAP). <xref target="oauthProfile"/> and <xref
    target="paramProfile"/></t>

    <t>Specify the security protocol the client and RS must use to protect
    their communication (e.g., OSCOAP or DTLS over CoAP).  This must provide
    encryption, integrity and replay protection. <xref
    target="paramProfile"/></t>

    <t>Specify how the client and the RS mutually authenticate. <xref
    target="specs"/></t>

    <t>Specify the Content-format of the protocol messages
    (e.g., "application/cbor" or "application/cose+cbor"). <xref
    target="specs"/></t>

    <t>Specify the proof-of-possession protocol(s) and how to select one,
    if several are available.  Also specify which key types
    (e.g., symmetric/asymmetric) are supported by a specific proof-of-possession
    protocol. <xref target="paramTokenType"/></t>

    <t>Specify a unique profile identifier. <xref target="paramProfile"/></t>

    <t>If introspection is supported: Specify the communication and security
    protocol for introspection.<xref target="introspectionEndpoint"/></t>

    <t>Specify the communication and security protocol for interactions between
    client and AS. <xref target="tokenEndpoint"/></t>

    <t>Specify how/if the authz-info endpoint is protected. <xref
    target="tokenAuthInfoEndpoint"/></t>

    <t>Optionally define other methods of token transport than the authz-info
    endpoint. <xref target="tokenAuthInfoEndpoint"/></t>

  </list>

  </t>


</section>

<section anchor="app:registration"
	 title="Assumptions on AS knowledge about C and RS">

 <t>This section lists the assumptions on what an AS should know about a
 client and a RS in order to be able to respond to requests to the token
 and introspection endpoints.  How this information is established is out of
 scope for this document.

  <list style="symbols">
    <t>The identifier of the client or RS.</t>
    <t>The profiles that the client or RS supports.</t>
    <t>The scopes that the RS supports.</t>
    <t>The audiences that the RS identifies with.</t>
    <t>The key types (e.g., pre-shared symmetric key, raw public key,
    key length, other key parameters) that the client or RS supports.</t>
    <t>The types of access tokens the RS supports (e.g., CWT).</t>
    <t>If the RS supports CWTs, the COSE parameters for the crypto wrapper
    (e.g., algorithm, key-wrap algorithm, key-length).</t>
    <t>The expiration time for access tokens issued to this RS
    (unless the RS accepts a default time chosen by the AS).</t>
    <t>The symmetric key shared between client or RS and AS (if any).</t>
    <t>The raw public key of the client or RS (if any).</t>
  </list>
 </t>
</section>

<!-- ***************************************************** -->
      <section anchor="options" title="Deployment Examples">
        <t>There is a large variety of IoT deployments, as is indicated in
        <xref target="constraints"/>, and this section highlights a few common
        variants.  This section is not normative but illustrates how the
        framework can be applied.
        </t>

        <t>For each of the deployment variants, there are a number of possible
        security setups between clients, resource servers and authorization
        servers.  The main focus in the following subsections is on how
        authorization of a client request for a resource hosted by a RS is
        performed.  This requires the security of the requests and
        responses between the clients and the RS to consider.
        </t>

        <t>Note: CBOR diagnostic notation is used for examples of requests
          and responses.</t>

<!-- ************************** -->


 <!-- ************************** -->
<section anchor="localTokenValidation" title="Local Token Validation">
  <t>In this scenario, the case where the resource server is offline is considered,
i.e., it is not connected to the AS at the time of the access request.
This access procedure involves steps A, B, C, and F of <xref target="fig:protocolFlow"/>.
  </t>

  <t>Since the resource server must be able to verify the access token locally,
  self-contained access tokens must be used.</t>

    <t>This example shows the interactions between a client, the
    authorization server and a temperature sensor acting as a resource server.  Message
    exchanges A and B are shown in <xref target="fig:RSOffline"/>.</t>

    <t><list style="hanging">
      <t>A: The client first generates a public-private key pair used for
      communication security with the RS.</t>

      <t>The client sends the POST request to the token endpoint at the AS.  The security
        of this request can be transport or application layer. It is up the
        the communication security profile to define. In the example transport
        layer identification of the AS is done and the client identifies with
        client_id and client_secret as in classic OAuth.  The request
      contains the public key of the client and the Audience parameter set to
      "tempSensorInLivingRoom", a value that the temperature sensor
      identifies itself with.  The AS evaluates the request and authorizes the
      client to access the resource.</t>

      <t>B: The AS responds with a PoP access token and RS Information.  The PoP
      access token contains the public key of the client, and the RS Information
      contains the public key of the RS.  For communication security
      this example uses DTLS RawPublicKey between the client and the RS. The issued
      token will have a short validity time, i.e., "exp" close to "iat",
      to protect the RS from replay attacks. The token includes
      the claim such as "scope" with the authorized access that an owner of the
      temperature device can enjoy.  In this example, the "scope" claim, issued
      by the AS, informs the RS that the owner of the token, that can prove
      the possession of a key is authorized to make a GET request
      against the /temperature resource and a POST request on the /firmware
      resource.  Note that the syntax and semantics of the scope claim
      are application specific.</t>

      <t>Note: In this example it is assumed that the client knows what resource it
      wants to access, and is therefore able to request specific
      audience and scope claims for the access token.</t>
    </list></t>

    <t><figure align="center" anchor="fig:RSOffline"
               title="Token Request and Response Using Client Credentials.">
        <artwork align="left"><![CDATA[
         Authorization
  Client    Server
    |         |
    |<=======>| DTLS Connection Establishment
    |         |   to identify the AS
    |         |
A:  +-------->| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"token"
    |         | Content-Type: application/cbor
    |         | Payload: <Request-Payload>
    |         |
B:  |<--------+ Header: 2.05 Content
    |  2.05   | Content-Type: application/cbor
    |         | Payload: <Response-Payload>
    |         |
        ]]></artwork>
    </figure></t>

    <t>The information contained in the Request-Payload and the
    Response-Payload is shown in <xref target="fig:RSOfflineReq"/>.
    Note that a transport layer security based communication security profile is used in this
    example, therefore the Content-Type is "application/cbor".

     <figure align="center" anchor="fig:RSOfflineReq"
             title="Request and Response Payload Details.">
      <artwork align="left"><![CDATA[
Request-Payload :
{
  "grant_type" : "client_credentials",
  "aud" : "tempSensorInLivingRoom",
  "client_id" : "myclient",
  "client_secret" : "qwerty"
}

Response-Payload :
{
  "access_token" : b64'SlAV32hkKG ...',
  "token_type" : "pop",
  "csp" : "DTLS",
  "rs_cnf" : {
    "COSE_Key" : {
      "kid" : b64'c29tZSBwdWJsaWMga2V5IGlk',
      "kty" : "EC",
      "crv" : "P-256",
      "x"   : b64'MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4',
      "y"   : b64'4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM'
    }
  }
}
        ]]></artwork>
    </figure></t>

    <t>The content of the access token is shown
    in  <xref target="fig:BothcborMappingValueAsymmetricCWT"/>.</t>

    <t><figure align="center"
               anchor="fig:BothcborMappingValueAsymmetricCWT"
               title="Access Token including Public Key of the Client.">
        <artwork align="left"><![CDATA[
{
  "aud" : "tempSensorInLivingRoom",
  "iat" : "1360189224",
  "exp" : "1360289224",
  "scope" :  "temperature_g firmware_p",
  "cnf" : {
    "COSE_Key" : {
      "kid" : b64'1Bg8vub9tLe1gHMzV76e8',
      "kty" : "EC",
      "crv" : "P-256",
      "x" : b64'f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU',
      "y" : b64'x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0'
    }
  }
}
        ]]></artwork>
    </figure></t>

    <t>Messages C and F are shown in
    <xref target="fig:RSOfflinePostAccessTokenAsymmetric"/> -
    <xref target="fig:RSOfflineDTLSRequestAndResponse"/>.

    <list style="hanging">
      <t>C: The client then sends the PoP access token to the authz-info endpoint at
      the RS.  This is a plain CoAP request, i.e., no transport or application
      layer security between client and RS, since the token is integrity protected
      between the AS and RS.  The RS verifies that the PoP access token was created by a
      known and trusted AS, is valid, and responds to the client.  The RS caches
      the security context together with authorization information about this client
      contained in the PoP access token.</t>

    <t><figure align="center" anchor="fig:RSOfflinePostAccessTokenAsymmetric"
               title="Access Token provisioning to RS">
      <artwork align="left"><![CDATA[
           Resource
 Client     Server
    |         |
C:  +-------->| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"authz-info"
    |         | Payload: SlAV32hkKG ...
    |         |
    |<--------+ Header: 2.04 Changed
    |  2.04   |
    |         |
]]></artwork>
    </figure></t>

      <t>The client and the RS runs the DTLS handshake using the raw
      public keys established in step B and C.</t>

      <t>The client sends the CoAP request GET to /temperature on RS over
      DTLS.  The RS verifies that the request is authorized, based on
      previously established security context.</t>

      <t>F: The RS responds with a resource representation over DTLS.</t>
    </list></t>

    <t><figure align="center" anchor="fig:RSOfflineDTLSRequestAndResponse"
               title="Resource Request and Response protected by DTLS.">
      <artwork align="left"><![CDATA[
           Resource
 Client     Server
    |         |
    |<=======>| DTLS Connection Establishment
    |         |   using Raw Public Keys
    |         |
    +-------->| Header: GET (Code=0.01)
    | GET     | Uri-Path: "temperature"
    |         |
    |         |
    |         |
F:  |<--------+ Header: 2.05 Content
    | 2.05    | Payload: <sensor value>
    |         |
      ]]></artwork>
    </figure></t>
</section>


 <!-- ************************** -->

<section anchor="introspectionAidedTokenValidation" title="Introspection Aided Token Validation">

  <t>In this deployment scenario it is assumed that a client is not able to
  access the AS at the time of the access request, whereas the RS is assumed
  to be connected to the back-end infrastructure. Thus the RS can make use of
  token introspection.  This access procedure involves steps A-F of
  <xref target="fig:protocolFlow"/>, but assumes steps A and B have been
  carried out during a phase when the client had connectivity to AS.
  </t>

  <t>Since the client is assumed to be offline, at least for a certain period of
  time, a pre-provisioned access token has to be long-lived.  Since the client
  is constrained, the token will not be self contained (i.e. not a CWT) but
  instead just a reference.  The resource server uses its connectivity to
  learn about the claims assoicated to the access token by using introspection,
  which is shown in the example below.</t>

    <t>In the example interactions between an offline client
    (key fob), a RS (online lock), and an AS is shown.  It is
    assumed that there is a provisioning step where the client has access to the
    AS.  This corresponds to message exchanges A and B which are shown in
    <xref target="fig:cOffline"/>.
    </t>
    <t>Authorization consent from the resource owner can be pre-configured,
    but it can also be provided via an interactive flow with the resource
    owner.  An example of this for the key fob case could be that the
    resource owner has a connected car, he buys a generic key that he
    wants to use with the car.  To authorize the key fob he connects it
    to his computer that then provides the UI for the device.  After
    that OAuth 2.0 implicit flow can used to authorize the key for
    his car at the the car manufacturers AS.</t>

      <t>Note: In this example the client does not know the exact door it
        will be used to access since the token request is not send at the
        time of access. So the scope and audience parameters are set quite
        wide to start with and new values different form the
        original once can be returned from introspection later on.</t>
            <t>
      <list style="hanging">
        <t>A: The client sends the request using POST to the token endpoint at AS.  The
        request contains the Audience parameter set to  "PACS1337" (PACS, Physical Access System), a
        value the that the online door in question identifies itself with.  The
        AS generates an access token as an opaque string, which it can match to
        the specific client, a targeted audience and a symmetric key. The
        security is provided by identifying the AS on transport layer using
        a pre shared security context (psk, rpk or certificate) and then the
        client is identified using client_id and client_secret as in classic OAuth.</t>

        <t>B: The AS responds with the an access token and RS Information,
        the latter containing a symmetric key.
        Communication security between C and RS will be DTLS and PreSharedKey.
        The PoP key is used as the PreSharedKey.
        </t>
      </list>
    </t>

    <t><figure align="center" anchor="fig:cOffline"
               title="Token Request and Response using Client Credentials.">
      <artwork align="left"><![CDATA[

         Authorization
 Client     Server
    |         |
    |         |
A:  +-------->| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"token"
    |         | Content-Type: application/cbor
    |         | Payload: <Request-Payload>
    |         |
B:  |<--------+ Header: 2.05 Content
    |         | Content-Type: application/cbor
    |  2.05   | Payload: <Response-Payload>
    |         |
    ]]></artwork>
    </figure></t>

    <t>The information contained in the Request-Payload and the
    Response-Payload is shown in <xref target="fig:cOfflineReq"/>.

     <figure align="center" anchor="fig:cOfflineReq"
             title="Request and Response Payload for C offline">
      <artwork align="left"><![CDATA[
Request-Payload:
{
  "grant_type" : "client_credentials",
  "aud" : "lockOfDoor4711",
  "client_id" : "keyfob",
  "client_secret" : "qwerty"
}

Response-Payload:
{
  "access_token" : b64'SlAV32hkKG ...'
  "token_type" : "pop",
  "csp" : "DTLS",
  "cnf" : {
    "COSE_Key" : {
      "kid" : b64'c29tZSBwdWJsaWMga2V5IGlk',
      "kty" : "oct",
      "alg" : "HS256",
      "k": b64'ZoRSOrFzN_FzUA5XKMYoVHyzff5oRJxl-IXRtztJ6uE'
    }
  }
}
      ]]></artwork>
    </figure></t>

    <t>The access token in this case is just an opaque string referencing
   the authorization information at the AS.</t>

    <t><list style="hanging">
        <t>C: Next, the client POSTs the access token to the authz-info
        endpoint in the RS.  This is a plain CoAP request, i.e., no
        DTLS between client and RS.  Since the token is an opaque string,
        the RS cannot verify it on its own, and thus defers to respond the
        client with a status code until after step E.</t>

        <t>D: The RS forwards the token to the introspection
        endpoint on the AS.  Introspection assumes a secure connection
        between the AS and the RS, e.g., using transport of application layer
        security. In the example AS is identified using pre shared security
        context (psk, rpk or certificate) while RS is acting as client and
        is identified with client_id and client_secret.
        </t>

        <t>E: The AS provides the introspection response containing parameters
  about the token.  This includes the confirmation key (cnf) parameter
        that allows the RS to verify the client's proof of possession in
  step F.</t>

        <t>After receiving message E, the RS responds to the client's POST in
        step C with the CoAP response code 2.01 (Created).</t>

        <t><figure align="center" anchor="fig:cOfflineIntrospection"
            title="Token Introspection for C offline">
            <artwork align="left"><![CDATA[
           Resource
  Client    Server
    |         |
C:  +-------->| Header: POST (T=CON, Code=0.02)
    |  POST   | Uri-Path:"authz-info"
    |         | Content-Type: "application/cbor"
    |         | Payload: b64'SlAV32hkKG ...''
    |         |
    |         |     Authorization
    |         |       Server
    |         |          |
    |      D: +--------->| Header: POST (Code=0.02)
    |         |  POST    | Uri-Path: "introspect"
    |         |          | Content-Type: "application/cbor"
    |         |          | Payload: <Request-Payload>
    |         |          |
    |      E: |<---------+ Header: 2.05 Content
    |         |  2.05    | Content-Type: "application/cbor"
    |         |          | Payload: <Response-Payload>
    |         |          |
    |         |
    |<--------+ Header: 2.01 Created
    |  2.01   |
    |         |
]]></artwork>
        </figure></t>

        <t>The information contained in the Request-Payload and the
        Response-Payload is shown in <xref target="fig:cOfflineIntroReq"/>.

        <figure align="center" anchor="fig:cOfflineIntroReq"
                title="Request and Response Payload for Introspection">
          <artwork align="left"><![CDATA[
Request-Payload:
{
  "token" : b64'SlAV32hkKG...',
  "client_id" : "FrontDoor",
  "client_secret" : "ytrewq"
}

Response-Payload:
{
  "active" : true,
  "aud" : "lockOfDoor4711",
  "scope" : "open, close",
  "iat" : 1311280970,
  "cnf" : {
    "kid" : b64'JDLUhTMjU2IiwiY3R5Ijoi ...'
  }
}
          ]]></artwork>
        </figure></t>
      </list>
  </t>

<t>
    <list style="hanging">
        <t>
            The client uses the symmetric PoP key to establish a DTLS
            PreSharedKey secure connection to the RS. The CoAP request PUT is
            sent to the uri-path /state on the RS, changing the state of the door to locked.
        </t>
        <t>
            F: The RS responds with a appropriate over the secure DTLS channel.
        </t>
    </list>
</t>
        <t><figure align="center" anchor="fig:cOfflineDTLSRequestAndResponse"
            title="Resource request and response protected by OSCOAP">
            <artwork align="left"><![CDATA[
           Resource
  Client    Server
    |         |
    |<=======>| DTLS Connection Establishment
    |         |   using Pre Shared Key
    |         |
    +-------->| Header: PUT (Code=0.03)
    | PUT     | Uri-Path: "state"
    |         | Payload: <new state for the lock>
    |         |
F:  |<--------+ Header: 2.04 Changed
    | 2.04    | Payload: <new state for the lock>
    |         |
            ]]></artwork>
        </figure></t>
    </section>

</section>
<section anchor="app:changelog" title="Document Updates">
   <section anchor="app:f9t10" title="Version -08 to -09">
      <t><list style="symbols">
        <t>Moved AS discovery from the DTLS profile to the
	framework, see <xref target="asDiscovery"/>.</t>
	<t>Made the use of CBOR mandatory. If you use JSON you
	can use vanilla OAuth.</t>
	<t>Made it mandatory for profiles to specify C-AS security
	and RS-AS security (the latter only if introspection is supported).</t>
	<t>Made the use of CBOR abbreviations mandatory.</t>
	<t>Added text to clarify the use of token references as an alternative
	to CWTs.</t>
	<t>Added text to clarify that introspection must not be delayed, in
	case the RS has to return a client token.</t>
	<t>Added security considerations about leakage through unprotected AS
	discovery information, combining profiles and leakage through error
	responses.</t>
	<t>Added privacy considerations about leakage through unprotected
	AS discovery.</t>
	<t>Added text that clarifies that introspection is optional.</t>
	<t>Made profile parameter optional since it can be implicit.</t>
	<t>Clarified that CoAP is not mandatory and other protocols can be
	used.</t>
	<t>Clarified the design justification for specific features of the
	framework in appendix A.</t>
	<t>Clarified appendix E.2.</t>
      </list></t>
   </section>
   <section anchor="app:f8t9" title="Version -07 to -08">
      <t><list style="symbols">
         <t>Removed specification of the "cnf" claim for CBOR/COSE, and
	 replaced with references to <xref
	 target="I-D.jones-ace-cwt-proof-of-possession"/></t>
      </list></t>
   </section>
   <section anchor="app:f7t8" title="Version -06 to -07">
     <t><list style="symbols">
       <t>Various clarifications added.</t>
       <t>Fixed erroneous author email.</t>
     </list></t>
   </section>
      <section anchor="app:f6t7" title="Version -05 to -06">
	<t><list style="symbols">
	  <t>Moved sections that define the ACE framework into
	  a subsection of the framework <xref target="oauthProfile"/>.</t>
	  <t>Split section on client credentials and grant into two separate
	  sections, <xref target="authorizationGrants"/>, and  <xref
	  target="clientCredentials"/>.</t>
	  <t>Added <xref target="ASAuthentication"/> on AS
	  authentication.</t>
	  <t>Added <xref target="authorizeEndpoint"/> on the Authorization
	  endpoint.</t>
	</list></t>
      </section>
      <section anchor="app:f5t6" title="Version -04 to -05">
	<t><list style="symbols">
	  <t>Added RFC 2119 language to the specification of the required
	  behavior of profile specifications.</t>
	  <t>Added <xref target="clientCredentials"/> on the relation
	  to the OAuth2 grant types.</t>
	  <t>Added CBOR abbreviations for error and the error codes defined in
	  OAuth2.</t>
	  <t>Added clarification about token expiration and long-running
	  requests in <xref target="tokenValidity"/></t>
	  <t>Added security considerations about tokens with symmetric pop
	  keys valid for more than one RS.</t>
	  <t>Added privacy considerations section.</t>
	  <t>Added IANA registry mapping the confirmation types from RFC 7800
	  to equivalent COSE types.</t>
	  <t>Added appendix D, describing assumptions about what the AS knows
	  about the client and the RS.</t>
	</list></t>
      </section>
      <section anchor="app:f4t5" title="Version -03 to -04">
	<t><list style="symbols">
	  <t>Added a description of the terms "framework" and
	  "profiles" as used in this document.</t>
	  <t>Clarified protection of access tokens in section 3.1.</t>
	  <t>Clarified uses of the "cnf" parameter in section 6.4.5.</t>
	  <t>Clarified intended use of Client Token in section 7.4.</t>
	</list></t>
      </section>
      <section anchor="app:f3t4" title="Version -02 to -03">
	<t><list style="symbols">
          <t>Removed references to draft-ietf-oauth-pop-key-distribution since
	  the status of this draft is unclear.</t>
	  <t>Copied and adapted security considerations from
	  draft-ietf-oauth-pop-key-distribution.</t>
	  <t>Renamed "client information" to "RS information" since it is
	  information about the RS.</t>
	  <t>Clarified the requirements on profiles of this framework.</t>
	  <t>Clarified the token endpoint protocol and removed negotiation
	  of "profile" and "alg" (section 6).</t>
	  <t>Renumbered the abbreviations for claims and parameters to
	  get a consistent numbering across different endpoints.</t>
	  <t>Clarified the introspection endpoint.</t>
	  <t>Renamed token, introspection and authz-info to "endpoint" instead
	  of "resource" to mirror the OAuth 2.0 terminology.</t>
	  <t>Updated the examples in the appendices.</t>
        </list></t>
      </section>
      <section anchor="app:f2t3" title="Version -01 to -02">
	<t><list style="symbols">
	  <t>Restructured to remove communication security parts.  These
	  shall now be defined in profiles.</t>
	  <t>Restructured section 5 to create new sections on the OAuth
	  endpoints token, introspection and authz-info.</t>
	  <t>Pulled in material from draft-ietf-oauth-pop-key-distribution in
	  order to define proof-of-possession key distribution.</t>
	  <t>Introduced the "cnf" parameter as defined in RFC7800 to reference
	  or transport keys used for proof of possession.</t>
	  <t>Introduced the "client-token" to transport client information
	  from the AS to the client via the RS in conjunction with
	  introspection.</t>
	  <t>Expanded the IANA section to define parameters for token request,
	  introspection and CWT claims.</t>
	  <t>Moved deployment scenarios to the appendix as examples.</t>
	</list></t>
      </section>
      <section anchor="app:f1t2" title="Version -00 to -01">
	<t><list style="symbols">
	  <t>Changed 5.1. from "Communication Security Protocol" to "Client
	  Information".</t>
	  <t>Major rewrite of 5.1 to clarify the information exchanged between
	  C and AS in the PoP access token request profile for IoT.
	  <list style="symbols">
	    <t>Allow the client to indicate preferences for the communication
	    security protocol.</t>
	    <t>Defined the term "Client Information" for the additional
	    information returned to the client in addition to the access
	    token.</t>
	    <t>Require that the messages between AS and client are secured,
	    either with (D)TLS or with COSE_Encrypted wrappers.</t>
	    <t>Removed dependency on OSCOAP and added generic text about
	    object security instead.</t>
	    <t>Defined the "rpk" parameter in the client information to
	    transmit the raw public key of the RS from AS to client.</t>
	    <t>(D)TLS MUST use the PoP key in the handshake (either as
	    PSK or as client RPK with client authentication).</t>
	    <t>Defined the use of x5c, x5t and x5tS256 parameters when a
	    client certificate is used for proof of possession.</t>
	    <t>Defined "tktn" parameter for signaling for how to transfer the
	    access token.</t>
	  </list></t>
	  <t>Added 5.2. the CoAP Access-Token option for transferring access
	  tokens in messages that do not have payload.</t>
	  <t>5.3.2. Defined success and error responses from the RS when
	  receiving an access token.</t>
	  <t>5.6.:Added section giving guidance on how to handle token
	  expiration in the absence of reliable time.</t>
	  <t>Appendix B Added list of roles and responsibilities for C, AS and
	  RS.</t>
	</list></t>
      </section>
    </section>
  </back>
</rfc>
