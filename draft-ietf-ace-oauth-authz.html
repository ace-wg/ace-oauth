<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Authentication and Authorization for Constrained Environments (ACE) using the OAuth 2.0 Framework (ACE-OAuth)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 Overview">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 OAuth 2.0">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 CoAP">
<link href="#rfc.section.4" rel="Chapter" title="4 Protocol Interactions">
<link href="#rfc.section.5" rel="Chapter" title="5 Framework">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Discovering Authorization Servers">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Unauthorized Resource Request Message">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 AS Request Creation Hints">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 The Client-Nonce Parameter">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Authorization Grants">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Client Credentials">
<link href="#rfc.section.5.6" rel="Chapter" title="5.6 AS Authentication">
<link href="#rfc.section.5.7" rel="Chapter" title="5.7 The Authorization Endpoint">
<link href="#rfc.section.5.8" rel="Chapter" title="5.8 The Token Endpoint">
<link href="#rfc.section.5.8.1" rel="Chapter" title="5.8.1 Client-to-AS Request">
<link href="#rfc.section.5.8.2" rel="Chapter" title="5.8.2 AS-to-Client Response">
<link href="#rfc.section.5.8.3" rel="Chapter" title="5.8.3 Error Response">
<link href="#rfc.section.5.8.4" rel="Chapter" title="5.8.4 Request and Response Parameters">
<link href="#rfc.section.5.8.4.1" rel="Chapter" title="5.8.4.1 Grant Type">
<link href="#rfc.section.5.8.4.2" rel="Chapter" title="5.8.4.2 Token Type">
<link href="#rfc.section.5.8.4.3" rel="Chapter" title="5.8.4.3 Profile">
<link href="#rfc.section.5.8.4.4" rel="Chapter" title="5.8.4.4 Client-Nonce">
<link href="#rfc.section.5.8.5" rel="Chapter" title="5.8.5 Mapping Parameters to CBOR">
<link href="#rfc.section.5.9" rel="Chapter" title="5.9 The Introspection Endpoint">
<link href="#rfc.section.5.9.1" rel="Chapter" title="5.9.1 Introspection Request">
<link href="#rfc.section.5.9.2" rel="Chapter" title="5.9.2 Introspection Response">
<link href="#rfc.section.5.9.3" rel="Chapter" title="5.9.3 Error Response">
<link href="#rfc.section.5.9.4" rel="Chapter" title="5.9.4 Mapping Introspection Parameters to CBOR">
<link href="#rfc.section.5.10" rel="Chapter" title="5.10 The Access Token">
<link href="#rfc.section.5.10.1" rel="Chapter" title="5.10.1 The Authorization Information Endpoint">
<link href="#rfc.section.5.10.1.1" rel="Chapter" title="5.10.1.1 Verifying an Access Token">
<link href="#rfc.section.5.10.1.2" rel="Chapter" title="5.10.1.2 Protecting the Authorization       Information Endpoint">
<link href="#rfc.section.5.10.2" rel="Chapter" title="5.10.2 Client Requests to the RS">
<link href="#rfc.section.5.10.3" rel="Chapter" title="5.10.3 Token Expiration">
<link href="#rfc.section.5.10.4" rel="Chapter" title="5.10.4 Key Expiration">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Protecting Tokens">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Communication Security">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Long-Term Credentials">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Unprotected AS Request Creation Hints">
<link href="#rfc.section.6.5" rel="Chapter" title="6.5 Minimal Security Requirements        for Communication">
<link href="#rfc.section.6.6" rel="Chapter" title="6.6 Token Freshness and Expiration">
<link href="#rfc.section.6.7" rel="Chapter" title="6.7 Combining Profiles">
<link href="#rfc.section.6.8" rel="Chapter" title="6.8 Unprotected Information">
<link href="#rfc.section.6.9" rel="Chapter" title="6.9 Identifying Audiences">
<link href="#rfc.section.6.10" rel="Chapter" title="6.10 Denial of Service Against or with      Introspection">
<link href="#rfc.section.7" rel="Chapter" title="7 Privacy Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 IANA Considerations">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 ACE Authorization Server Request Creation Hints">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 CoRE Resource Type Registry">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 OAuth Extensions Error Registration">
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 OAuth Error Code CBOR Mappings Registry">
<link href="#rfc.section.8.5" rel="Chapter" title="8.5 OAuth Grant Type CBOR Mappings">
<link href="#rfc.section.8.6" rel="Chapter" title="8.6 OAuth Access Token Types">
<link href="#rfc.section.8.7" rel="Chapter" title="8.7 OAuth Access Token Type CBOR Mappings">
<link href="#rfc.section.8.7.1" rel="Chapter" title="8.7.1 Initial Registry Contents">
<link href="#rfc.section.8.8" rel="Chapter" title="8.8 ACE Profile Registry">
<link href="#rfc.section.8.9" rel="Chapter" title="8.9 OAuth Parameter Registration">
<link href="#rfc.section.8.10" rel="Chapter" title="8.10 OAuth Parameters CBOR Mappings Registry">
<link href="#rfc.section.8.11" rel="Chapter" title="8.11 OAuth Introspection Response Parameter Registration">
<link href="#rfc.section.8.12" rel="Chapter" title="8.12 OAuth Token Introspection Response CBOR Mappings Registry">
<link href="#rfc.section.8.13" rel="Chapter" title="8.13 JSON Web Token Claims">
<link href="#rfc.section.8.14" rel="Chapter" title="8.14 CBOR Web Token Claims">
<link href="#rfc.section.8.15" rel="Chapter" title="8.15 Media Type Registrations">
<link href="#rfc.section.8.16" rel="Chapter" title="8.16 CoAP Content-Format Registry">
<link href="#rfc.section.8.17" rel="Chapter" title="8.17 Expert Review Instructions">
<link href="#rfc.section.9" rel="Chapter" title="9 Acknowledgments">
<link href="#rfc.references" rel="Chapter" title="10 References">
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Design Justification">
<link href="#rfc.appendix.B" rel="Chapter" title="B Roles and Responsibilities">
<link href="#rfc.appendix.C" rel="Chapter" title="C Requirements on Profiles">
<link href="#rfc.appendix.D" rel="Chapter" title="D Assumptions on AS Knowledge about C and RS">
<link href="#rfc.appendix.E" rel="Chapter" title="E Differences to OAuth 2.0">
<link href="#rfc.appendix.F" rel="Chapter" title="F Deployment Examples">
<link href="#rfc.appendix.F.1" rel="Chapter" title="F.1 Local Token Validation">
<link href="#rfc.appendix.F.2" rel="Chapter" title="F.2 Introspection Aided Token Validation">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.37.1 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Seitz, L., Selander, G., Wahlstroem, E., Erdtman, S., and H. Tschofenig" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-ace-oauth-authz-43" />
  <meta name="dct.issued" scheme="ISO8601" content="2021-17" />
  <meta name="dct.abstract" content="This specification defines a framework for authentication and authorization in Internet of Things (IoT) environments called ACE-OAuth.  The framework is based on a set of building blocks including OAuth 2.0 and the Constrained Application Protocol (CoAP), thus transforming a well-known and widely used authorization solution into a form suitable for IoT devices.  Existing specifications are used where possible, but extensions are added and profiles are defined to better serve the IoT use cases.  " />
  <meta name="description" content="This specification defines a framework for authentication and authorization in Internet of Things (IoT) environments called ACE-OAuth.  The framework is based on a set of building blocks including OAuth 2.0 and the Constrained Application Protocol (CoAP), thus transforming a well-known and widely used authorization solution into a form suitable for IoT devices.  Existing specifications are used where possible, but extensions are added and profiles are defined to better serve the IoT use cases.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">ACE Working Group</td>
<td class="right">L. Seitz</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Combitech</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">G. Selander</td>
</tr>
<tr>
<td class="left">Expires: February 18, 2022</td>
<td class="right">Ericsson</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">E. Wahlstroem</td>
</tr>
<tr>
<td class="left"></td>
<td class="right"></td>
</tr>
<tr>
<td class="left"></td>
<td class="right">S. Erdtman</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Spotify AB</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">H. Tschofenig</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Arm Ltd.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">August 17, 2021</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Authentication and Authorization for Constrained Environments (ACE) using the OAuth 2.0 Framework (ACE-OAuth)<br />
  <span class="filename">draft-ietf-ace-oauth-authz-43</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This specification defines a framework for authentication and authorization in Internet of Things (IoT) environments called ACE-OAuth.  The framework is based on a set of building blocks including OAuth 2.0 and the Constrained Application Protocol (CoAP), thus transforming a well-known and widely used authorization solution into a form suitable for IoT devices.  Existing specifications are used where possible, but extensions are added and profiles are defined to better serve the IoT use cases.  </p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on February 18, 2022.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2021 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">Overview</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">OAuth 2.0</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">CoAP</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Protocol Interactions</a>
</li>
<li>5.   <a href="#rfc.section.5">Framework</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Discovering Authorization Servers</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Unauthorized Resource Request Message</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">AS Request Creation Hints</a>
</li>
<ul><li>5.3.1.   <a href="#rfc.section.5.3.1">The Client-Nonce Parameter</a>
</li>
</ul><li>5.4.   <a href="#rfc.section.5.4">Authorization Grants</a>
</li>
<li>5.5.   <a href="#rfc.section.5.5">Client Credentials</a>
</li>
<li>5.6.   <a href="#rfc.section.5.6">AS Authentication</a>
</li>
<li>5.7.   <a href="#rfc.section.5.7">The Authorization Endpoint</a>
</li>
<li>5.8.   <a href="#rfc.section.5.8">The Token Endpoint</a>
</li>
<ul><li>5.8.1.   <a href="#rfc.section.5.8.1">Client-to-AS Request</a>
</li>
<li>5.8.2.   <a href="#rfc.section.5.8.2">AS-to-Client Response</a>
</li>
<li>5.8.3.   <a href="#rfc.section.5.8.3">Error Response</a>
</li>
<li>5.8.4.   <a href="#rfc.section.5.8.4">Request and Response Parameters</a>
</li>
<ul><li>5.8.4.1.   <a href="#rfc.section.5.8.4.1">Grant Type</a>
</li>
<li>5.8.4.2.   <a href="#rfc.section.5.8.4.2">Token Type</a>
</li>
<li>5.8.4.3.   <a href="#rfc.section.5.8.4.3">Profile</a>
</li>
<li>5.8.4.4.   <a href="#rfc.section.5.8.4.4">Client-Nonce</a>
</li>
</ul><li>5.8.5.   <a href="#rfc.section.5.8.5">Mapping Parameters to CBOR</a>
</li>
</ul><li>5.9.   <a href="#rfc.section.5.9">The Introspection Endpoint</a>
</li>
<ul><li>5.9.1.   <a href="#rfc.section.5.9.1">Introspection Request</a>
</li>
<li>5.9.2.   <a href="#rfc.section.5.9.2">Introspection Response</a>
</li>
<li>5.9.3.   <a href="#rfc.section.5.9.3">Error Response</a>
</li>
<li>5.9.4.   <a href="#rfc.section.5.9.4">Mapping Introspection Parameters to CBOR</a>
</li>
</ul><li>5.10.   <a href="#rfc.section.5.10">The Access Token</a>
</li>
<ul><li>5.10.1.   <a href="#rfc.section.5.10.1">The Authorization Information Endpoint</a>
</li>
<ul><li>5.10.1.1.   <a href="#rfc.section.5.10.1.1">Verifying an Access Token</a>
</li>
<li>5.10.1.2.   <a href="#rfc.section.5.10.1.2">Protecting the Authorization       Information Endpoint</a>
</li>
</ul><li>5.10.2.   <a href="#rfc.section.5.10.2">Client Requests to the RS</a>
</li>
<li>5.10.3.   <a href="#rfc.section.5.10.3">Token Expiration</a>
</li>
<li>5.10.4.   <a href="#rfc.section.5.10.4">Key Expiration</a>
</li>
</ul></ul><li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Protecting Tokens</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Communication Security</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Long-Term Credentials</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Unprotected AS Request Creation Hints</a>
</li>
<li>6.5.   <a href="#rfc.section.6.5">Minimal Security Requirements        for Communication</a>
</li>
<li>6.6.   <a href="#rfc.section.6.6">Token Freshness and Expiration</a>
</li>
<li>6.7.   <a href="#rfc.section.6.7">Combining Profiles</a>
</li>
<li>6.8.   <a href="#rfc.section.6.8">Unprotected Information</a>
</li>
<li>6.9.   <a href="#rfc.section.6.9">Identifying Audiences</a>
</li>
<li>6.10.   <a href="#rfc.section.6.10">Denial of Service Against or with      Introspection</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Privacy Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">IANA Considerations</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">ACE Authorization Server Request Creation Hints</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">CoRE Resource Type Registry</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">OAuth Extensions Error Registration</a>
</li>
<li>8.4.   <a href="#rfc.section.8.4">OAuth Error Code CBOR Mappings Registry</a>
</li>
<li>8.5.   <a href="#rfc.section.8.5">OAuth Grant Type CBOR Mappings</a>
</li>
<li>8.6.   <a href="#rfc.section.8.6">OAuth Access Token Types</a>
</li>
<li>8.7.   <a href="#rfc.section.8.7">OAuth Access Token Type CBOR Mappings</a>
</li>
<ul><li>8.7.1.   <a href="#rfc.section.8.7.1">Initial Registry Contents</a>
</li>
</ul><li>8.8.   <a href="#rfc.section.8.8">ACE Profile Registry</a>
</li>
<li>8.9.   <a href="#rfc.section.8.9">OAuth Parameter Registration</a>
</li>
<li>8.10.   <a href="#rfc.section.8.10">OAuth Parameters CBOR Mappings Registry</a>
</li>
<li>8.11.   <a href="#rfc.section.8.11">OAuth Introspection Response Parameter Registration</a>
</li>
<li>8.12.   <a href="#rfc.section.8.12">OAuth Token Introspection Response CBOR Mappings Registry</a>
</li>
<li>8.13.   <a href="#rfc.section.8.13">JSON Web Token Claims</a>
</li>
<li>8.14.   <a href="#rfc.section.8.14">CBOR Web Token Claims</a>
</li>
<li>8.15.   <a href="#rfc.section.8.15">Media Type Registrations</a>
</li>
<li>8.16.   <a href="#rfc.section.8.16">CoAP Content-Format Registry</a>
</li>
<li>8.17.   <a href="#rfc.section.8.17">Expert Review Instructions</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Acknowledgments</a>
</li>
<li>10.   <a href="#rfc.references">References</a>
</li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Design Justification</a>
</li>
<li>Appendix B.   <a href="#rfc.appendix.B">Roles and Responsibilities</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Requirements on Profiles</a>
</li>
<li>Appendix D.   <a href="#rfc.appendix.D">Assumptions on AS Knowledge about C and RS</a>
</li>
<li>Appendix E.   <a href="#rfc.appendix.E">Differences to OAuth 2.0</a>
</li>
<li>Appendix F.   <a href="#rfc.appendix.F">Deployment Examples</a>
</li>
<ul><li>F.1.   <a href="#rfc.appendix.F.1">Local Token Validation</a>
</li>
<li>F.2.   <a href="#rfc.appendix.F.2">Introspection Aided Token Validation</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">Authorization is the process for granting approval to an entity to access a generic resource <a href="#RFC4949" class="xref">[RFC4949]</a>. The authorization task itself can best be described as granting access to a requesting client, for a resource hosted on a device, the resource server (RS).  This exchange is mediated by one or multiple authorization servers (AS). Managing authorization for a large number of devices and users can be a complex task.  </p>
<p id="rfc.section.1.p.2">While prior work on authorization solutions for the Web and for the mobile environment also applies to the Internet of Things (IoT) environment, many IoT devices are constrained, for example, in terms of processing capabilities, available memory, etc. For such devices the Constrained Application Protocol (CoAP) <a href="#RFC7252" class="xref">[RFC7252]</a> can alleviate some resource concerns when used instead of HTTP to implement the communication flows of this specification.</p>
<p><a href="#constraints" class="xref">Appendix A</a> gives an overview of the constraints considered in this design, and a more detailed treatment of constraints can be found in <a href="#RFC7228" class="xref">[RFC7228]</a>.  This design aims to accommodate different IoT deployments and thus a continuous range of device and network capabilities.  Taking energy consumption as an example: At one end there are energy-harvesting or  battery powered devices which have a tight power budget, on the other end there are mains-powered devices, and all levels in between.</p>
<p id="rfc.section.1.p.4">Hence, IoT devices may be very different in terms of available processing and message exchange capabilities and there is a need to support many different authorization use cases <a href="#RFC7744" class="xref">[RFC7744]</a>.</p>
<p id="rfc.section.1.p.5">This specification describes a framework for authentication and authorization in constrained environments (ACE) built on re-use of OAuth 2.0 <a href="#RFC6749" class="xref">[RFC6749]</a>, thereby extending authorization to Internet of Things devices.  This specification contains the necessary building blocks for adjusting OAuth 2.0 to IoT environments.</p>
<p id="rfc.section.1.p.6">Profiles of this framework are available in separate specifications, such as <a href="#I-D.ietf-ace-dtls-authorize" class="xref">[I-D.ietf-ace-dtls-authorize]</a> or <a href="#I-D.ietf-ace-oscore-profile" class="xref">[I-D.ietf-ace-oscore-profile]</a>.  Such profiles may specify the use of the framework for a specific security protocol and the underlying transports for use in a specific deployment environment to improve interoperability.  Implementations may claim conformance with a specific profile, whereby implementations utilizing the same profile interoperate, while implementations of different profiles are not expected to be interoperable.  More powerful devices, such as mobile phones and tablets, may implement multiple profiles and will therefore be able to interact with a wider range of constrained devices.  Requirements on profiles are described at contextually appropriate places throughout this specification, and also summarized in <a href="#app:profileRequirements" class="xref">Appendix C</a>.  </p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.2.p.2">Certain security-related terms such as "authentication", "authorization", "confidentiality", "(data) integrity", "message authentication code", and "verify" are taken from <a href="#RFC4949" class="xref">[RFC4949]</a>.  </p>
<p id="rfc.section.2.p.3">Since exchanges in this specification are described as RESTful protocol interactions, HTTP <a href="#RFC7231" class="xref">[RFC7231]</a> offers useful terminology.  </p>
<p id="rfc.section.2.p.4">Terminology for entities in the architecture is defined in OAuth 2.0 <a href="#RFC6749" class="xref">[RFC6749]</a> such as client (C), resource server (RS), and authorization server (AS).</p>
<p id="rfc.section.2.p.5">Note that the term "endpoint" is used here following its OAuth definition, which is to denote resources such as token and introspection at the AS and authz-info at the RS (see <a href="#tokenAuthInfoEndpoint" class="xref">Section 5.10.1</a> for a definition of the authz-info endpoint).  The CoAP <a href="#RFC7252" class="xref">[RFC7252]</a> definition, which is "An entity participating in the CoAP protocol" is not used in this specification.</p>
<p id="rfc.section.2.p.6">The specifications in this document is called the "framework" or "ACE framework".  When referring to "profiles of this framework" it refers to additional specifications that define the use of this specification with concrete transport and communication security protocols (e.g., CoAP over DTLS).  </p>
<p id="rfc.section.2.p.7">The term "Access Information" is used for parameters, other than the access token, provided to the client by the AS to enable it to access the RS (e.g. public key of the RS, profile supported by RS).</p>
<p id="rfc.section.2.p.8">The term "Authorization Information" is used to denote all information, including the claims of relevant access tokens, that an RS uses to determine whether an access request should be granted.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#overview" id="overview">Overview</a>
</h1>
<p id="rfc.section.3.p.1">This specification defines the ACE framework for authorization in the Internet of Things environment. It consists of a set of building blocks.</p>
<p id="rfc.section.3.p.2">The basic block is the OAuth 2.0 <a href="#RFC6749" class="xref">[RFC6749]</a> framework, which enjoys widespread deployment.  Many IoT devices can support OAuth 2.0 without any additional extensions, but for certain constrained settings additional profiling is needed.  </p>
<p id="rfc.section.3.p.3">Another building block is the lightweight web transfer protocol CoAP <a href="#RFC7252" class="xref">[RFC7252]</a>, for those communication environments where HTTP is not appropriate.  CoAP typically runs on top of UDP, which further reduces overhead and message exchanges. While this specification defines extensions for the use of OAuth over CoAP, other underlying protocols are not prohibited from being supported in the future, such as HTTP/2 <a href="#RFC7540" class="xref">[RFC7540]</a>, Message Queuing Telemetry Transport (MQTT) <a href="#MQTT5.0" class="xref">[MQTT5.0]</a>, Bluetooth Low Energy (BLE) <a href="#BLE" class="xref">[BLE]</a> and QUIC <a href="#I-D.ietf-quic-transport" class="xref">[I-D.ietf-quic-transport]</a>.  Note that this document specifies protocol exchanges in terms of RESTful verbs such as GET and POST.  Future profiles using protocols that do not support these verbs MUST specify how the corresponding protocol messages are transmitted instead.</p>
<p id="rfc.section.3.p.4">A third building block is the Concise Binary Object Representation (CBOR) <a href="#RFC8949" class="xref">[RFC8949]</a>, for encodings where JSON <a href="#RFC8259" class="xref">[RFC8259]</a> is not sufficiently compact.  CBOR is a binary encoding designed for small code and message size. Self-contained tokens and protocol message payloads are encoded in CBOR when CoAP is used. When CoAP is not used, the use of CBOR remains RECOMMENDED.  </p>
<p id="rfc.section.3.p.5">A fourth building block is CBOR Object Signing and Encryption (COSE) <a href="#RFC8152" class="xref">[RFC8152]</a>, which enables object-level layer security as an alternative or complement to transport layer security (DTLS <a href="#RFC6347" class="xref">[RFC6347]</a> or TLS <a href="#RFC8446" class="xref">[RFC8446]</a>). COSE is used to secure self-contained tokens such as proof-of-possession (PoP) tokens, which are an extension to the OAuth bearer tokens. The default token format is defined in CBOR Web Token (CWT) <a href="#RFC8392" class="xref">[RFC8392]</a>.  Application-layer security for CoAP using COSE can be provided with OSCORE <a href="#RFC8613" class="xref">[RFC8613]</a>.</p>
<p id="rfc.section.3.p.6">With the building blocks listed above, solutions satisfying various IoT device and network constraints are possible.  A list of constraints is described in detail in <a href="#RFC7228" class="xref">[RFC7228]</a> and a description of how the building blocks mentioned above relate to the various constraints can be found in <a href="#constraints" class="xref">Appendix A</a>.</p>
<p id="rfc.section.3.p.7">Luckily, not every IoT device suffers from all constraints.  The ACE framework nevertheless takes all these aspects into account and allows several different deployment variants to co-exist, rather than mandating a one-size-fits-all solution.  It is important to cover the wide range of possible interworking use cases and the different requirements from a security point of view.  Once IoT deployments mature, popular deployment variants will be documented in the form of ACE profiles.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#oauth2Overview" id="oauth2Overview">OAuth 2.0</a>
</h1>
<p id="rfc.section.3.1.p.1">The OAuth 2.0 authorization framework enables a client to obtain scoped access to a resource with the permission of a resource owner.  Authorization information, or references to it, is passed between the nodes using access tokens.  These access tokens are issued to clients by an authorization server with the approval of the resource owner.  The client uses the access token to access the protected resources hosted by the resource server.</p>
<p id="rfc.section.3.1.p.2">A number of OAuth 2.0 terms are used within this specification: </p>

<dl>
<dt>Access Tokens:</dt>
<dd style="margin-left: 8">
<br> Access tokens are credentials needed to access protected resources.  An access token is a data structure representing authorization permissions issued by the AS to the client.  Access tokens are generated by the AS and consumed by the RS.  The access token content is opaque to the client.  <br><br> Access tokens can have different formats, and various methods of utilization e.g., cryptographic properties) based on the security requirements of the given deployment.  <br><br> </dd>
<dt>Introspection:</dt>
<dd style="margin-left: 8">
<br> Introspection is a method for a resource server or potentially a client, to query the authorization server for the active state and content of a received access token.  This is particularly useful in those cases where the authorization decisions are very dynamic and/or where the received access token itself is an opaque reference rather than a self-contained token.  More information about introspection in OAuth 2.0 can be found in <a href="#RFC7662" class="xref">[RFC7662]</a>.  </dd>
<dt>Refresh Tokens:</dt>
<dd style="margin-left: 8">
<br> Refresh tokens are credentials used to obtain access tokens.  Refresh tokens are issued to the client by the authorization server and are used to obtain a new access token when the current access token expires, or to obtain additional access tokens with identical or narrower scope (such access tokens may have a shorter lifetime and fewer permissions than authorized by the resource owner).  Issuing a refresh token is optional at the discretion of the authorization server.  If the authorization server issues a refresh token, it is included when issuing an access token (i.e., step (B) in <a href="#fig:protocolFlow" class="xref">Figure 1</a>).  <br><br> A refresh token in OAuth 2.0 is a string representing the authorization granted	to the client by the resource owner.  The string is usually opaque to the client.  The token denotes an identifier used to retrieve the authorization information.  Unlike access tokens, refresh tokens are intended for use only with authorization servers and are never sent to resource servers.  In this framework, refresh tokens are encoded in binary instead of strings, if used.  <br><br>
</dd>
<dt>Proof of Possession Tokens:</dt>
<dd style="margin-left: 8">
<br> A token may be bound to a cryptographic key,  which is then used to bind the token to a request authorized by the token.  Such tokens are called proof-of-possession tokens (or PoP tokens).  <br><br> The proof-of-possession security concept used here assumes that the AS acts as a trusted third party that binds keys to tokens.  In the case of access tokens, these so called PoP keys are then used by the client to demonstrate the possession of the secret to the RS when accessing the resource.  The RS, when receiving an access token, needs to verify that the key used by the client matches the one bound to the access token.  When this specification uses the term "access token" it is assumed to be a PoP access token unless specifically stated otherwise.  <br><br> The key bound to the token (the PoP key) may use either symmetric or asymmetric cryptography.  The appropriate choice of the kind of cryptography depends on the constraints of the IoT devices as well as on the security requirements of the use case.  <br><br> <dl>
<dt>Symmetric PoP key:</dt>
<dd style="margin-left: 8">
<br> The AS generates a random symmetric PoP key.  The key is either stored to be returned on introspection calls or included in the token.  Either the whole token or only the key MUST be encrypted in the latter case.  The PoP key is also returned to client together with the token.<br><br> </dd>
<dt>Asymmetric PoP key:</dt>
<dd style="margin-left: 8">
<br> An asymmetric key pair is generated by the client and the public key is sent to the AS (if it does not already have knowledge of the client's public key).  Information about the public key, which is the PoP key in this case, is either stored to be returned on introspection calls or included inside the token and sent back to the client.  The resource server consuming the token can identify the public key from the information in the token, which allows the client to use the corresponding private key for the proof of possession.  </dd>
</dl>
<p> </p>
<br><br> The token is either a simple reference, or a structured information object (e.g., CWT <a href="#RFC8392" class="xref">[RFC8392]</a>) protected by a cryptographic wrapper (e.g., COSE <a href="#RFC8152" class="xref">[RFC8152]</a>).  The choice of PoP key does not necessarily imply a specific credential type for the integrity protection of the token.<br><br> </dd>
<dt>Scopes and Permissions:</dt>
<dd style="margin-left: 8">
<br> In OAuth 2.0, the client specifies the type of permissions it is seeking to obtain (via the scope parameter) in the access token request.  In turn, the AS may use the scope response parameter to inform the client of the scope of the access token issued.  As the client could be a constrained device as well, this specification defines the use of CBOR encoding, see <a href="#oauthProfile" class="xref">Section 5</a>, for such requests and responses.  <br><br> The values of the scope parameter in OAuth 2.0 are expressed as a list of space-delimited, case-sensitive strings, with a semantic that is well-known to the AS and the RS.  More details about the concept of scopes is found under Section 3.3 in <a href="#RFC6749" class="xref">[RFC6749]</a>.<br><br> </dd>
<dt>Claims:</dt>
<dd style="margin-left: 8">
<br> Information carried in the access token or returned from introspection, called claims, is in the form of name-value pairs.  An access token may, for example, include a claim identifying the AS that issued the token (via the "iss" claim) and what audience the access token is intended for (via the "aud" claim).  The audience of an access token can be a specific resource or one or many resource servers.  The resource owner policies influence what claims are put into the access token by the authorization server.  <br><br> While the structure and encoding of the access token varies throughout deployments, a standardized format has been defined with the JSON Web Token (JWT) <a href="#RFC7519" class="xref">[RFC7519]</a> where claims are encoded as a JSON object.  In <a href="#RFC8392" class="xref">[RFC8392]</a> the CBOR Web Token (CWT) has been defined as an equivalent format using CBOR encoding.  <br><br> </dd>
<dt>The token and introspection Endpoints:</dt>
<dd style="margin-left: 8">
<br> The AS hosts the token endpoint that allows a client to request access tokens. The client makes a POST request to the token endpoint on the AS and receives the access token in the response (if the request was successful).  <br> In some deployments, a token introspection endpoint is provided by the AS, which can be used by the RS and potentially the client, if they need to request additional information regarding a received access token.  The requesting entity makes a POST request to the introspection endpoint on the AS and receives information about the access token in the response. (See "Introspection" above.) <br><br> </dd>
</dl>

<p> </p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#coap" id="coap">CoAP</a>
</h1>
<p id="rfc.section.3.2.p.1">CoAP is an application-layer protocol similar to HTTP, but specifically designed for constrained environments.  CoAP typically uses datagram-oriented transport, such as UDP, where reordering and loss of packets can occur.  A security solution needs to take the latter aspects into account.</p>
<p id="rfc.section.3.2.p.2">While HTTP uses headers and query strings to convey additional information about a request, CoAP encodes such information into header parameters called 'options'.</p>
<p id="rfc.section.3.2.p.3">CoAP supports application-layer fragmentation of the CoAP payloads through blockwise transfers <a href="#RFC7959" class="xref">[RFC7959]</a>.  However, blockwise transfer does not increase the size limits of CoAP options, therefore data encoded in options has to be kept small.  </p>
<p id="rfc.section.3.2.p.4">Transport layer security for CoAP can be provided by DTLS or TLS <a href="#RFC6347" class="xref">[RFC6347]</a><a href="#RFC8446" class="xref">[RFC8446]</a> <a href="#I-D.ietf-tls-dtls13" class="xref">[I-D.ietf-tls-dtls13]</a>.  CoAP defines a number of proxy operations that require transport layer security to be terminated at the proxy. One approach for protecting CoAP communication end-to-end through proxies, and also to support security for CoAP over a different transport in a uniform way, is to provide security at the application layer using an object-based security mechanism such as COSE <a href="#RFC8152" class="xref">[RFC8152]</a>.  </p>
<p id="rfc.section.3.2.p.5">One application of COSE is OSCORE <a href="#RFC8613" class="xref">[RFC8613]</a>, which provides end-to-end confidentiality, integrity and replay protection, and a secure binding between CoAP request and response messages. In OSCORE, the CoAP messages are wrapped in COSE objects and sent using CoAP.  </p>
<p id="rfc.section.3.2.p.6">In this framework the use of CoAP as replacement for HTTP is RECOMMENDED for use in constrained environments.  For communication security this framework does not make an explicit protocol recommendation, since the choice depends on the requirements of the specific application.  DTLS <a href="#RFC6347" class="xref">[RFC6347]</a>, <a href="#I-D.ietf-tls-dtls13" class="xref">[I-D.ietf-tls-dtls13]</a> and OSCORE <a href="#RFC8613" class="xref">[RFC8613]</a> are mentioned as examples, other protocols fulfilling the requirements from <a href="#minimalCommSecReq" class="xref">Section 6.5</a> are also applicable.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#specs" id="specs">Protocol Interactions</a>
</h1>
<p id="rfc.section.4.p.1">The ACE framework is based on the OAuth 2.0 protocol interactions using the token endpoint and optionally the introspection endpoint.  A client obtains an access token, and optionally a refresh token, from an AS using the token endpoint and subsequently presents the access token to an RS to gain access to a protected resource. In most deployments the RS can process the access token locally, however in some cases the RS may present it to the AS via the introspection endpoint to get fresh information.  These interactions are shown in <a href="#fig:protocolFlow" class="xref">Figure 1</a>.  An overview of various OAuth concepts is provided in <a href="#oauth2Overview" class="xref">Section 3.1</a>.  </p>
<div id="rfc.figure.1"></div>
<div id="fig:protocolFlow"></div>
<pre>
+--------+                               +---------------+
|        |---(A)-- Token Request -------&gt;|               |
|        |                               | Authorization |
|        |&lt;--(B)-- Access Token ---------|    Server     |
|        |    + Access Information       |               |
|        |    + Refresh Token (optional) +---------------+
|        |                                      ^ |
|        |            Introspection Request  (D)| |
| Client |                         Response     | |(E)
|        |            (optional exchange)       | |
|        |                                      | v
|        |                               +--------------+
|        |---(C)-- Token + Request -----&gt;|              |
|        |                               |   Resource   |
|        |&lt;--(F)-- Protected Resource ---|    Server    |
|        |                               |              |
+--------+                               +--------------+
  </pre>
<p class="figure">Figure 1: Basic Protocol Flow.</p>
<p></p>
<p></p>

<dl>
<dt>Requesting an Access Token (A):</dt>
<dd style="margin-left: 8">
<br> The client makes an access token request to the token endpoint at the AS.  This framework assumes the use of PoP access tokens (see <a href="#oauth2Overview" class="xref">Section 3.1</a> for a short description) wherein the AS binds a key to an access token.  The client may include permissions it seeks to obtain, and information about the credentials it wants to use for proof-of-possession (e.g., symmetric/asymmetric cryptography or a reference to a specific key) of the access token.<br><br> </dd>
<dt>Access Token Response (B):</dt>
<dd style="margin-left: 8">
<br> If the request from the client has been successfully verified, authenticated, and authorized, the AS returns an access token and optionally a refresh token. Note that only certain grant types support refresh tokens.  The AS can also return additional parameters, referred to as "Access Information".  In addition to the response parameters defined by OAuth 2.0 and the PoP access token extension, this framework defines parameters that can be used to inform the client about capabilities of the RS, e.g.  the profile the RS supports.  More information about these parameters can be found in <a href="#tokenParams" class="xref">Section 5.8.4</a>.  <br><br> </dd>
<dt>Resource Request (C):</dt>
<dd style="margin-left: 8">
<br> The client interacts with the RS to request access to the protected resource and provides the access token.  The protocol to use between the client and the RS is not restricted to CoAP. HTTP, HTTP/2 <a href="#RFC7540" class="xref">[RFC7540]</a>, QUIC <a href="#I-D.ietf-quic-transport" class="xref">[I-D.ietf-quic-transport]</a>, MQTT <a href="#MQTT5.0" class="xref">[MQTT5.0]</a>, Bluetooth Low Energy <a href="#BLE" class="xref">[BLE]</a>, etc., are also viable candidates.  <br><br> Depending on the device limitations and the selected protocol, this exchange may be split up into two parts: <ul class="empty">
<li>(1) the client sends the access token containing, or referencing, the authorization information to the RS, that will be used for subsequent resource requests by the client, and </li>
<li>(2) the client makes the resource access request, using the communication security protocol and other Access Information obtained from the AS.</li>
</ul>
<p> </p>
<br><br> The client and the RS mutually authenticate using the security protocol specified in the profile (see step B) and the keys obtained in the access token or the Access Information.  The RS verifies that the token is integrity protected and originated by the AS. It then compares the claims contained in the access token with the resource request. If the RS is online, validation can be handed over to the AS using token introspection (see messages D and E) over HTTP or CoAP.<br><br> </dd>
<dt>Token Introspection Request (D):</dt>
<dd style="margin-left: 8">
<br> A resource server may be configured to introspect the access token by including it in a request to the introspection endpoint at that AS.  Token introspection over CoAP is defined in <a href="#introspectionEndpoint" class="xref">Section 5.9</a> and for HTTP in <a href="#RFC7662" class="xref">[RFC7662]</a>.  <br><br> Note that token introspection is an optional step and can be omitted if the token is self-contained and the resource server is prepared to perform the token validation on its own.<br><br> </dd>
<dt>Token Introspection Response (E):</dt>
<dd style="margin-left: 8">
<br> The AS validates the token and returns the most recent parameters, such as scope, audience, validity etc. associated with it back to the RS.  The RS then uses the received parameters to process the request to either accept or to deny it.<br><br> </dd>
<dt>Protected Resource (F):</dt>
<dd style="margin-left: 8">
<br> If the request from the client is authorized, the RS fulfills the request and returns a response with the appropriate response code.  The RS uses the dynamically established keys to protect the response, according to the communication security protocol used.  </dd>
</dl>

<p> </p>
<p id="rfc.section.4.p.4">The OAuth 2.0 framework defines a number of "protocol flows" via grant types, which have been extended further with extensions to OAuth 2.0 (such as <a href="#RFC7521" class="xref">[RFC7521]</a> and <a href="#RFC8628" class="xref">[RFC8628]</a>).  What grant type works best depends on the usage scenario and <a href="#RFC7744" class="xref">[RFC7744]</a> describes many different IoT use cases but there are two grant types that cover a majority of these scenarios, namely the Authorization Code Grant (described in Section 4.1 of <a href="#RFC7521" class="xref">[RFC7521]</a>) and the Client Credentials Grant (described in Section 4.4 of <a href="#RFC7521" class="xref">[RFC7521]</a>). The Authorization Code Grant is a good fit for use with apps running on smart phones and tablets that request access to IoT devices, a common scenario in the smart home environment, where users need to go through an authentication and authorization phase (at least during the initial setup phase). The native apps guidelines described in <a href="#RFC8252" class="xref">[RFC8252]</a> are applicable to this use case. The Client Credential Grant is a good fit for use with IoT devices where the OAuth client itself is constrained. In such a case, the resource owner has pre-arranged access rights for the client with the authorization server, which is often accomplished using a commissioning tool.</p>
<p id="rfc.section.4.p.5">The consent of the resource owner, for giving a client access to a protected resource, can be provided dynamically as in the traditional OAuth flows, or it could be pre-configured by the resource owner as authorization policies at the AS, which the AS evaluates when a token request arrives.  The resource owner and the requesting party (i.e., client owner) are not shown in <a href="#fig:protocolFlow" class="xref">Figure 1</a>.  </p>
<p id="rfc.section.4.p.6">This framework supports a wide variety of communication security mechanisms between the ACE entities, such as client, AS, and RS. It is assumed that the client has been registered (also called enrolled or onboarded) to an AS using a mechanism defined outside the scope of this document.  In practice, various techniques for onboarding have been used, such as factory-based provisioning or the use of commissioning tools. Regardless of the onboarding technique, this provisioning procedure implies that the client and the AS exchange credentials and configuration parameters.  These credentials are used to mutually authenticate each other and to protect messages exchanged between the client and the AS.</p>
<p id="rfc.section.4.p.7">It is also assumed that the RS has been registered with the AS, potentially in a similar way as the client has been registered with the AS.  Established keying material between the AS and the RS allows the AS to apply cryptographic protection to the access token to ensure that its content cannot be modified, and if needed, that the content is confidentiality protected. Confidentiality protection of the access token content would be provided on top of confidentiality protection via a communication security protocol. </p>
<p id="rfc.section.4.p.8">The keying material necessary for establishing communication security between C and RS is dynamically established as part of the protocol described in this document.  </p>
<p id="rfc.section.4.p.9">At the start of the protocol, there is an optional discovery step where the client discovers the resource server and the resources this server hosts.  In this step, the client might also determine what permissions are needed to access the protected resource.  A generic procedure is described in <a href="#asDiscovery" class="xref">Section 5.1</a>; profiles MAY define other procedures for discovery.</p>
<p id="rfc.section.4.p.10">In Bluetooth Low Energy, for example, advertisements are broadcast by a peripheral, including information about the primary services.  In CoAP, as a second example, a client can make a request to "/.well-known/core" to obtain information about available resources, which are returned in a standardized format as described in <a href="#RFC6690" class="xref">[RFC6690]</a>.  </p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#oauthProfile" id="oauthProfile">Framework</a>
</h1>
<p id="rfc.section.5.p.1">The following sections detail the profiling and extensions of OAuth 2.0 for constrained environments, which constitutes the ACE framework.  </p>
<p></p>

<dl>
<dt>Credential Provisioning</dt>
<dd style="margin-left: 8">
<br> In constrained environments it cannot be assumed that the client and the RS are part of a common key infrastructure. Therefore, the AS provisions credentials and associated information to allow mutual authentication between the client and the RS. The resulting security association between the client and the RS may then also be used to bind these credentials to the access tokens the client uses.  <br><br> </dd>
<dt>Proof-of-Possession</dt>
<dd style="margin-left: 8">
<br> The ACE framework, by default, implements proof-of-possession for access tokens, i.e., that the token holder can prove being a holder of the key bound to the token.  The binding is provided by the "cnf" claim <a href="#RFC8747" class="xref">[RFC8747]</a> indicating what key is used for proof-of-possession. If a client needs to submit a new access token, e.g., to obtain additional access rights, they can request that the AS binds this token to the same key as the previous one.  <br><br> </dd>
<dt>ACE Profiles</dt>
<dd style="margin-left: 8">
<br> The client or RS may be limited in the encodings or protocols it supports.  To support a variety of different deployment settings, specific interactions between client and RS are defined in an ACE profile.  In ACE framework the AS is expected to manage the matching of compatible profile choices between a client and an RS.  The AS informs the client of the selected profile using the "ace_profile" parameter in the token response.  </dd>
</dl>

<p> </p>
<p id="rfc.section.5.p.3">OAuth 2.0 requires the use of TLS both to protect the communication between AS and client when requesting an access token; between client and RS when accessing a resource and between AS and RS if introspection is used.  In constrained settings TLS is not always feasible, or desirable.  Nevertheless it is REQUIRED that the communications named above are encrypted, integrity protected and protected against message replay.  It is also REQUIRED that the communicating endpoints perform mutual authentication.  Furthermore it MUST be assured that responses are bound to the requests in the sense that the receiver of a response can be certain that the response actually belongs to a certain request.  Note that setting up such a secure communication may require some unprotected messages to be exchanged first (e.g. sending the token from the client to the RS).</p>
<p id="rfc.section.5.p.4">Profiles MUST specify a communication security protocol between client and RS that provides the features required above.  Profiles MUST specify a communication security protocol RECOMMENDED to be used between client and AS that provides the features required above.  Profiles MUST specify for introspection a communication security protocol RECOMMENDED to be used between RS and AS that provides the features required above.  These recommendations enable interoperability between different implementations without the need to define a new profile if the communication between C and AS, or between RS and AS, is protected with a different security protocol complying with the security requirements above.</p>
<p id="rfc.section.5.p.5">In OAuth 2.0 the communication with the Token and the Introspection endpoints at the AS is assumed to be via HTTP and may use Uri-query parameters.  When profiles of this framework use CoAP instead, it is REQUIRED to use of the following alternative instead of Uri-query parameters: The sender (client or RS) encodes the parameters of its request as a CBOR map and submits that map as the payload of the POST request.  The CBOR encoding for a number of  OAuth 2.0 parameters is specified in this document, if a profile needs to use other OAuth 2.0 parameters with CoAP it MUST specify their CBOR encoding.</p>
<p id="rfc.section.5.p.6">Profiles that use CBOR encoding of protocol message parameters at the outermost encoding layer MUST use the content format 'application/ace+cbor'.  If CoAP is used for communication, the Content-Format MUST be abbreviated with the ID: 19 (see <a href="#IANAcoapContentFormat" class="xref">Section 8.16</a>).</p>
<p id="rfc.section.5.p.7">The OAuth 2.0 AS uses a JSON structure in the payload of its responses both to client and RS.  If CoAP is used, it is REQUIRED to use CBOR <a href="#RFC8949" class="xref">[RFC8949]</a> instead of JSON.  Depending on the profile, the CBOR payload MAY be enclosed in a non-CBOR cryptographic wrapper.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#asDiscovery" id="asDiscovery">Discovering Authorization Servers</a>
</h1>
<p id="rfc.section.5.1.p.1">C must discover the AS in charge of RS to determine where to request the access token. To do so, C must 1. find out the AS URI to which the token request message must be sent and 2. MUST validate that the AS with this URI is authorized to provide access tokens for this RS.  </p>
<p id="rfc.section.5.1.p.2">In order to determine the AS URI, C MAY send an initial Unauthorized Resource Request message to RS.  RS then denies the request and sends the address of its AS back to C (see <a href="#rreq" class="xref">Section 5.2</a>). How C validates the AS authorization is not in scope for this document. C may, e.g., ask its owner if this AS is authorized for this RS. C may also use a mechanism that addresses both problems at once (e.g. by querying a dedicated secure service provided by the client owner) .</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#rreq" id="rreq">Unauthorized Resource Request Message</a>
</h1>
<p id="rfc.section.5.2.p.1">An Unauthorized Resource Request message is a request for any resource hosted by RS for which the client does not have authorization granted. RSes MUST treat any request for a protected resource as an Unauthorized Resource Request message when any of the following hold: </p>

<ul>
<li>The request has been received on an unsecured channel.</li>
<li>The RS has no valid access token for the sender of the request regarding the requested action on that resource.</li>
<li>The RS has a valid access token for the sender of the request, but that token does not authorize the requested action on the requested resource.</li>
</ul>

<p> </p>
<p id="rfc.section.5.2.p.2">Note: These conditions ensure that the RS can handle requests autonomously once access was granted and a secure channel has been established between C and RS. The authz-info endpoint, as part of the process for authorizing to protected resources, is not itself a protected resource and MUST NOT be protected as specified above (cf.  <a href="#tokenAuthInfoEndpoint" class="xref">Section 5.10.1</a>).</p>
<p id="rfc.section.5.2.p.3">Unauthorized Resource Request messages MUST be denied with an "unauthorized_client" error response. In this response, the Resource Server SHOULD provide proper "AS Request Creation Hints" to enable the client to request an access token from RS's AS as described in <a href="#asInfo" class="xref">Section 5.3</a>.</p>
<p id="rfc.section.5.2.p.4">The handling of all client requests (including unauthorized ones) by the RS is described in <a href="#requestC2RS" class="xref">Section 5.10.2</a>.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#asInfo" id="asInfo">AS Request Creation Hints</a>
</h1>
<p id="rfc.section.5.3.p.1">The "AS Request Creation Hints" message is sent by an RS as a response to an Unauthorized Resource Request message (see <a href="#rreq" class="xref">Section 5.2</a>) to help the sender of the Unauthorized Resource Request message acquire a valid access token. The "AS Request Creation Hints" message is a CBOR or JSON map, with an OPTIONAL element "AS" specifying an absolute URI (see Section 4.3 of <a href="#RFC3986" class="xref">[RFC3986]</a>) that identifies the appropriate AS for the RS.</p>
<p id="rfc.section.5.3.p.2">The message can also contain the following OPTIONAL parameters: </p>

<ul>
<li>A "audience" element contains an identifier the client should request at the AS, as suggested by the RS. With this parameter, when included in the access token request to the AS, the AS is able to restrict the use of access token to specific RSs. See <a href="#audience" class="xref">Section 6.9</a> for a discussion of this parameter.</li>
<li>A "kid" element containing the key identifier of a key used in an existing security association between the client and the RS.  The RS expects the client to request an access token bound to this key, in order to avoid having to re-establish the security association.</li>
<li>A "cnonce" element containing a client-nonce. See <a href="#cnonceParam" class="xref">Section 5.3.1</a>.</li>
<li>A "scope" element containing the suggested scope that the client should request towards the AS.</li>
</ul>
<div id="rfc.figure.2"></div>
<div id="fig:asinfo"></div>
<pre>
        /-----------+----------+---------------------\
        | Name      | CBOR Key | Value Type          |
        |-----------+----------+---------------------|
        | AS        |     1    | text string         |
        | kid       |     2    | byte string         |
        | audience  |     5    | text string         |
        | scope     |     9    | text or byte string |
        | cnonce    |    39    | byte string         |
        \-----------+----------+---------------------/
      </pre>
<p class="figure">Figure 2: AS Request Creation Hints</p>
<p><a href="#fig:asinfo" class="xref">Figure 2</a> summarizes the parameters that may be part of the "AS Request Creation Hints".  </p>
<p id="rfc.section.5.3.p.4">Note that the schema part of the AS parameter may need to be adapted to the security protocol that is used between the client and the AS. Thus the example AS value "coap://as.example.com/token" might need to be transformed to "coaps://as.example.com/token".  It is assumed that the client can determine the correct schema part on its own depending on the way it communicates with the AS.</p>
<p><a href="#fig:as-info-payload" class="xref">Figure 3</a> shows an example for an "AS Request Creation Hints" message payload using CBOR <a href="#RFC8949" class="xref">[RFC8949]</a> diagnostic notation, using the parameter names instead of the CBOR keys for better human readability.</p>
<div id="rfc.figure.3"></div>
<div id="fig:as-info-payload"></div>
<pre>
    4.01 Unauthorized
    Content-Format: application/ace+cbor
    Payload :
    {
     "AS" : "coaps://as.example.com/token",
     "audience" : "coaps://rs.example.com"
     "scope" : "rTempC",
     "cnonce" : h'e0a156bb3f'
    }
</pre>
<p class="figure">Figure 3: AS Request Creation Hints payload example</p>
<p id="rfc.section.5.3.p.6">In the example above, the response parameter "AS" points the receiver of this message to the URI "coaps://as.example.com/token" to request access tokens.  The RS sending this response uses an internal clock that is not synchronized with the clock of the AS.  Therefore, it can not reliably verify the expiration time of access tokens it receives.  To ensure a certain level of access token freshness nevertheless, the RS has included a <samp>cnonce</samp> parameter (see <a href="#cnonceParam" class="xref">Section 5.3.1</a>) in the response. (The hex-sequence of the cnonce parameter is encoded in CBOR-based notation in this example.)</p>
<p><a href="#fig:as-info-cbor" class="xref">Figure 4</a> illustrates the mandatory to use binary encoding of the message payload shown in <a href="#fig:as-info-payload" class="xref">Figure 3</a>.</p>
<div id="rfc.figure.4"></div>
<div id="fig:as-info-cbor"></div>
<pre>
a4                                   # map(4)
   01                                # unsigned(1) (=AS)
   78 1c                             # text(28)
      636f6170733a2f2f61732e657861
      6d706c652e636f6d2f746f6b656e   # "coaps://as.example.com/token"
   05                                # unsigned(5) (=audience)
   76                                # text(22)
      636f6170733a2f2f72732e657861
      6d706c652e636f6d               # "coaps://rs.example.com"
   09                                # unsigned(9) (=scope)
   66                                # text(6)
      7254656d7043                   # "rTempC"
   18 27                             # unsigned(39) (=cnonce)
   45                                # bytes(5)
      e0a156bb3f                     # 
      </pre>
<p class="figure">Figure 4: AS Request Creation Hints example encoded in CBOR</p>
<h1 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> <a href="#cnonceParam" id="cnonceParam">The Client-Nonce Parameter</a>
</h1>
<p id="rfc.section.5.3.1.p.1">If the RS does not synchronize its clock with the AS, it could be tricked into accepting old access tokens, that are either expired or have been compromised.  In order to ensure some level of token freshness in that case, the RS can use the "cnonce" (client-nonce) parameter.  The processing requirements for this parameter are as follows: </p>

<ul>
<li>An RS sending a "cnonce" parameter in an "AS Request Creation Hints" message MUST store information to validate that a given cnonce is fresh.  How this is implemented internally is out of scope for this specification.  Expiration of client-nonces should be based roughly on the time it would take a client to obtain an access token after receiving the "AS Request Creation Hints" message, with some allowance for unexpected delays.</li>
<li>A client receiving a "cnonce" parameter in an "AS Request Creation Hints" message MUST include this in the parameters when requesting an access token at the AS, using the "cnonce" parameter from <a href="#cnonceParamToken" class="xref">Section 5.8.4.4</a>.</li>
<li>If an AS grants an access token request containing a "cnonce" parameter, it MUST include this value in the access token, using the "cnonce" claim specified in <a href="#accessToken" class="xref">Section 5.10</a>.</li>
<li>An RS that is using the client-nonce mechanism and that receives an access token MUST verify that this token contains a cnonce claim, with a client-nonce value that is fresh according to the information stored at the first step above.  If the cnonce claim is not present or if the cnonce claim value is not fresh, the RS MUST discard the access token.  If this was an interaction with the authz-info endpoint the RS MUST also respond with an error message using a response code equivalent to the CoAP code 4.01 (Unauthorized).</li>
</ul>

<p> </p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#authorizationGrants" id="authorizationGrants">Authorization Grants</a>
</h1>
<p id="rfc.section.5.4.p.1">To request an access token, the client obtains authorization from the resource owner or uses its client credentials as a grant.  The authorization is expressed in the form of an authorization grant.</p>
<p id="rfc.section.5.4.p.2">The OAuth framework <a href="#RFC6749" class="xref">[RFC6749]</a> defines four grant types. The grant types can be split up into two groups, those granted on behalf of the resource owner (password, authorization code, implicit) and those for the client (client credentials). Further grant types have been added later, such as <a href="#RFC7521" class="xref">[RFC7521]</a> defining an assertion-based authorization grant.</p>
<p id="rfc.section.5.4.p.3">The grant type is selected depending on the use case.  In cases where the client acts on behalf of the resource owner, the authorization code grant is recommended.  If the client acts on behalf of the resource owner, but does not have any display or has very limited interaction possibilities, it is recommended to use the device code grant defined in <a href="#RFC8628" class="xref">[RFC8628]</a>.  In cases where the client acts autonomously the client credentials grant is recommended.</p>
<p id="rfc.section.5.4.p.4">For details on the different grant types, see section 1.3 of <a href="#RFC6749" class="xref">[RFC6749]</a>. The OAuth 2.0 framework provides an extension mechanism for defining additional grant types, so profiles of this framework MAY define additional grant types, if needed.</p>
<h1 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> <a href="#clientCredentials" id="clientCredentials">Client Credentials</a>
</h1>
<p id="rfc.section.5.5.p.1">Authentication of the client is mandatory independent of the grant type when requesting an access token from the token endpoint. In the case of the client credentials grant type, the authentication and grant coincide.</p>
<p id="rfc.section.5.5.p.2">Client registration and provisioning of client credentials to the client is out of scope for this specification.</p>
<p id="rfc.section.5.5.p.3">The OAuth framework defines one client credential type in section 2.3.1 of <a href="#RFC6749" class="xref">[RFC6749]</a>: client id and client secret. <a href="#I-D.erdtman-ace-rpcc" class="xref">[I-D.erdtman-ace-rpcc]</a> adds raw-public-key and pre-shared-key to the client credentials types.  Profiles of this framework MAY extend with an additional client credentials type using client certificates.</p>
<h1 id="rfc.section.5.6">
<a href="#rfc.section.5.6">5.6.</a> <a href="#ASAuthentication" id="ASAuthentication">AS Authentication</a>
</h1>
<p id="rfc.section.5.6.p.1">The client credential grant does not, by default, authenticate the AS that the client connects to. In classic OAuth, the AS is authenticated with a TLS server certificate.</p>
<p id="rfc.section.5.6.p.2">Profiles of this framework MUST specify how clients authenticate the AS and how communication security is implemented. By default, server side TLS certificates, as defined by OAuth 2.0, are required.</p>
<h1 id="rfc.section.5.7">
<a href="#rfc.section.5.7">5.7.</a> <a href="#authorizeEndpoint" id="authorizeEndpoint">The Authorization Endpoint</a>
</h1>
<p id="rfc.section.5.7.p.1">The OAuth 2.0 authorization endpoint is used to interact with the resource owner and obtain an authorization grant, in certain grant flows.  The primary use case for the ACE-OAuth framework is for machine-to-machine interactions that do not involve the resource owner in the authorization flow; therefore, this endpoint is out of scope here.  Future profiles may define constrained adaptation mechanisms for this endpoint as well.  Non-constrained clients interacting with constrained resource servers can use the specification in section 3.1 of <a href="#RFC6749" class="xref">[RFC6749]</a> and the attack countermeasures suggested in section 4.2 of <a href="#RFC6819" class="xref">[RFC6819]</a>.</p>
<h1 id="rfc.section.5.8">
<a href="#rfc.section.5.8">5.8.</a> <a href="#tokenEndpoint" id="tokenEndpoint">The Token Endpoint</a>
</h1>
<p id="rfc.section.5.8.p.1">In standard OAuth 2.0, the AS provides the token endpoint for submitting access token requests.  This framework extends the functionality of the token endpoint, giving the AS the possibility to help the client and RS to establish shared keys or to exchange their public keys.  Furthermore, this framework defines encodings using CBOR, as a substitute for JSON.</p>
<p id="rfc.section.5.8.p.2">The endpoint may also be exposed over HTTPS as in classical OAuth or even other transports.  A profile MUST define the details of the mapping between the fields described below, and these transports.  If HTTPS is used, the semantics of Sections 4.1.3 and 4.1.4 of the OAuth 2.0 specification MUST be followed (with additions as described below). If the CoAP is some other transport with CBOR payload format is supported, the semantics described in this section MUST be followed.</p>
<p id="rfc.section.5.8.p.3">For the AS to be able to issue a token, the client MUST be authenticated and present a valid grant for the scopes requested.  Profiles of this framework MUST specify how the AS authenticates the client and how the communication between client and AS is protected, fulfilling the requirements specified in <a href="#oauthProfile" class="xref">Section 5</a>.</p>
<p id="rfc.section.5.8.p.4">The default name of this endpoint in an url-path SHOULD be '/token'.  However, implementations are not required to use this name and can define their own instead.</p>
<p id="rfc.section.5.8.p.5">The figures of this section use CBOR diagnostic notation without the integer abbreviations for the parameters or their values for illustrative purposes. Note that implementations MUST use the integer abbreviations and the binary CBOR encoding, if the CBOR encoding is used.</p>
<h1 id="rfc.section.5.8.1">
<a href="#rfc.section.5.8.1">5.8.1.</a> <a href="#tokenRequest" id="tokenRequest">Client-to-AS Request</a>
</h1>
<p id="rfc.section.5.8.1.p.1">The client sends a POST request to the token endpoint at the AS. The profile MUST specify how the communication is protected.  The content of the request consists of the parameters specified in the relevant subsection of section 4 of the OAuth 2.0 specification <a href="#RFC6749" class="xref">[RFC6749]</a>, depending on the grant type, with the following exceptions and additions: </p>

<ul>
<li>The parameter "grant_type" is OPTIONAL in the context of this framework (as opposed to REQUIRED in RFC6749).  If that parameter is missing, the default value "client_credentials" is implied.</li>
<li>The "audience" parameter from <a href="#RFC8693" class="xref">[RFC8693]</a> is OPTIONAL to request an access token bound to a specific audience.</li>
<li>The "cnonce" parameter defined in <a href="#cnonceParamToken" class="xref">Section 5.8.4.4</a> is REQUIRED if the RS provided a client-nonce in the "AS Request Creation Hints" message <a href="#asInfo" class="xref">Section 5.3</a>
</li>
<li>The "scope" parameter MAY be encoded as a byte string instead of the string encoding specified in section 3.3 of <a href="#RFC6749" class="xref">[RFC6749]</a>, in order allow compact encoding of complex scopes.  The syntax of such a binary encoding is explicitly not specified here and left to profiles or applications. Note specifically that a binary encoded scope does not necessarily use the space character '0x20' to delimit scope-tokens.</li>
<li>The client can send an empty (null value) "ace_profile" parameter to indicate that it wants the AS to include the "ace_profile" parameter in the response.  See <a href="#paramProfile" class="xref">Section 5.8.4.3</a>.</li>
<li>A client MUST be able to use the parameters from <a href="#I-D.ietf-ace-oauth-params" class="xref">[I-D.ietf-ace-oauth-params]</a> in an access token request to the token endpoint and the AS MUST be able to process these additional parameters.</li>
</ul>
<p id="rfc.section.5.8.1.p.2">The default behavior, is that the AS generates a symmetric proof-of-possession key for the client. In order to use an asymmetric key pair or to re-use a key previously established with the RS, the client is supposed to use the "req_cnf" parameter from <a href="#I-D.ietf-ace-oauth-params" class="xref">[I-D.ietf-ace-oauth-params]</a>.  </p>
<p id="rfc.section.5.8.1.p.3">If CoAP is used then these parameters MUST be provided in a CBOR map, see <a href="#fig:cborTokenParameters" class="xref">Figure 12</a>.</p>
<p id="rfc.section.5.8.1.p.4">When HTTP is used as a transport then the client makes a request to the token endpoint, the parameters MUST be encoded as defined in Appendix B of <a href="#RFC6749" class="xref">[RFC6749]</a>.</p>
<p id="rfc.section.5.8.1.p.5">The following examples illustrate different types of requests for proof-of-possession tokens. </p>
<div id="rfc.figure.5"></div>
<div id="fig:symmATreq"></div>
<pre>
Header: POST (Code=0.02)
Uri-Host: "as.example.com"
Uri-Path: "token"
Content-Format: "application/ace+cbor"
Payload:
{
  "client_id" : "myclient",
  "audience" : "tempSensor4711"
}
        </pre>
<p class="figure">Figure 5: Example request for an access token bound to a      symmetric key.</p>
<p><a href="#fig:symmATreq" class="xref">Figure 5</a> shows a request for a token with a symmetric proof-of-possession key.  The content is displayed in CBOR diagnostic notation, without abbreviations for better readability.  </p>
<div id="rfc.figure.6"></div>
<div id="fig:asymmATreq"></div>
<pre>
Header: POST (Code=0.02)
Uri-Host: "as.example.com"
Uri-Path: "token"
OSCORE: 0x09, 0x05, 0x44, 0x6C
  (h=0, k=1, n=001, partialIV= 0x05, kid=[0x44, 0x6C])
Content-Format: "application/oscore"
Payload:
  0x44025d1 ... (full payload omitted for brevity) ... 68b3825e
  
Decrypted payload:
{
  "client_id" : "myclient",
  "req_cnf" : {
    "COSE_Key" : {
      "kty" : "EC",
      "kid" : h'11',
      "crv" : "P-256",
      "x" : b64'usWxHK2PmfnHKwXPS54m0kTcGJ90UiglWiGahtagnv8',
      "y" : b64'IBOL+C3BttVivg+lSreASjpkttcsz+1rb7btKLv8EX4'
    }
  }
}
        </pre>
<p class="figure">Figure 6: Example token request bound to an asymmetric key.</p>
<p><a href="#fig:asymmATreq" class="xref">Figure 6</a> shows a request for a token with an asymmetric proof-of-possession key.  Note that in this example OSCORE <a href="#RFC8613" class="xref">[RFC8613]</a> is used to provide object-security, therefore the Content-Format is "application/oscore" wrapping the "application/ace+cbor" type content.  The OSCORE option has a decoded interpretation appended in parentheses for the reader's convenience.  Also note that in this example the audience is implicitly known by both client and AS. Furthermore note that this example uses the "req_cnf" parameter from <a href="#I-D.ietf-ace-oauth-params" class="xref">[I-D.ietf-ace-oauth-params]</a>.  </p>
<div id="rfc.figure.7"></div>
<div id="fig:kidATreq"></div>
<pre>
Header: POST (Code=0.02)
Uri-Host: "as.example.com"
Uri-Path: "token"
Content-Format: "application/ace+cbor"
Payload:
{
  "client_id" : "myclient",
  "audience" : "valve424",
  "scope" : "read",
  "req_cnf" : {
    "kid" : b64'6kg0dXJM13U'
  }
}
       </pre>
<p class="figure">Figure 7: Example request for an access token bound to a      key reference.</p>
<p><a href="#fig:kidATreq" class="xref">Figure 7</a> shows a request for a token where a previously communicated proof-of-possession key is only referenced using the "req_cnf" parameter from <a href="#I-D.ietf-ace-oauth-params" class="xref">[I-D.ietf-ace-oauth-params]</a>.  </p>
<p id="rfc.section.5.8.1.p.9">Refresh tokens are typically not stored as securely as proof-of-possession keys in requesting clients.  Proof-of-possession based refresh token requests MUST NOT request different proof-of-possession keys or different audiences in token requests.  Refresh token requests can only use to request access tokens bound to the same proof-of-possession key and the same audience as access tokens issued in the initial token request.</p>
<h1 id="rfc.section.5.8.2">
<a href="#rfc.section.5.8.2">5.8.2.</a> <a href="#tokenResponse" id="tokenResponse">AS-to-Client Response</a>
</h1>
<p id="rfc.section.5.8.2.p.1">If the access token request has been successfully verified by the AS and the client is authorized to obtain an access token corresponding to its access token request, the AS sends a response with the response code equivalent to the CoAP response code 2.01 (Created).  If client request was invalid, or not authorized, the AS returns an error response as described in <a href="#errorsToken" class="xref">Section 5.8.3</a>.</p>
<p id="rfc.section.5.8.2.p.2">Note that the AS decides which token type and profile to use when issuing a successful response.  It is assumed that the AS has prior knowledge of the capabilities of the client and the RS (see <a href="#app:registration" class="xref">Appendix D</a>).  This prior knowledge may, for example, be set by the use of a dynamic client registration protocol exchange <a href="#RFC7591" class="xref">[RFC7591]</a>.  If the client has requested a specific proof-of-possession key using the "req_cnf" parameter from <a href="#I-D.ietf-ace-oauth-params" class="xref">[I-D.ietf-ace-oauth-params]</a>, this may also influence which profile the AS selects, as it needs to support the use of the key type requested the client.</p>
<p id="rfc.section.5.8.2.p.3">The content of the successful reply is the Access Information.  When using CoAP, the payload MUST be encoded as a CBOR map, when using HTTP the encoding is a JSON map as specified in section 5.1 of <a href="#RFC6749" class="xref">[RFC6749]</a>.  In both cases the parameters specified in Section 5.1 of <a href="#RFC6749" class="xref">[RFC6749]</a> are used, with the following additions and changes: </p>

<dl>
<dt>ace_profile:</dt>
<dd style="margin-left: 8">
<br> OPTIONAL unless the request included an empty ace_profile parameter in which case it is MANDATORY.  This indicates the profile that the client MUST use	towards the RS. See <a href="#paramProfile" class="xref">Section 5.8.4.3</a> for the formatting of this parameter.  If this parameter is absent, the AS assumes that the client implicitly knows which profile to use towards the RS.</dd>
<dt>token_type:</dt>
<dd style="margin-left: 8">
<br> This parameter is OPTIONAL, as opposed to 'required' in <a href="#RFC6749" class="xref">[RFC6749]</a>. By default implementations of this framework SHOULD assume that the token_type is "PoP".  If a specific use case requires another token_type (e.g., "Bearer") to be used then this parameter is REQUIRED.  </dd>
</dl>

<p> </p>
<p id="rfc.section.5.8.2.p.4">Furthermore <a href="#I-D.ietf-ace-oauth-params" class="xref">[I-D.ietf-ace-oauth-params]</a> defines additional parameters that the AS MUST be able to use when responding to a request to the token endpoint.</p>
<div id="rfc.figure.8"></div>
<div id="fig:rsinfo"></div>
<pre>
        /-------------------+-------------------------------\
        | Parameter name    | Specified in                  |
        |-------------------+-------------------------------|
        | access_token      |  RFC 6749                     |
        | token_type        |  RFC 6749                     |
        | expires_in        |  RFC 6749                     |
        | refresh_token     |  RFC 6749                     |
        | scope             |  RFC 6749                     |
        | state             |  RFC 6749                     |
        | error             |  RFC 6749                     |
        | error_description |  RFC 6749                     |
        | error_uri         |  RFC 6749                     |
        | ace_profile       | [this document]               |
        | cnf               | [I-D.ietf-ace-oauth-params]   |
        | rs_cnf            | [I-D.ietf-ace-oauth-params]   |
        \-------------------+-------------------------------/
      </pre>
<p class="figure">Figure 8: Access Information parameters</p>
<p><a href="#fig:rsinfo" class="xref">Figure 8</a> summarizes the parameters that can currently be part of the Access Information. Future extensions may define additional parameters.  </p>
<div id="rfc.figure.9"></div>
<div id="fig:symmATres"></div>
<pre>
Header: Created (Code=2.01)
Content-Format: "application/ace+cbor"
Payload:
{
  "access_token" : b64'SlAV32hkKG ...
   (remainder of CWT omitted for brevity;
   CWT contains COSE_Key in the "cnf" claim)',
  "ace_profile" : "coap_dtls",
  "expires_in" : "3600",
  "cnf" : {
    "COSE_Key" : {
      "kty" : "Symmetric",
      "kid" : b64'39Gqlw',
      "k" : b64'hJtXhkV8FJG+Onbc6mxCcQh'
    }
  }
}
      </pre>
<p class="figure">Figure 9: Example AS response with an access token bound to a      symmetric key.</p>
<p><a href="#fig:symmATres" class="xref">Figure 9</a> shows a response containing a token and a "cnf" parameter with a symmetric proof-of-possession key, which is defined in <a href="#I-D.ietf-ace-oauth-params" class="xref">[I-D.ietf-ace-oauth-params]</a>.  Note that the key identifier 'kid' is only used to simplify indexing and retrieving the key, and no assumptions should be made that it is unique in the domains of either the client or the RS.  </p>
<h1 id="rfc.section.5.8.3">
<a href="#rfc.section.5.8.3">5.8.3.</a> <a href="#errorsToken" id="errorsToken">Error Response</a>
</h1>
<div id="rfc.figure.10"></div>
<div id="fig:cborErrorCodes"></div>
<pre>
     /---------------------------+--------+--------------------------\
     |                           | CBOR   | Original                 |
     | Name                      | Values | Specification            |
     |---------------------------+--------+--------------------------|
     | invalid_request           |    1   | section 5.2 of [RFC6749] |
     | invalid_client            |    2   | section 5.2 of [RFC6749] |
     | invalid_grant             |    3   | section 5.2 of [RFC6749] |
     | unauthorized_client       |    4   | section 5.2 of [RFC6749] |
     | unsupported_grant_type    |    5   | section 5.2 of [RFC6749] |
     | invalid_scope             |    6   | section 5.2 of [RFC6749] |
     | unsupported_pop_key       |    7   | [this document]          |
     | incompatible_ace_profiles |    8   | [this document]          |
     \---------------------------+--------+--------------------------/
        </pre>
<p class="figure">Figure 10: CBOR abbreviations for common error codes</p>
<p id="rfc.section.5.8.3.p.1">The error responses for interactions with the AS are generally equivalent to the ones defined in Section 5.2 of <a href="#RFC6749" class="xref">[RFC6749]</a>, with the following exceptions: </p>

<ul>
<li>When using CoAP the payload MUST be encoded as a CBOR map, with the Content-Format "application/ace+cbor".  When using HTTP the payload is encoded in JSON as specified in section 5.2 of <a href="#RFC6749" class="xref">[RFC6749]</a>.</li>
<li>A response code equivalent to the CoAP code 4.00 (Bad Request) MUST be used for all error responses, except for invalid_client where a response code equivalent to the CoAP code 4.01 (Unauthorized) MAY be used under the same conditions as specified in Section 5.2 of <a href="#RFC6749" class="xref">[RFC6749]</a>.</li>
<li>The parameters "error", "error_description" and "error_uri" MUST be abbreviated using the codes specified in <a href="#fig:cborTokenParameters" class="xref">Figure 12</a>, when a CBOR encoding is used.</li>
<li>The error code (i.e., value of the "error" parameter) MUST be abbreviated as specified in <a href="#fig:cborErrorCodes" class="xref">Figure 10</a>, when a CBOR encoding is used.</li>
</ul>

<p> </p>
<p id="rfc.section.5.8.3.p.2">In addition to the error responses defined in OAuth 2.0, the following behavior MUST be implemented by the AS: </p>

<ul>
<li>If the client submits an asymmetric key in the token request that the RS cannot process, the AS MUST reject that request with a response code equivalent to the CoAP code 4.00 (Bad Request) including the error code "unsupported_pop_key" specified in <a href="#fig:cborErrorCodes" class="xref">Figure 10</a>.</li>
<li>If the client and the RS it has requested an access token for do not share a common profile, the AS MUST reject that request with a response code equivalent to the CoAP code 4.00 (Bad Request) including the error code "incompatible_ace_profiles" specified in <a href="#fig:cborErrorCodes" class="xref">Figure 10</a>.</li>
</ul>
<h1 id="rfc.section.5.8.4">
<a href="#rfc.section.5.8.4">5.8.4.</a> <a href="#tokenParams" id="tokenParams">Request and Response Parameters</a>
</h1>
<p id="rfc.section.5.8.4.p.1">This section provides more detail about the new parameters that can be used in access token requests and responses, as well as abbreviations for more compact encoding of existing parameters and common parameter values.</p>
<h1 id="rfc.section.5.8.4.1">
<a href="#rfc.section.5.8.4.1">5.8.4.1.</a> <a href="#paramGrantType" id="paramGrantType">Grant Type</a>
</h1>
<div id="rfc.figure.11"></div>
<div id="fig:grant_types"></div>
<pre>
        /--------------------+------------+------------------------\
        | Name               | CBOR Value | Original Specification |
        |--------------------+------------+------------------------|
        | password           |      0     |  s. 4.3.2 of [RFC6749] |
        | authorization_code |      1     |  s. 4.1.3 of [RFC6749] |
        | client_credentials |      2     |  s. 4.4.2 of [RFC6749] |
        | refresh_token      |      3     |  s. 6 of [RFC6749]     |
        \--------------------+------------+------------------------/
        </pre>
<p class="figure">Figure 11: CBOR abbreviations for common grant types </p>
<p id="rfc.section.5.8.4.1.p.1">The abbreviations specified in the registry defined in <a href="#IANAGrantTypeMappings" class="xref">Section 8.5</a> MUST be used in CBOR encodings instead of the string values defined in <a href="#RFC6749" class="xref">[RFC6749]</a>, if CBOR payloads are used.  </p>
<h1 id="rfc.section.5.8.4.2">
<a href="#rfc.section.5.8.4.2">5.8.4.2.</a> <a href="#paramTokenType" id="paramTokenType">Token Type</a>
</h1>
<p id="rfc.section.5.8.4.2.p.1">The "token_type" parameter, defined in section 5.1 of <a href="#RFC6749" class="xref">[RFC6749]</a>, allows the AS to indicate to the client which type of access token it is receiving (e.g., a bearer token). </p>
<p id="rfc.section.5.8.4.2.p.2">This document registers the new value "PoP" for the OAuth Access Token Types registry,  specifying a proof-of-possession token.  How the proof-of-possession by the client to the RS is performed MUST be specified by the profiles.</p>
<p id="rfc.section.5.8.4.2.p.3">The values in the "token_type" parameter MUST use the CBOR abbreviations defined in the registry specified by <a href="#IANATokenTypeMappings" class="xref">Section 8.7</a>, if a CBOR encoding is used. </p>
<p id="rfc.section.5.8.4.2.p.4">In this framework the "pop" value for the "token_type" parameter is the default. The AS may, however, provide a different value from those registered in <a href="#IANA.OAuthAccessTokenTypes" class="xref">[IANA.OAuthAccessTokenTypes]</a>.</p>
<h1 id="rfc.section.5.8.4.3">
<a href="#rfc.section.5.8.4.3">5.8.4.3.</a> <a href="#paramProfile" id="paramProfile">Profile</a>
</h1>
<p id="rfc.section.5.8.4.3.p.1">Profiles of this framework MUST define the communication protocol and the communication security protocol between the client and the RS.  The security protocol MUST provide encryption, integrity and replay protection. It MUST also provide a binding between requests and responses.  Furthermore profiles MUST define a list of allowed proof-of-possession methods, if they support proof-of-possession tokens.</p>
<p id="rfc.section.5.8.4.3.p.2">A profile MUST specify an identifier that MUST be used to uniquely identify itself in the "ace_profile" parameter. The textual representation of the profile identifier is intended for human readability and for JSON-based interactions, it MUST NOT be used for CBOR-based interactions.  Profiles MUST register their identifier in the registry defined in <a href="#IANAProfile" class="xref">Section 8.8</a>.  </p>
<p id="rfc.section.5.8.4.3.p.3">Profiles MAY define additional parameters for both the token request and the Access Information in the access token response in order to support negotiation or signaling of profile specific parameters.  </p>
<p id="rfc.section.5.8.4.3.p.4">Clients that want the AS to provide them with the "ace_profile" parameter in the access token response can indicate that by sending a ace_profile parameter with a null value for CBOR-based interactions, or an empty string if CBOR is not used, in the access token request.</p>
<h1 id="rfc.section.5.8.4.4">
<a href="#rfc.section.5.8.4.4">5.8.4.4.</a> <a href="#cnonceParamToken" id="cnonceParamToken">Client-Nonce</a>
</h1>
<p id="rfc.section.5.8.4.4.p.1">This parameter MUST be sent from the client to the AS, if it previously received a "cnonce" parameter in the "AS Request Creation Hints" <a href="#asInfo" class="xref">Section 5.3</a>.  The parameter is encoded as a byte string for CBOR-based interactions, and as a string (Base64 encoded binary) if CBOR is not used.  It MUST copy the value from the cnonce parameter in the "AS Request Creation Hints".</p>
<h1 id="rfc.section.5.8.5">
<a href="#rfc.section.5.8.5">5.8.5.</a> <a href="#tokenCborParams" id="tokenCborParams">Mapping Parameters to CBOR</a>
</h1>
<p id="rfc.section.5.8.5.p.1">If CBOR encoding is used, all OAuth parameters in access token requests and responses MUST be mapped to CBOR types as specified in the registry defined by <a href="#IANAOAuthParameterMappingsRegistry" class="xref">Section 8.10</a>, using the given integer abbreviation for the map keys.</p>
<p id="rfc.section.5.8.5.p.2">Note that we have aligned the abbreviations corresponding to claims with the abbreviations defined in <a href="#RFC8392" class="xref">[RFC8392]</a>.</p>
<p id="rfc.section.5.8.5.p.3">Note also that abbreviations from -24 to 23 have a 1 byte encoding size in CBOR. We have thus chosen to assign abbreviations in that range to parameters we expect to be used most frequently in constrained scenarios.</p>
<div id="rfc.figure.12"></div>
<div id="fig:cborTokenParameters"></div>
<pre>
  /-------------------+----------+---------------------+---------------\
  |                   |          |                     | Original      |
  | Name              | CBOR Key | Value Type          | Specification |
  |-------------------+----------+---------------------+---------------|
  | access_token      | 1        | byte string         | [RFC6749]     |
  | expires_in        | 2        | unsigned integer    | [RFC6749]     |
  | audience          | 5        | text string         | [RFC8693]     |
  | scope             | 9        | text or byte string | [RFC6749]     |
  | client_id         | 24       | text string         | [RFC6749]     |
  | client_secret     | 25       | byte string         | [RFC6749]     |
  | response_type     | 26       | text string         | [RFC6749]     |
  | redirect_uri      | 27       | text string         | [RFC6749]     |
  | state             | 28       | text string         | [RFC6749]     |
  | code              | 29       | byte string         | [RFC6749]     |
  | error             | 30       | integer             | [RFC6749]     |
  | error_description | 31       | text string         | [RFC6749]     |
  | error_uri         | 32       | text string         | [RFC6749]     |
  | grant_type        | 33       | unsigned integer    | [RFC6749]     |
  | token_type        | 34       | integer             | [RFC6749]     |
  | username          | 35       | text string         | [RFC6749]     |
  | password          | 36       | text string         | [RFC6749]     |
  | refresh_token     | 37       | byte string         | [RFC6749]     |
  | ace_profile       | 38       | integer             |[this document]|
  | cnonce            | 39       | byte string         |[this document]|
  \-------------------+----------+---------------------+---------------/
      </pre>
<p class="figure">Figure 12: CBOR mappings used in token requests and responses</p>
<p></p>
<h1 id="rfc.section.5.9">
<a href="#rfc.section.5.9">5.9.</a> <a href="#introspectionEndpoint" id="introspectionEndpoint">The Introspection Endpoint</a>
</h1>
<p id="rfc.section.5.9.p.1">Token introspection <a href="#RFC7662" class="xref">[RFC7662]</a> MAY be implemented by the AS, and the RS. When implemented, it MAY be used by the RS and to query the AS for metadata about a given token, e.g., validity or scope. Analogous to the protocol defined in <a href="#RFC7662" class="xref">[RFC7662]</a> for HTTP and JSON, this section defines adaptations to more constrained  environments using CBOR and leaving the choice of the application protocol to the profile.</p>
<p id="rfc.section.5.9.p.2">Communication between the requesting entity and the introspection endpoint at the AS MUST be integrity protected and encrypted.  The communication security protocol MUST also provide a binding between requests and responses.  Furthermore, the two interacting parties MUST perform mutual authentication.  Finally, the AS SHOULD verify that the requesting entity has the right to access introspection information about the provided token.  Profiles of this framework that support introspection MUST specify how authentication and communication security between the requesting entity and the AS is implemented.</p>
<p id="rfc.section.5.9.p.3">The default name of this endpoint in an url-path SHOULD be '/introspect'.  However, implementations are not required to use this name and can define their own instead.</p>
<p id="rfc.section.5.9.p.4">The figures of this section use the CBOR diagnostic notation without the integer abbreviations for the parameters and their values for better readability.  </p>
<h1 id="rfc.section.5.9.1">
<a href="#rfc.section.5.9.1">5.9.1.</a> <a href="#introReq" id="introReq">Introspection Request</a>
</h1>
<p id="rfc.section.5.9.1.p.1">The requesting entity sends a POST request to the introspection endpoint at the AS.  The profile MUST specify how the communication is protected.  If CoAP is used, the payload MUST be encoded as a CBOR map with a "token" entry containing the access token.  Further optional parameters representing additional context that is known by the requesting entity to aid the AS in its response MAY be included.</p>
<p id="rfc.section.5.9.1.p.2">For CoAP-based interaction, all messages MUST use the content type "application/ace+cbor". For HTTP the encoding defined in section 2.1 of <a href="#RFC7662" class="xref">[RFC7662]</a> is used.</p>
<p id="rfc.section.5.9.1.p.3">The same parameters are required and optional as in Section 2.1 of <a href="#RFC7662" class="xref">[RFC7662]</a>.</p>
<div id="rfc.figure.13"></div>
<div id="fig:introReq"></div>
<pre>
Header: POST (Code=0.02)
Uri-Host: "as.example.com"
Uri-Path: "introspect"
OSCORE: 0x09, 0x05, 0x25
Content-Format: "application/oscore"
Payload:
... COSE content ...
       </pre>
<p class="figure">Figure 13: Example introspection request.</p>
<div id="rfc.figure.14"></div>
<div id="fig:introReq-payl"></div>
<pre>
{
  "token" : b64'7gj0dXJQ43U',
  "token_type_hint" : "PoP"
}
       </pre>
<p class="figure">Figure 14: Decoded payload.</p>
<p id="rfc.section.5.9.1.p.4">For example, <a href="#fig:introReq" class="xref">Figure 13</a> shows an RS calling the token introspection endpoint at the AS to query about an OAuth 2.0 proof-of-possession token.  Note that object security based on OSCORE <a href="#RFC8613" class="xref">[RFC8613]</a> is assumed in this example, therefore the Content-Format is "application/oscore". <a href="#fig:introReq-payl" class="xref">Figure 14</a> shows the decoded payload.  </p>
<h1 id="rfc.section.5.9.2">
<a href="#rfc.section.5.9.2">5.9.2.</a> <a href="#introRes" id="introRes">Introspection Response</a>
</h1>
<p id="rfc.section.5.9.2.p.1">If the introspection request is authorized and successfully processed, the AS sends a response with the response code equivalent to the CoAP code 2.01 (Created).  If the introspection request was invalid, not authorized or couldn't be processed the AS returns an error response as described in <a href="#errorsIntro" class="xref">Section 5.9.3</a>.</p>
<p id="rfc.section.5.9.2.p.2">In a successful response, the AS encodes the response parameters in a map.  If CoAP is used, this MUST be encoded as a CBOR map, if HTTP is used the JSON encoding specified in section 2.2 of <a href="#RFC7662" class="xref">[RFC7662]</a> is used.  The map containing the response payload  includes the same required and optional parameters as in Section 2.2 of <a href="#RFC7662" class="xref">[RFC7662]</a> with the following additions: </p>

<dl>
<dt>ace_profile</dt>
<dd style="margin-left: 8">OPTIONAL.  This indicates the profile that the RS MUST use with the client.  See <a href="#paramProfile" class="xref">Section 5.8.4.3</a> for more details on the formatting of this parameter. If this parameter is absent, the AS assumes that the RS implicitly knows which profile to use towards the client.</dd>
<dt>cnonce</dt>
<dd style="margin-left: 8">OPTIONAL.  A client-nonce provided to the AS by the client.  The RS MUST verify that this corresponds to the client-nonce previously provided to the client in the "AS Request Creation Hints". See <a href="#asInfo" class="xref">Section 5.3</a> and <a href="#cnonceParamToken" class="xref">Section 5.8.4.4</a>.  </dd>
<dt>exi</dt>
<dd style="margin-left: 8">OPTIONAL. The "expires-in" claim associated to this access token.  See <a href="#tokenExpiration" class="xref">Section 5.10.3</a>.  </dd>
</dl>

<p> </p>
<p id="rfc.section.5.9.2.p.3">Furthermore <a href="#I-D.ietf-ace-oauth-params" class="xref">[I-D.ietf-ace-oauth-params]</a> defines more parameters that the AS MUST be able to use when responding to a request to the introspection endpoint.</p>
<div id="rfc.figure.15"></div>
<div id="fig:introRes"></div>
<pre>
Header: Created (Code=2.01)
Content-Format: "application/ace+cbor"
Payload:
{
  "active" : true,
  "scope" : "read",
  "ace_profile" : "coap_dtls",
  "cnf" : {
    "COSE_Key" : {
      "kty" : "Symmetric",
      "kid" : b64'39Gqlw',
      "k" : b64'hJtXhkV8FJG+Onbc6mxCcQh'
    }
  }
}
      </pre>
<p class="figure">Figure 15: Example introspection response.</p>
<p id="rfc.section.5.9.2.p.4">For example, <a href="#fig:introRes" class="xref">Figure 15</a> shows an AS response to the introspection request in <a href="#fig:introReq" class="xref">Figure 13</a>.  Note that this example contains the "cnf" parameter defined in <a href="#I-D.ietf-ace-oauth-params" class="xref">[I-D.ietf-ace-oauth-params]</a>.  </p>
<h1 id="rfc.section.5.9.3">
<a href="#rfc.section.5.9.3">5.9.3.</a> <a href="#errorsIntro" id="errorsIntro">Error Response</a>
</h1>
<p id="rfc.section.5.9.3.p.1">The error responses for CoAP-based interactions with the AS are equivalent to the ones for HTTP-based interactions as defined in Section 2.3 of <a href="#RFC7662" class="xref">[RFC7662]</a>, with the following differences: </p>

<ul>
<li>If content is sent and CoAP is used the payload MUST be encoded as a CBOR map and the Content-Format "application/ace+cbor" MUST be used.  For HTTP the encoding defined in section 2.3 of <a href="#RFC6749" class="xref">[RFC6749]</a> is used.</li>
<li>If the credentials used by the requesting entity (usually the RS) are invalid the AS MUST respond with the response code equivalent to the CoAP code 4.01 (Unauthorized) and use the required and optional parameters from Section 2.3 in <a href="#RFC7662" class="xref">[RFC7662]</a>.</li>
<li>If the requesting entity does not have the right to perform this introspection request, the AS MUST respond with a response code equivalent to the CoAP code 4.03 (Forbidden).  In this case no payload is returned.</li>
<li>The parameters "error", "error_description" and "error_uri" MUST be abbreviated using the codes specified in <a href="#fig:cborTokenParameters" class="xref">Figure 12</a>.</li>
<li>The error codes MUST be abbreviated using the codes specified in the registry defined by <a href="#IANAErrorCBORMappings" class="xref">Section 8.4</a>.</li>
</ul>

<p> </p>
<p id="rfc.section.5.9.3.p.2">Note that a properly formed and authorized query for an inactive or otherwise invalid token does not warrant an error response by this specification.  In these cases, the authorization server MUST instead respond with an introspection response with the "active" field set to "false".</p>
<h1 id="rfc.section.5.9.4">
<a href="#rfc.section.5.9.4">5.9.4.</a> <a href="#introParamsCbor" id="introParamsCbor">Mapping Introspection Parameters to CBOR</a>
</h1>
<p id="rfc.section.5.9.4.p.1">If CBOR is used, the introspection request and response parameters MUST be mapped to CBOR types as specified in the registry defined by <a href="#IANAIntrospectionEndpointCBORMappingsRegistry" class="xref">Section 8.12</a>, using the given integer abbreviation for the map key.</p>
<div id="rfc.figure.16"></div>
<div id="fig:cborIntrospectionParameters"></div>
<pre>
    /-------------------+----------+-------------------+---------------\
    |                   |          |                   | Original      |
    | Parameter name    | CBOR Key | Value Type        | Specification |
    |-------------------+----------+-------------------+---------------|
    | iss               | 1        | text string       | [RFC7662]     |
    | sub               | 2        | text string       | [RFC7662]     |
    | aud               | 3        | text string       | [RFC7662]     |
    | exp               | 4        | integer or        | [RFC7662]     |
    |                   |          |   floating-point  |               |
    |                   |          |   number          |               |
    | nbf               | 5        | integer or        | [RFC7662]     |
    |                   |          |   floating-point  |               |
    |                   |          |   number          |               |
    | iat               | 6        | integer or        | [RFC7662]     |
    |                   |          |   floating-point  |               |
    |                   |          |   number          |               |
    | scope             | 9        | text or           |               |
    |                   |          |   byte string     | [RFC7662]     |
    | active            | 10       | True or False     | [RFC7662]     |
    | token             | 11       | byte string       | [RFC7662]     |
    | client_id         | 24       | text string       | [RFC7662]     |
    | error             | 30       | integer           | [RFC7662]     |
    | error_description | 31       | text string       | [RFC7662]     |
    | error_uri         | 32       | text string       | [RFC7662]     |
    | token_type_hint   | 33       | text string       | [RFC7662]     |
    | token_type        | 34       | integer           | [RFC7662]     |
    | username          | 35       | text string       | [RFC7662]     |
    | ace_profile       | 38       | integer           |[this document]|
    | cnonce            | 39       | byte string       |[this document]| 
    | exi               | 40       | unsigned integer  |[this document]|
    \-------------------+----------+-------------------+---------------/
        </pre>
<p class="figure">Figure 16: CBOR Mappings to Token Introspection Parameters.</p>
<p id="rfc.section.5.9.4.p.2">Note that we have aligned abbreviations that correspond to a claim with the abbreviations defined in <a href="#RFC8392" class="xref">[RFC8392]</a> and the abbreviations of parameters with the same name from <a href="#tokenCborParams" class="xref">Section 5.8.5</a>.  </p>
<h1 id="rfc.section.5.10">
<a href="#rfc.section.5.10">5.10.</a> <a href="#accessToken" id="accessToken">The Access Token</a>
</h1>
<p id="rfc.section.5.10.p.1">In this framework the use of CBOR Web Token (CWT) as specified in <a href="#RFC8392" class="xref">[RFC8392]</a> is RECOMMENDED.  </p>
<p id="rfc.section.5.10.p.2">In order to facilitate offline processing of access tokens, this document uses the "cnf" claim from <a href="#RFC8747" class="xref">[RFC8747]</a> and the "scope" claim from <a href="#RFC8693" class="xref">[RFC8693]</a> for JWT- and CWT-encoded tokens.  In addition to string encoding specified for the "scope" claim, a binary encoding MAY be used.  The syntax of such an encoding is explicitly not specified here and left to profiles or applications, specifically note that a binary encoded scope does not necessarily use the space character '0x20' to delimit scope-tokens.</p>
<p id="rfc.section.5.10.p.3">If the AS needs to convey a hint to the RS about which profile it should use to communicate with the client, the AS MAY include an "ace_profile" claim in the access token, with the same syntax and semantics as defined in <a href="#paramProfile" class="xref">Section 5.8.4.3</a>.</p>
<p id="rfc.section.5.10.p.4">If the client submitted a client-nonce parameter in the access token request <a href="#cnonceParamToken" class="xref">Section 5.8.4.4</a>, the AS MUST include the value of this parameter in the "cnonce" claim specified here.  The "cnonce" claim uses binary encoding.</p>
<h1 id="rfc.section.5.10.1">
<a href="#rfc.section.5.10.1">5.10.1.</a> <a href="#tokenAuthInfoEndpoint" id="tokenAuthInfoEndpoint">The Authorization Information Endpoint</a>
</h1>
<p id="rfc.section.5.10.1.p.1">The access token, containing authorization information and information about the proof-of-possession method used by the client, needs to be transported to the RS so that the RS can authenticate and authorize the client request.</p>
<p id="rfc.section.5.10.1.p.2">This section defines a method for transporting the access token to the RS using a RESTful protocol such as CoAP. Profiles of this framework MAY define other methods for token transport.  </p>
<p id="rfc.section.5.10.1.p.3">The method consists of an authz-info endpoint, implemented by the RS.  A client using this method MUST make a POST request to the authz-info endpoint at the RS with the access token in the payload.  The CoAP Content-Format or HTTP Media Type MUST reflect the format of the token, e.g. application/cwt for CBOR Web Tokens, if no Content-Format or Media Type is defined for the token format, application/octet-stream MUST be used.</p>
<p id="rfc.section.5.10.1.p.4">The RS receiving the token MUST verify the validity of the token.  If the token is valid, the RS MUST respond to the POST request with a response code equivalent to CoAP's 2.01 (Created).  <a href="#verifyToken" class="xref">Section 5.10.1.1</a> outlines how an RS MUST proceed to verify the validity of an access token.</p>
<p id="rfc.section.5.10.1.p.5">The RS MUST be prepared to store at least one access token for future use. This is a difference to how access tokens are handled in OAuth 2.0, where the access token is typically sent along with each request, and therefore not stored at the RS.</p>
<p id="rfc.section.5.10.1.p.6">When using this framework it is RECOMMENDED that an RS stores only one token per proof-of-possession key.  This means that an additional token linked to the same key will supersede any existing token at the RS, by replacing the corresponding authorization information.  The reason is that this greatly simplifies (constrained) implementations, with respect to required storage and resolving a request to the applicable token.  The use of multiple access tokens for a single client increases the strain on the resource server as it must consider every access token and calculate the actual permissions of the client.  Also, tokens may contradict each other which may lead the server to enforce wrong permissions.  If one of the access tokens expires earlier than others, the resulting permissions may offer insufficient protection.  </p>
<p id="rfc.section.5.10.1.p.7">If the payload sent to the authz-info endpoint does not parse to a token, the RS MUST respond with a response code equivalent to the CoAP code 4.00 (Bad Request).</p>
<p id="rfc.section.5.10.1.p.8">The RS MAY make an introspection request to validate the token before responding to the POST request to the authz-info endpoint, e.g. if the token is an opaque reference.  Some transport protocols may provide a way to indicate that the RS is busy and the client should retry after an interval; this type of status update would be appropriate while the RS is waiting for an introspection response.  </p>
<p id="rfc.section.5.10.1.p.9">Profiles MUST specify whether the authz-info endpoint is protected, including whether error responses from this endpoint are protected.  Note that since the token contains information that allow the client and the RS to establish a security context in the first place, mutual authentication may not be possible at this point.</p>
<p id="rfc.section.5.10.1.p.10">The default name of this endpoint in an url-path is '/authz-info', however implementations are not required to use this name and can define their own instead.</p>
<h1 id="rfc.section.5.10.1.1">
<a href="#rfc.section.5.10.1.1">5.10.1.1.</a> <a href="#verifyToken" id="verifyToken">Verifying an Access Token</a>
</h1>
<p id="rfc.section.5.10.1.1.p.1">When an RS receives an access token, it MUST verify it before storing it. The details of token verification depends on various aspects, including the token encoding, the type of token, the security protection applied to the token, and the claims.  The token encoding matters since the security protection differs between the token encodings. For example, a CWT token uses COSE while a JWT token uses JOSE.  The type of token also has an influence on the verification procedure since tokens may be self-contained whereby token verification may happen locally at the RS while a token-by-reference requires further interaction with the authorization server, for example using token introspection, to obtain the claims associated with the token reference.  Self-contained tokens MUST, at least be integrity protected but they MAY also be encrypted.</p>
<p id="rfc.section.5.10.1.1.p.2">For self-contained tokens the RS MUST process the security protection of the token first, as specified by the respective token format.  For CWT the description can be found in <a href="#RFC8392" class="xref">[RFC8392]</a> and for JWT the relevant specification is <a href="#RFC7519" class="xref">[RFC7519]</a>.  This MUST include a verification that security protection (and thus the token) was generated by an AS that has the right to issue access tokens for this RS.</p>
<p id="rfc.section.5.10.1.1.p.3">In case the token is communicated by reference the RS needs to obtain the claims first. When the RS uses token introspection the relevant specification is <a href="#RFC7662" class="xref">[RFC7662]</a> with CoAP transport specified in <a href="#introspectionEndpoint" class="xref">Section 5.9</a>. </p>
<p id="rfc.section.5.10.1.1.p.4">Errors may happen during this initial processing stage: </p>

<ul>
<li>If the verification of the security wrapper fails, or the token was issued by an AS that does not have the right to issue tokens for the receiving RS, the RS MUST discard the token and, if this was an interaction with authz-info, return an error message with a response code equivalent to the CoAP code 4.01 (Unauthorized).</li>
<li>If the claims cannot be obtained the RS MUST discard the token and, in case of an interaction via the authz-info endpoint, return an error message with a response code equivalent to the CoAP code 4.00 (Bad Request).</li>
</ul>

<p> </p>
<p id="rfc.section.5.10.1.1.p.5">Next, the RS MUST verify claims, if present, contained in the access token. Errors are returned when claim checks fail, in the order of priority of this list: </p>

<dl>
<dt>iss</dt>
<dd style="margin-left: 8">The issuer claim (if present) must identify the AS that has produced the security protection for the access token.  If that is not the case the RS MUST discard the token.  If this was an interaction with authz-info, the RS MUST also respond with a response code equivalent to the CoAP code 4.01 (Unauthorized).</dd>
<dt>exp</dt>
<dd style="margin-left: 8">The expiration date must be in the future.  If that is not the case the RS MUST discard the token.  If this was an interaction with authz-info the RS MUST also respond with a response code equivalent to the CoAP code 4.01 (Unauthorized). Note that the RS has to terminate access rights to the protected resources at the time when the tokens expire. </dd>
<dt>aud</dt>
<dd style="margin-left: 8">The audience claim must refer to an audience that the RS identifies with. If that is not the case the RS MUST discard the token.  If this was an interaction with authz-info, the RS MUST also respond with a response code equivalent to the CoAP code 4.03 (Forbidden).</dd>
<dt>scope</dt>
<dd style="margin-left: 8">The RS must recognize value of the scope claim.  If that is not the case the RS MUST discard the token.  If this was an interaction with authz-info, the RS MUST also respond with a response code equivalent to the CoAP code 4.00 (Bad Request).  The RS MAY provide additional information in the error response, to clarify what went wrong.</dd>
</dl>
<p id="rfc.section.5.10.1.1.p.6">Additional processing may be needed for other claims in a way specific to a profile or the underlying application.</p>
<p id="rfc.section.5.10.1.1.p.7">Note that the Subject (sub) claim cannot always be verified when the token is submitted to the RS since the client may not have authenticated yet. Also note that a counter for the expires_in (exi) claim MUST be initialized when the RS first verifies this token.</p>
<p id="rfc.section.5.10.1.1.p.8">Also note that profiles of this framework may define access token transport mechanisms that do not allow for error responses.  Therefore the error messages specified here only apply if the token was sent to the authz-info endpoint.</p>
<p id="rfc.section.5.10.1.1.p.9">When sending error responses, the RS MAY use the error codes from Section 3.1 of <a href="#RFC6750" class="xref">[RFC6750]</a>, to provide additional details to the client.</p>
<h1 id="rfc.section.5.10.1.2">
<a href="#rfc.section.5.10.1.2">5.10.1.2.</a> <a href="#protAuthzInfo" id="protAuthzInfo">Protecting the Authorization       Information Endpoint</a>
</h1>
<p id="rfc.section.5.10.1.2.p.1">As this framework can be used in RESTful environments, it is important to make sure that attackers cannot perform unauthorized requests on the authz-info endpoints, other than submitting access tokens.</p>
<p id="rfc.section.5.10.1.2.p.2">Specifically it SHOULD NOT be possible to perform GET, DELETE or PUT on the authz-info endpoint.</p>
<p id="rfc.section.5.10.1.2.p.3">The RS SHOULD implement rate limiting measures to mitigate attacks aiming to overload the processing capacity of the RS by repeatedly submitting tokens. For CoAP-based communication the RS could use the mechanisms from <a href="#RFC8516" class="xref">[RFC8516]</a> to indicate that it is overloaded.</p>
<h1 id="rfc.section.5.10.2">
<a href="#rfc.section.5.10.2">5.10.2.</a> <a href="#requestC2RS" id="requestC2RS">Client Requests to the RS</a>
</h1>
<p id="rfc.section.5.10.2.p.1">Before sending a request to an RS, the client MUST verify that the keys used to protect this communication are still valid. See <a href="#keyExpiration" class="xref">Section 5.10.4</a> for details on how the client determines the validity of the keys used.</p>
<p id="rfc.section.5.10.2.p.2">If an RS receives a request from a client, and the target resource requires authorization, the RS MUST first verify that it has an access token that authorizes this request, and that the client has performed the proof-of-possession binding that token to the request.</p>
<p id="rfc.section.5.10.2.p.3">The response code MUST be 4.01 (Unauthorized) in case the client has not performed the proof-of-possession, or if RS has no valid access token for the client. If RS has an access token for the client but the token does not authorize access for the resource that was requested, RS MUST reject the request with a 4.03 (Forbidden). If RS has an access token for the client but it does not cover the action that was requested on the resource, RS MUST reject the request with a 4.05 (Method Not Allowed).</p>
<p id="rfc.section.5.10.2.p.4">Note: The use of the response codes 4.03 and 4.05 is intended to prevent infinite loops where a dumb client optimistically tries to access a requested resource with any access token received from AS. As malicious clients could pretend to be C to determine C's privileges, these detailed response codes must be used only when a certain level of security is already available which can be achieved only when the client is authenticated.</p>
<p id="rfc.section.5.10.2.p.5">Note: The RS MAY use introspection for timely validation of an access token, at the time when a request is presented.</p>
<p id="rfc.section.5.10.2.p.6">Note: Matching the claims of the access token (e.g., scope) to a specific request is application specific.</p>
<p id="rfc.section.5.10.2.p.7">If the request matches a valid token and the client has performed the proof-of-possession for that token, the RS continues to process the request as specified by the underlying application.</p>
<h1 id="rfc.section.5.10.3">
<a href="#rfc.section.5.10.3">5.10.3.</a> <a href="#tokenExpiration" id="tokenExpiration">Token Expiration</a>
</h1>
<p id="rfc.section.5.10.3.p.1">Depending on the capabilities of the RS, there are various ways in which it can verify the expiration of a received access token.  Here follows a list of the possibilities including what functionality they require of the RS.</p>
<p></p>

<ul>
<li>The token is a CWT and includes an "exp" claim and possibly the "nbf" claim.  The RS verifies these by comparing them to values from its internal clock as defined in <a href="#RFC7519" class="xref">[RFC7519]</a>.  In this case the RS's internal clock must reflect the current date and time, or at least be synchronized with the AS's clock.  How this clock synchronization would be performed is out of scope for this specification.</li>
<li>The RS verifies the validity of the token by performing an introspection request as specified in <a href="#introspectionEndpoint" class="xref">Section 5.9</a>.  This requires the RS to have a reliable network connection to the AS and to be able to handle two secure sessions in parallel (C to RS and RS to AS).</li>
<li>In order to support token expiration for devices that have no reliable way of synchronizing their internal clocks, this specification defines the following approach: The claim "exi" ("expires in") can be used, to provide the RS with the lifetime of the token in seconds from the time the RS first receives the token.  This mechanism only works for self-contained tokens, i.e. CWTs and JWTs. For CWTs this parameter is encoded as unsigned integer, while JWTs encode this as JSON number.</li>
<li>Processing this claim requires that the RS does the following: <ul>
<li>For each token the RS receives, that contains an "exi" claim: Keep track of the time it received that token and revisit that list regularly to expunge expired tokens.</li>
<li>Keep track of the identifiers of tokens containing the "exi" claim that have expired (in order to avoid accepting them again).  In order to avoid an unbounded memory usage growth, this MUST be implemented in the following way when the "exi" claim is used: <ul>
<li>When creating the token, the AS MUST add a 'cti' claim ( or 'jti' for JWTs) to the access token.  The value of this claim MUST be created as the binary representation of the concatenation of the identifier of the RS with a sequence number counting the tokens containing an 'exi' claim, issued by this AS for the RS.</li>
<li>The RS MUST store the highest sequence number of an expired token containing the "exi" claim that it has seen, and treat tokens with lower sequence numbers as expired.  Note that this could lead to discarding valid tokens with lower sequence numbers, if the AS where to issue tokens of different validity time for the same RS.  The assumption is that typically tokens in such a scenario would all have the same validity time.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p id="rfc.section.5.10.3.p.3">If a token that authorizes a long running request such as a CoAP Observe <a href="#RFC7641" class="xref">[RFC7641]</a> expires, the RS MUST send an error response with the response code equivalent to the CoAP code 4.01 (Unauthorized) to the client and then terminate processing the long running request.</p>
<h1 id="rfc.section.5.10.4">
<a href="#rfc.section.5.10.4">5.10.4.</a> <a href="#keyExpiration" id="keyExpiration">Key Expiration</a>
</h1>
<p id="rfc.section.5.10.4.p.1">The AS provides the client with key material that the RS uses. This can either be a common symmetric PoP-key, or an asymmetric key used by the RS to authenticate towards the client.  Since there is currently no expiration metadata associated to those keys, the client has no way of knowing if these keys are still valid.  This may lead to situations where the client sends requests containing sensitive information to the RS using a key that is expired and possibly in the hands of an attacker, or accepts responses from the RS that are not properly protected and could possibly have been forged by an attacker.  </p>
<p id="rfc.section.5.10.4.p.2">In order to prevent this, the client must assume that those keys are only valid as long as the related access token is.  Since the access token is opaque to the client, one of the following methods MUST be used to inform the client about the validity of an access token: </p>

<ul>
<li>The client knows a default validity time for all tokens it is using (i.e. how long a token is valid after being issued).  This information could be provisioned to the client when it is registered at the AS, or published by the AS in a way that the client can query.</li>
<li>The AS informs the client about the token validity using the "expires_in" parameter in the Access Information.</li>
</ul>

<p> </p>
<p id="rfc.section.5.10.4.p.3">A client that is not able to obtain information about the expiration of a token MUST NOT use this token.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#security" id="security">Security Considerations</a>
</h1>
<p id="rfc.section.6.p.1">Security considerations applicable to authentication and authorization in RESTful environments provided in OAuth 2.0 <a href="#RFC6749" class="xref">[RFC6749]</a> apply to this work.  Furthermore <a href="#RFC6819" class="xref">[RFC6819]</a> provides additional security considerations for OAuth which apply to IoT deployments as well.  If the introspection endpoint is used, the security considerations from <a href="#RFC7662" class="xref">[RFC7662]</a> also apply.</p>
<p id="rfc.section.6.p.2">The following subsections address issues specific to this document and it's use in constrained environments.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#tokenProtection" id="tokenProtection">Protecting Tokens</a>
</h1>
<p id="rfc.section.6.1.p.1">A large range of threats can be mitigated by protecting the contents of the access token by using a digital signature or a keyed message digest (MAC) or an Authenticated Encryption with Associated Data (AEAD) algorithm.  Consequently, the token integrity protection MUST be applied to prevent the token from being modified, particularly since it contains a reference to the symmetric key or the asymmetric key used for proof-of-possession.  If the access token contains the symmetric key, this symmetric key MUST be encrypted by the authorization server so that only the resource server can decrypt it.  Note that using an AEAD algorithm is preferable over using a MAC unless the token needs to be publicly readable.</p>
<p id="rfc.section.6.1.p.2">If the token is intended for multiple recipients (i.e. an audience that is a group), integrity protection of the token with a symmetric key, shared between the AS and the recipients, is not sufficient, since any of the recipients could modify the token undetected by the other recipients.  Therefore a token with a multi-recipient audience MUST be protected with an asymmetric signature.  </p>
<p id="rfc.section.6.1.p.3">It is important for the authorization server to include the identity of the intended recipient (the audience), typically a single resource server (or a list of resource servers), in the token.  The same shared secret MUST NOT be used as proof-of-possession key with multiple resource servers since the benefit from using the proof-of-possession concept is then significantly reduced.</p>
<p id="rfc.section.6.1.p.4">If clients are capable of doing so, they should frequently request fresh access tokens, as this allows the AS to keep the lifetime of the tokens short. This allows the AS to use shorter proof-of-possession key sizes, which translate to a performance benefit for the client and for the resource server.  Shorter keys also lead to shorter messages (particularly with asymmetric keying material).</p>
<p id="rfc.section.6.1.p.5">When authorization servers bind symmetric keys to access tokens, they SHOULD scope these access tokens to a specific permission.</p>
<p id="rfc.section.6.1.p.6">In certain situations it may be necessary to revoke an access token that is still valid.  Client-initiated revocation is specified in <a href="#RFC7009" class="xref">[RFC7009]</a> for OAuth 2.0.  Other revocation mechanisms are currently not specified, as the underlying assumption in OAuth is that access tokens are issued with a relatively short lifetime.  This may not hold true for disconnected constrained devices, needing access tokens with relatively long lifetimes, and would therefore necessitate further standardization work that is out of scope for this document.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#commSec" id="commSec">Communication Security</a>
</h1>
<p id="rfc.section.6.2.p.1">Communication with the authorization server MUST use confidentiality protection.  This step is extremely important since the client or the RS may obtain the proof-of-possession key from the authorization server for use with a specific access token.  Not using confidentiality protection exposes this secret (and the access token) to an eavesdropper thereby completely negating proof-of-possession security.  The requirements for communication security of profiles are specified in <a href="#oauthProfile" class="xref">Section 5</a>.</p>
<p id="rfc.section.6.2.p.2">Additional protection for the access token can be applied by encrypting it, for example encryption of CWTs is specified in Section 5.1 of <a href="#RFC8392" class="xref">[RFC8392]</a>.  Such additional protection can be necessary if the token is later transferred over an insecure connection (e.g. when it is sent to the authz-info endpoint).</p>
<p id="rfc.section.6.2.p.3">Care must by taken by developers to prevent leakage of the PoP credentials (i.e., the private key or the symmetric key).  An adversary in possession of the PoP credentials bound to the access token will be able to impersonate the client.  Be aware that this is a real risk with many constrained environments, since adversaries may get physical access to the devices and can therefore use physical extraction techniques to gain access to memory contents.  This risk can be mitigated to some extent by making sure that keys are refreshed frequently, by using software isolation techniques and by using hardware security.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#keys" id="keys">Long-Term Credentials</a>
</h1>
<p id="rfc.section.6.3.p.1">Both clients and RSs have long-term credentials that are used to secure communications, and authenticate to the AS.  These credentials need to be protected against unauthorized access.  In constrained devices, deployed in publicly accessible places, such protection can be difficult to achieve without specialized hardware (e.g. secure key storage memory).</p>
<p id="rfc.section.6.3.p.2">If credentials are lost or compromised, the operator of the affected devices needs to have procedures to invalidate any access these credentials give and to revoke tokens linked to such credentials.  The loss of a credential linked to a specific device MUST NOT lead to a compromise of other credentials not linked to that device, therefore secret keys used for authentication MUST NOT be shared between more than two parties.</p>
<p id="rfc.section.6.3.p.3">Operators of clients or RS SHOULD have procedures in place to replace credentials that are suspected to have been compromised or that have been lost.</p>
<p id="rfc.section.6.3.p.4">Operators also SHOULD have procedures for decommissioning devices, that include securely erasing credentials and other security critical material in the devices being decommissioned.</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#unprotected-as-information" id="unprotected-as-information">Unprotected AS Request Creation Hints</a>
</h1>
<p id="rfc.section.6.4.p.1">Initially, no secure channel exists to protect the communication between C and RS. Thus, C cannot determine if the "AS Request Creation Hints" contained in an unprotected response from RS to an unauthorized request (see <a href="#asInfo" class="xref">Section 5.3</a>) are authentic. C therefore MUST determine if an AS is authorized to provide access tokens for a certain RS. How this determination is implemented is out of scope for this document and left to the applications.</p>
<h1 id="rfc.section.6.5">
<a href="#rfc.section.6.5">6.5.</a> <a href="#minimalCommSecReq" id="minimalCommSecReq">Minimal Security Requirements        for Communication</a>
</h1>
<p id="rfc.section.6.5.p.1">This section summarizes the minimal requirements for the communication security of the different protocol interactions.  </p>

<dl>
<dt>C-AS</dt>
<dd style="margin-left: 8">All communication between the client and the Authorization Server MUST be encrypted, integrity and replay protected. Furthermore responses from the AS to the client MUST be bound to the client's request to avoid attacks where the attacker swaps the intended response for an older one valid for a previous request.  This requires that the client and the Authorization Server have previously exchanged either a shared secret or their public keys in order to negotiate a secure communication. Furthermore the client MUST be able to determine whether an AS has the authority to issue access tokens for a certain RS.  This can for example be done through pre-configured lists, or through an online lookup mechanism that in turn also must be secured.  </dd>
<dt>RS-AS</dt>
<dd style="margin-left: 8">The communication between the Resource Server and the Authorization Server via the introspection endpoint MUST be encrypted, integrity and replay protected. Furthermore responses from the AS to the RS MUST be bound to the RS's request.  This requires that the RS and the Authorization Server have previously exchanged either a shared secret, or their public keys in order to negotiate a secure communication. Furthermore the RS MUST be able to determine whether an AS has the authority to issue access tokens itself.  This is usually configured out of band, but could also be performed through an online lookup mechanism provided that it is also secured in the same way.</dd>
<dt>C-RS</dt>
<dd style="margin-left: 8">The initial communication between the client and the Resource Server can not be secured in general, since the RS is not in possession of on access token for that client, which would carry the necessary parameters.  If both parties support DTLS without client authentication it is RECOMMEND to use this mechanism for protecting the initial communication.  After the client has successfully transmitted the access token to the RS, a secure communication protocol MUST be established between client and RS for the actual resource request.  This protocol MUST provide confidentiality, integrity and replay protection as well as a binding between requests and responses.  This requires that the client learned either the RS's public key or received a symmetric proof-of-possession key bound to the access token from the AS.  The RS must have learned either the client's public key or a shared symmetric key from the claims in the token or an introspection request.  Since ACE does not provide profile negotiation between C and RS, the client MUST have learned what profile the RS supports (e.g. from the AS or pre-configured) and initiate the communication accordingly.</dd>
</dl>
<h1 id="rfc.section.6.6">
<a href="#rfc.section.6.6">6.6.</a> <a href="#nonce" id="nonce">Token Freshness and Expiration</a>
</h1>
<p id="rfc.section.6.6.p.1">An RS that is offline faces the problem of clock drift. Since it cannot synchronize its clock with the AS, it may be tricked into accepting old access tokens that are no longer valid or have been compromised.  In order to prevent this, an RS may use the nonce-based mechanism (cnonce) defined in <a href="#asInfo" class="xref">Section 5.3</a> to ensure freshness of an	Access Token subsequently presented to this RS.</p>
<p id="rfc.section.6.6.p.2">Another problem with clock drift is that evaluating the standard token expiration claim "exp" can give unpredictable results.  </p>
<p id="rfc.section.6.6.p.3">Acceptable ranges of clock drift are highly dependent on the concrete application.  Important factors are how long access tokens are valid, and how critical timely expiration of access token is.</p>
<p id="rfc.section.6.6.p.4">The expiration mechanism implemented by the "exi" claim, based on the first time the RS sees the token was defined to provide a more predictable alternative.  The "exi" approach has some drawbacks that need to be considered: </p>

<ul class="empty">
<li>A malicious client may hold back tokens with the "exi" claim in order to prolong their lifespan.</li>
<li>If an RS loses state (e.g. due to an unscheduled reboot), it may lose the current values of counters tracking the "exi" claims of tokens it is storing.</li>
</ul>

<p> The first drawback is inherent to the deployment scenario and the "exi" solution.  It can therefore not be mitigated without requiring the RS be online at times.  The second drawback can be mitigated by regularly storing the value of "exi" counters to persistent memory.</p>
<h1 id="rfc.section.6.7">
<a href="#rfc.section.6.7">6.7.</a> <a href="#mixnmatch" id="mixnmatch">Combining Profiles</a>
</h1>
<p id="rfc.section.6.7.p.1">There may be use cases where different transport and security protocols are allowed for the different interactions, and, if that is not explicitly covered by an existing profile, it corresponds to combining profiles into a new one.  For example, a new profile could specify that a previously-defined MQTT-TLS profile is used between the client and the RS in combination with a previously-defined CoAP-DTLS profile for interactions between the client and the AS. The new profile that combines existing profiles MUST specify how the existing profiles' security properties are achieved. Any profile therefore MUST clearly specify its security requirements and MUST document if its security depends on the combination of various protocol interactions.</p>
<h1 id="rfc.section.6.8">
<a href="#rfc.section.6.8">6.8.</a> <a href="#infoLeak" id="infoLeak">Unprotected Information</a>
</h1>
<p id="rfc.section.6.8.p.1">Communication with the authz-info endpoint, as well as the various error responses defined in this framework, all potentially include sending information over an unprotected channel.  These messages may leak information to an adversary, or may be manipulated by active attackers to induce incorrect behavior.  For example	error responses for requests to the Authorization Information endpoint can reveal information about an otherwise opaque access token to an adversary who has intercepted this token.</p>
<p id="rfc.section.6.8.p.2">As far as error messages are concerned, this framework is written under the assumption that, in general, the benefits of detailed error messages outweigh the risk due to information leakage. For particular use cases, where this assessment does not apply, detailed error messages can be replaced by more generic ones.</p>
<p id="rfc.section.6.8.p.3">In some scenarios it may be possible to protect the communication with the authz-info endpoint (e.g. through DTLS with only server-side authentication). In cases where this is not possible, it is RECOMMENDED to use encrypted CWTs or tokens that are opaque references and need to be subjected to introspection by the RS.</p>
<p id="rfc.section.6.8.p.4">If the initial unauthorized resource request message (see <a href="#rreq" class="xref">Section 5.2</a>) is used, the client MUST make sure that it is not sending sensitive content in this request. While GET and DELETE requests only reveal the target URI of the resource, POST and PUT requests would reveal the whole payload of the intended operation.</p>
<p id="rfc.section.6.8.p.5">Since the client is not authenticated at the point when it is submitting an access token to the authz-info endpoint, attackers may be pretending to be a client and trying to trick an RS to use an obsolete profile that in turn specifies a vulnerable security mechanism via the authz-info endpoint.  Such an attack would require a valid access token containing an "ace_profile" claim requesting the use of said obsolete profile.  Resource Owners should update the configuration of their RS's to prevent them from using such obsolete profiles.</p>
<h1 id="rfc.section.6.9">
<a href="#rfc.section.6.9">6.9.</a> <a href="#audience" id="audience">Identifying Audiences</a>
</h1>
<p id="rfc.section.6.9.p.1">The audience claim as defined in <a href="#RFC7519" class="xref">[RFC7519]</a> and the equivalent "audience" parameter from <a href="#RFC8693" class="xref">[RFC8693]</a> are intentionally vague on how to match the audience value to a specific RS.  This is intended to allow application specific semantics to be used.  This section attempts to give some general guidance for the use of audiences in constrained environments.</p>
<p id="rfc.section.6.9.p.2">URLs are not a good way of identifying mobile devices that can switch networks and thus be associated with new URLs.  If the audience represents a single RS, and asymmetric keys are used, the RS can be uniquely identified by a hash of its public key.  If this approach is used it is RECOMMENDED to apply the procedure from section 3 of <a href="#RFC6920" class="xref">[RFC6920]</a>.</p>
<p id="rfc.section.6.9.p.3">If the audience addresses a group of resource servers, the mapping of group identifier to individual RS has to be provisioned to each RS before the group-audience is usable.  Managing dynamic groups could be an issue, if any RS is not always reachable when the groups' memberships change. Furthermore, issuing access tokens bound to symmetric proof-of-possession keys that apply to a group-audience is problematic, as an RS that is in possession of the access token can impersonate the client towards the other RSs that are part of the group.  It is therefore NOT RECOMMENDED to issue access tokens bound to a group audience and symmetric proof-of possession keys.</p>
<p id="rfc.section.6.9.p.4">Even the client must be able to determine the correct values to put into the "audience" parameter, in order to obtain a token for the intended RS.  Errors in this process can lead to the client inadvertently obtaining a token for the wrong RS.  The correct values for "audience" can either be provisioned to the client as part of its configuration, or dynamically looked up by the client in some directory. In the latter case the integrity and	correctness of the directory data must be assured.  Note that the "audience" hint provided by the RS as part of the "AS Request Creation Hints" <a href="#asInfo" class="xref">Section 5.3</a> is not typically source authenticated and integrity protected, and should therefore not be treated a trusted value.</p>
<h1 id="rfc.section.6.10">
<a href="#rfc.section.6.10">6.10.</a> <a href="#introDos" id="introDos">Denial of Service Against or with      Introspection</a>
</h1>
<p id="rfc.section.6.10.p.1">The optional introspection mechanism provided by OAuth and supported in the ACE framework allows for two types of attacks that need to be considered by implementers.</p>
<p id="rfc.section.6.10.p.2">First, an attacker could perform a denial of service attack against the introspection endpoint at the AS in order to prevent validation of access tokens.  To maintain the security of the system, an RS that is configured to use introspection MUST NOT allow access based on a token for which it couldn't reach the introspection endpoint.</p>
<p id="rfc.section.6.10.p.3">Second, an attacker could use the fact that an RS performs introspection to perform a denial of service attack against that RS by repeatedly sending tokens to its authz-info endpoint that require an introspection call. RS can mitigate such attacks by implementing rate limits on how many introspection requests they perform in a given time interval for a certain client IP address submitting tokens to /authz-info.  When that limit has been reached, incoming requests from that address are rejected for a certain	amount of time.  A general rate limit on the introspection requests should also be considered, to mitigate distributed attacks.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#privacy" id="privacy">Privacy Considerations</a>
</h1>
<p id="rfc.section.7.p.1">Implementers and users should be aware of the privacy implications of the different possible deployments of this framework.</p>
<p id="rfc.section.7.p.2">The AS is in a very central position and can potentially learn sensitive information about the clients requesting access tokens.  If the client credentials grant is used, the AS can track what kind of access the client intends to perform.  With other grants this can be prevented by the Resource Owner.  To do so, the resource owner needs to bind the grants it issues to anonymous, ephemeral credentials that do not allow the AS to link different grants and thus different access token requests by the same client.</p>
<p id="rfc.section.7.p.3">The claims contained in a token can reveal privacy sensitive information about the client and the RS to any party having access to them (whether by processing the content of a self-contained token or by introspection).  The AS SHOULD be configured to minimize the information about clients and RSs disclosed in the tokens it issues.</p>
<p id="rfc.section.7.p.4">If tokens are only integrity protected and not encrypted, they may reveal information to attackers listening on the wire, or able to acquire the access tokens in some other way.  In the case of CWTs the token may, e.g., reveal the audience, the scope and the confirmation method used by the client.  The latter may reveal the identity of the device or application running the client.  This may be linkable to the identity of the person using the client (if there is a person and not a machine-to-machine interaction).</p>
<p id="rfc.section.7.p.5">Clients using asymmetric keys for proof-of-possession should be aware of the consequences of using the same key pair for proof-of-possession towards different RSs.  A set of colluding RSs or an attacker able to obtain the access tokens will be able to link the requests, or even to determine the client's identity.</p>
<p id="rfc.section.7.p.6">An unprotected response to an unauthorized request (see <a href="#asInfo" class="xref">Section 5.3</a>) may disclose information about RS and/or its existing relationship with C. It is advisable to include as little information as possible in an unencrypted response. Even the absolute URI of the AS may reveal sensitive information about the service that RS provides. Developers must ensure that the RS does not disclose information that has an impact on the privacy of the stakeholders in the "AS Request Creation Hints". They may choose to use a different mechanism for the discovery of the AS if necessary. If means of encrypting communication between C and RS already exist, more detailed information may be included with an error response to provide C with sufficient information to react on that particular error.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#iana" id="iana">IANA Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This document creates several registries with a registration policy of "Expert Review"; guidelines to the experts are given in <a href="#IANAinstructions" class="xref">Section 8.17</a>.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#IANAASInformation" id="IANAASInformation">ACE Authorization Server Request Creation Hints</a>
</h1>
<p id="rfc.section.8.1.p.1">This specification establishes the IANA "ACE Authorization Server Request Creation Hints" registry. The registry has been created to use the "Expert Review" registration procedure <a href="#RFC8126" class="xref">[RFC8126]</a>.  It should be noted that, in addition to the expert review, some portions of the registry require a specification, potentially a Standards Track RFC, be supplied as well.</p>
<p id="rfc.section.8.1.p.2">The columns of the registry are: </p>

<dl>
<dt>Name</dt>
<dd style="margin-left: 8">The name of the parameter</dd>
<dt>CBOR Key</dt>
<dd style="margin-left: 8">CBOR map key for the parameter.  Different ranges of values use different registration policies <a href="#RFC8126" class="xref">[RFC8126]</a>.  Integer values from -256 to 255 are designated as Standards Action.  Integer values from -65536 to -257 and from 256 to 65535 are designated as Specification Required.  Integer values greater than 65535 are designated as Expert Review.  Integer values less than -65536 are marked as Private Use.</dd>
<dt>Value Type</dt>
<dd style="margin-left: 8">The CBOR data types allowable for the values of this parameter.</dd>
<dt>Reference</dt>
<dd style="margin-left: 8">This contains a pointer to the public specification of the request creation hint abbreviation, if one exists.</dd>
</dl>
<p id="rfc.section.8.1.p.3">This registry will be initially populated by the values in <a href="#fig:asinfo" class="xref">Figure 2</a>. The Reference column for all of these entries will be this document.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#IANAcoreRT" id="IANAcoreRT">CoRE Resource Type Registry</a>
</h1>
<p id="rfc.section.8.2.p.1">IANA is requested to register a new Resource Type (rt=) Link Target Attribute in the "Resource Type (rt=) Link Target Attribute Values" subregistry under the "Constrained RESTful Environments (CoRE) Parameters" <a href="#IANA.CoreParameters" class="xref">[IANA.CoreParameters]</a> registry:</p>
<p></p>

<ul>
<li>Value: <samp>ace.ai</samp>
</li>
<li>Description: ACE-OAuth authz-info endpoint resource.</li>
<li>Reference: [this document]</li>
</ul>
<p id="rfc.section.8.2.p.3">Specific ACE-OAuth profiles can use this common resource type for defining their profile-specific discovery processes.</p>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> <a href="#IANAOAuthErrorCodes" id="IANAOAuthErrorCodes">OAuth Extensions Error Registration</a>
</h1>
<p id="rfc.section.8.3.p.1">This specification registers the following error values in the OAuth Extensions Error registry <a href="#IANA.OAuthExtensionsErrorRegistry" class="xref">[IANA.OAuthExtensionsErrorRegistry]</a>.</p>
<p></p>

<ul>
<li>Error name: <samp>unsupported_pop_key</samp>
</li>
<li>Error usage location: token error response</li>
<li>Related protocol extension: [this document]</li>
<li>Change Controller: IETF</li>
<li>Specification document(s): <a href="#errorsToken" class="xref">Section 5.8.3</a> of [this document]</li>
</ul>
<p></p>

<ul>
<li>Error name: <samp>incompatible_ace_profiles</samp>
</li>
<li>Error usage location: token error response</li>
<li>Related protocol extension: [this document]</li>
<li>Change Controller: IETF</li>
<li>Specification document(s): <a href="#errorsToken" class="xref">Section 5.8.3</a> of [this document]</li>
</ul>
<h1 id="rfc.section.8.4">
<a href="#rfc.section.8.4">8.4.</a> <a href="#IANAErrorCBORMappings" id="IANAErrorCBORMappings">OAuth Error Code CBOR Mappings Registry</a>
</h1>
<p id="rfc.section.8.4.p.1">This specification establishes the IANA "OAuth Error Code CBOR Mappings" registry.  The registry has been created to use the "Expert Review" registration procedure <a href="#RFC8126" class="xref">[RFC8126]</a>, except for the value range designated for private use.</p>
<p id="rfc.section.8.4.p.2">The columns of the registry are: </p>

<dl>
<dt>Name</dt>
<dd style="margin-left: 8">The OAuth Error Code name, refers to the name in Section 5.2. of <a href="#RFC6749" class="xref">[RFC6749]</a>, e.g., "invalid_request".</dd>
<dt>CBOR Value</dt>
<dd style="margin-left: 8">CBOR abbreviation for this error code.  Integer values less than -65536 are marked as "Private Use", all other values use the registration policy "Expert Review" <a href="#RFC8126" class="xref">[RFC8126]</a>.</dd>
<dt>Reference</dt>
<dd style="margin-left: 8">This contains a pointer to the public specification of the error code abbreviation, if one exists.</dd>
<dt>Original Specification</dt>
<dd style="margin-left: 8">This contains a pointer to the public specification of the error code, if one exists.</dd>
</dl>
<p id="rfc.section.8.4.p.3">This registry will be initially populated by the values in <a href="#fig:cborErrorCodes" class="xref">Figure 10</a>. The Reference column for all of these entries will be this document.</p>
<h1 id="rfc.section.8.5">
<a href="#rfc.section.8.5">8.5.</a> <a href="#IANAGrantTypeMappings" id="IANAGrantTypeMappings">OAuth Grant Type CBOR Mappings</a>
</h1>
<p id="rfc.section.8.5.p.1">This specification establishes the IANA "OAuth Grant Type CBOR Mappings" registry.  The registry has been created to use the "Expert Review" registration procedure <a href="#RFC8126" class="xref">[RFC8126]</a>, except for the value range designated for private use. </p>
<p id="rfc.section.8.5.p.2">The columns of this registry are: </p>

<dl>
<dt>Name</dt>
<dd style="margin-left: 8">The name of the grant type as specified in Section 1.3 of <a href="#RFC6749" class="xref">[RFC6749]</a>.</dd>
<dt>CBOR Value</dt>
<dd style="margin-left: 8">CBOR abbreviation for this grant type.  Integer values less than -65536 are marked as "Private Use", all other values use the registration policy "Expert Review" <a href="#RFC8126" class="xref">[RFC8126]</a>.</dd>
<dt>Reference</dt>
<dd style="margin-left: 8">This contains a pointer to the public specification of the grant type abbreviation, if one exists.</dd>
<dt>Original Specification</dt>
<dd style="margin-left: 8">This contains a pointer to the public specification of the grant type, if one exists.</dd>
</dl>
<p id="rfc.section.8.5.p.3">This registry will be initially populated by the values in <a href="#fig:grant_types" class="xref">Figure 11</a>. The Reference column for all of these entries will be this document.</p>
<h1 id="rfc.section.8.6">
<a href="#rfc.section.8.6">8.6.</a> <a href="#IANAOAuthTokenType" id="IANAOAuthTokenType">OAuth Access Token Types</a>
</h1>
<p id="rfc.section.8.6.p.1">This section registers the following new token type in the "OAuth Access Token Types" registry <a href="#IANA.OAuthAccessTokenTypes" class="xref">[IANA.OAuthAccessTokenTypes]</a>.</p>
<p></p>

<ul>
<li>Type name: <samp>PoP</samp>
</li>
<li>Additional Token Endpoint Response Parameters: "cnf", "rs_cnf" see section 3.1 of <a href="#RFC8747" class="xref">[RFC8747]</a> and section 3.1 of <a href="#I-D.ietf-ace-oauth-params" class="xref">[I-D.ietf-ace-oauth-params]</a>.</li>
<li>HTTP Authentication Scheme(s): N/A</li>
<li>Change Controller: IETF</li>
<li>Specification document(s): [this document]</li>
</ul>
<h1 id="rfc.section.8.7">
<a href="#rfc.section.8.7">8.7.</a> <a href="#IANATokenTypeMappings" id="IANATokenTypeMappings">OAuth Access Token Type CBOR Mappings</a>
</h1>
<p id="rfc.section.8.7.p.1">This specification established the IANA "OAuth Access Token Type CBOR Mappings" registry.  The registry has been created to use the "Expert Review" registration procedure <a href="#RFC8126" class="xref">[RFC8126]</a>, except for the value range designated for private use. </p>
<p id="rfc.section.8.7.p.2">The columns of this registry are: </p>

<dl>
<dt>Name</dt>
<dd style="margin-left: 8">The name of token type as registered in the OAuth Access Token Types registry, e.g., "Bearer".</dd>
<dt>CBOR Value</dt>
<dd style="margin-left: 8">CBOR abbreviation for this token type.  Integer values less than -65536 are marked as "Private Use", all other values use the registration policy "Expert Review" <a href="#RFC8126" class="xref">[RFC8126]</a>.</dd>
<dt>Reference</dt>
<dd style="margin-left: 8">This contains a pointer to the public specification of the OAuth token type abbreviation, if one exists.</dd>
<dt>Original Specification</dt>
<dd style="margin-left: 8">This contains a pointer to the public specification of the OAuth token type, if one exists.</dd>
</dl>
<h1 id="rfc.section.8.7.1">
<a href="#rfc.section.8.7.1">8.7.1.</a> <a href="#IANATokenTypeMappingsInitial" id="IANATokenTypeMappingsInitial">Initial Registry Contents</a>
</h1>
<p></p>

<ul>
<li>Name: <samp>Bearer</samp>
</li>
<li>Value:  1</li>
<li>Reference:  [this document]</li>
<li>Original Specification:  <a href="#RFC6749" class="xref">[RFC6749]</a>
</li>
</ul>

<p> </p>
<p></p>

<ul>
<li>Name: <samp>PoP</samp>
</li>
<li>Value: 2</li>
<li>Reference: [this document]</li>
<li>Original Specification:  [this document]</li>
</ul>

<p> </p>
<h1 id="rfc.section.8.8">
<a href="#rfc.section.8.8">8.8.</a> <a href="#IANAProfile" id="IANAProfile">ACE Profile Registry</a>
</h1>
<p id="rfc.section.8.8.p.1">This specification establishes the IANA "ACE Profile" registry.  The registry has been created to use the "Expert Review" registration procedure <a href="#RFC8126" class="xref">[RFC8126]</a>.  It should be noted that, in addition to the expert review, some portions of the registry require a specification, potentially a Standards Track RFC, be supplied as well.</p>
<p id="rfc.section.8.8.p.2">The columns of this registry are: </p>

<dl>
<dt>Name</dt>
<dd style="margin-left: 8">The name of the profile, to be used as value of the profile attribute.</dd>
<dt>Description</dt>
<dd style="margin-left: 8">Text giving an overview of the profile and the context it is developed for.</dd>
<dt>CBOR Value</dt>
<dd style="margin-left: 8">CBOR abbreviation for this profile name.  Different ranges of values use different registration policies <a href="#RFC8126" class="xref">[RFC8126]</a>.  Integer values from -256 to 255 are designated as Standards Action.  Integer values from -65536 to -257 and from 256 to 65535 are designated as Specification Required.  Integer values greater than 65535 are designated as "Expert Review".  Integer values less than -65536 are marked as Private Use.</dd>
<dt>Reference</dt>
<dd style="margin-left: 8">This contains a pointer to the public specification of the profile abbreviation, if one exists.</dd>
</dl>
<p id="rfc.section.8.8.p.3">This registry will be initially empty and will be populated by the registrations from the ACE framework profiles.</p>
<h1 id="rfc.section.8.9">
<a href="#rfc.section.8.9">8.9.</a> <a href="#IANAOAuthParameter" id="IANAOAuthParameter">OAuth Parameter Registration</a>
</h1>
<p id="rfc.section.8.9.p.1">This specification registers the following parameter in the "OAuth Parameters" registry <a href="#IANA.OAuthParameters" class="xref">[IANA.OAuthParameters]</a>:</p>
<p></p>

<ul>
<li>Name: <samp>ace_profile</samp>
</li>
<li>Parameter Usage Location: token response</li>
<li>Change Controller: IETF</li>
<li>Reference: <a href="#tokenResponse" class="xref">Section 5.8.2</a> and <a href="#paramProfile" class="xref">Section 5.8.4.3</a> of [this document]</li>
</ul>
<h1 id="rfc.section.8.10">
<a href="#rfc.section.8.10">8.10.</a> <a href="#IANAOAuthParameterMappingsRegistry" id="IANAOAuthParameterMappingsRegistry">OAuth Parameters CBOR Mappings Registry</a>
</h1>
<p id="rfc.section.8.10.p.1">This specification establishes the IANA "OAuth Parameters CBOR Mappings" registry.  The registry has been created to use the "Expert Review" registration procedure <a href="#RFC8126" class="xref">[RFC8126]</a>, except for the value range designated for private use.</p>
<p id="rfc.section.8.10.p.2">The columns of this registry are: </p>

<dl>
<dt>Name</dt>
<dd style="margin-left: 8">The OAuth Parameter name, refers to the name in the OAuth parameter registry, e.g., "client_id".</dd>
<dt>CBOR Key</dt>
<dd style="margin-left: 8">CBOR map key for this parameter.  Integer values less than -65536 are marked as "Private Use", all other values use the registration policy "Expert Review" <a href="#RFC8126" class="xref">[RFC8126]</a>.</dd>
<dt>Value Type</dt>
<dd style="margin-left: 8">The allowable CBOR data types for values of this parameter.</dd>
<dt>Reference</dt>
<dd style="margin-left: 8">This contains a pointer to the public specification of the OAuth parameter abbreviation, if one exists.</dd>
<dt>Original Specification</dt>
<dd style="margin-left: 8">This contains a pointer to the public specification of the OAuth parameter, if one exists.</dd>
</dl>
<p id="rfc.section.8.10.p.3">This registry will be initially populated by the values in <a href="#fig:cborTokenParameters" class="xref">Figure 12</a>. The Reference column for all of these entries will be this document.</p>
<h1 id="rfc.section.8.11">
<a href="#rfc.section.8.11">8.11.</a> <a href="#IANAOAuthIntrospectionResponseParameterRegistration" id="IANAOAuthIntrospectionResponseParameterRegistration">OAuth Introspection Response Parameter Registration</a>
</h1>
<p id="rfc.section.8.11.p.1">This specification registers the following parameters in the OAuth Token Introspection Response registry <a href="#IANA.TokenIntrospectionResponse" class="xref">[IANA.TokenIntrospectionResponse]</a>.</p>
<p></p>

<ul>
<li>Name: <samp>ace_profile</samp>
</li>
<li>Description: The ACE profile used between client and RS.</li>
<li>Change Controller: IETF</li>
<li>Reference: <a href="#introRes" class="xref">Section 5.9.2</a> of [this document]</li>
</ul>

<p> </p>
<p></p>

<ul>
<li>Name: <samp>cnonce</samp>
</li>
<li>Description: "client-nonce". A nonce previously provided to the AS by the RS via the client.  Used to verify token freshness when the RS cannot synchronize its clock with the AS.</li>
<li>Change Controller: IETF</li>
<li>Reference: <a href="#introRes" class="xref">Section 5.9.2</a> of [this document]</li>
</ul>

<p> </p>
<p></p>

<ul>
<li>Name: <samp>exi</samp>
</li>
<li>Description: "Expires in". Lifetime of the token in seconds from the time the RS first sees it.  Used to implement a weaker from of token expiration for devices that cannot synchronize their internal clocks.</li>
<li>Change Controller: IETF</li>
<li>Reference: <a href="#introRes" class="xref">Section 5.9.2</a> of [this document]</li>
</ul>

<p> </p>
<h1 id="rfc.section.8.12">
<a href="#rfc.section.8.12">8.12.</a> <a href="#IANAIntrospectionEndpointCBORMappingsRegistry" id="IANAIntrospectionEndpointCBORMappingsRegistry">OAuth Token Introspection Response CBOR Mappings Registry</a>
</h1>
<p id="rfc.section.8.12.p.1">This specification establishes the IANA "OAuth Token Introspection Response CBOR Mappings" registry.  The registry has been created to use the "Expert Review" registration procedure <a href="#RFC8126" class="xref">[RFC8126]</a>, except for the value range designated for private use.</p>
<p id="rfc.section.8.12.p.2">The columns of this registry are: </p>

<dl>
<dt>Name</dt>
<dd style="margin-left: 8">The OAuth Parameter name, refers to the name in the OAuth parameter registry, e.g., "client_id".</dd>
<dt>CBOR Key</dt>
<dd style="margin-left: 8">CBOR map key for this parameter.  Integer values less than -65536 are marked as "Private Use", all other values use the registration policy "Expert Review" <a href="#RFC8126" class="xref">[RFC8126]</a>.</dd>
<dt>Value Type</dt>
<dd style="margin-left: 8">The allowable CBOR data types for values of this parameter.</dd>
<dt>Reference</dt>
<dd style="margin-left: 8">This contains a pointer to the public specification of the introspection response parameter abbreviation, if one exists.</dd>
<dt>Original Specification</dt>
<dd style="margin-left: 8">This contains a pointer to the public specification of OAuth Token Introspection parameter, if one exists.</dd>
</dl>
<p id="rfc.section.8.12.p.3">This registry will be initially populated by the values in <a href="#fig:cborIntrospectionParameters" class="xref">Figure 16</a>. The Reference column for all of these entries will be this document.</p>
<p id="rfc.section.8.12.p.4">Note that the mappings of parameters corresponding to claim names intentionally coincide with the CWT claim name mappings from <a href="#RFC8392" class="xref">[RFC8392]</a>.</p>
<h1 id="rfc.section.8.13">
<a href="#rfc.section.8.13">8.13.</a> <a href="#IANAJWTClaims" id="IANAJWTClaims">JSON Web Token Claims</a>
</h1>
<p id="rfc.section.8.13.p.1">This specification registers the following new claims in the JSON Web Token (JWT) registry of JSON Web Token Claims <a href="#IANA.JsonWebTokenClaims" class="xref">[IANA.JsonWebTokenClaims]</a>:</p>
<p></p>

<ul>
<li>Claim Name: <samp>ace_profile</samp>
</li>
<li>Claim Description: The ACE profile a token is supposed to be used with.</li>
<li>Change Controller: IETF</li>
<li>Reference: <a href="#accessToken" class="xref">Section 5.10</a> of [this document]</li>
</ul>
<p></p>

<ul>
<li>Claim Name: <samp>cnonce</samp>
</li>
<li>Claim Description: "client-nonce". A nonce previously provided to the AS by the RS via the client.  Used to verify token freshness when the RS cannot synchronize its clock with the AS.</li>
<li>Change Controller: IETF</li>
<li>Reference: <a href="#accessToken" class="xref">Section 5.10</a> of [this document]</li>
</ul>
<p></p>

<ul>
<li>Claim Name: <samp>exi</samp>
</li>
<li>Claim Description: "Expires in". Lifetime of the token in seconds from the time the RS first sees it.  Used to implement a weaker from of token expiration for devices that cannot synchronize their internal clocks.</li>
<li>Change Controller: IETF</li>
<li>Reference: <a href="#tokenExpiration" class="xref">Section 5.10.3</a> of [this document]</li>
</ul>
<h1 id="rfc.section.8.14">
<a href="#rfc.section.8.14">8.14.</a> <a href="#IANACWTClaims" id="IANACWTClaims">CBOR Web Token Claims</a>
</h1>
<p id="rfc.section.8.14.p.1">This specification registers the following new claims in the "CBOR Web Token (CWT) Claims" registry <a href="#IANA.CborWebTokenClaims" class="xref">[IANA.CborWebTokenClaims]</a>.</p>
<p></p>

<ul>
<li>Claim Name: <samp>ace_profile</samp>
</li>
<li>Claim Description: The ACE profile a token is supposed to be used with.</li>
<li>JWT Claim Name: ace_profile</li>
<li>Claim Key: TBD (suggested: 38)</li>
<li>Claim Value Type(s): integer</li>
<li>Change Controller: IETF</li>
<li>Specification Document(s): <a href="#accessToken" class="xref">Section 5.10</a> of [this document]</li>
</ul>
<p></p>

<ul>
<li>Claim Name: <samp>cnonce</samp>
</li>
<li>Claim Description: The client-nonce sent to the AS by the RS via the client.</li>
<li>JWT Claim Name: cnonce</li>
<li>Claim Key: TBD (suggested: 39)</li>
<li>Claim Value Type(s): byte string</li>
<li>Change Controller: IETF</li>
<li>Specification Document(s): <a href="#accessToken" class="xref">Section 5.10</a> of [this document]</li>
</ul>
<p></p>

<ul>
<li>Claim Name: <samp>exi</samp>
</li>
<li>Claim Description: The expiration time of a token measured from when it was received at the RS in seconds.</li>
<li>JWT Claim Name: exi</li>
<li>Claim Key: TBD (suggested: 40)</li>
<li>Claim Value Type(s): integer</li>
<li>Change Controller: IETF</li>
<li>Specification Document(s): <a href="#tokenExpiration" class="xref">Section 5.10.3</a> of [this document]</li>
</ul>
<p></p>

<ul>
<li>Claim Name: <samp>scope</samp>
</li>
<li>Claim Description: The scope of an access token as defined in <a href="#RFC6749" class="xref">[RFC6749]</a>.</li>
<li>JWT Claim Name: scope</li>
<li>Claim Key: TBD (suggested: 9)</li>
<li>Claim Value Type(s): byte string or text string</li>
<li>Change Controller: IETF</li>
<li>Specification Document(s): Section 4.2 of <a href="#RFC8693" class="xref">[RFC8693]</a>
</li>
</ul>
<h1 id="rfc.section.8.15">
<a href="#rfc.section.8.15">8.15.</a> <a href="#IANAmediaType" id="IANAmediaType">Media Type Registrations</a>
</h1>
<p id="rfc.section.8.15.p.1">This specification registers the 'application/ace+cbor' media type for messages of the protocols defined in this document carrying parameters encoded in CBOR.  This registration follows the procedures specified in <a href="#RFC6838" class="xref">[RFC6838]</a>.</p>
<p id="rfc.section.8.15.p.2">Type name: application</p>
<p id="rfc.section.8.15.p.3">Subtype name: ace+cbor</p>
<p id="rfc.section.8.15.p.4">Required parameters: N/A</p>
<p id="rfc.section.8.15.p.5">Optional parameters: N/A</p>
<p id="rfc.section.8.15.p.6">Encoding considerations: Must be encoded as CBOR map containing the protocol parameters defined in [this document].</p>
<p id="rfc.section.8.15.p.7">Security considerations: See <a href="#security" class="xref">Section 6</a> of [this document]</p>
<p id="rfc.section.8.15.p.8">Interoperability considerations: N/A</p>
<p id="rfc.section.8.15.p.9">Published specification: [this document]</p>
<p id="rfc.section.8.15.p.10">Applications that use this media type: The type is used by authorization servers, clients and resource servers that support the ACE framework with CBOR encoding as specified in [this document].</p>
<p id="rfc.section.8.15.p.11">Fragment identifier considerations: N/A </p>
<p id="rfc.section.8.15.p.12">Additional information: N/A</p>
<p id="rfc.section.8.15.p.13">Person &amp; email address to contact for further information: &lt;iesg@ietf.org&gt;</p>
<p id="rfc.section.8.15.p.14">Intended usage: COMMON</p>
<p id="rfc.section.8.15.p.15">Restrictions on usage: none</p>
<p id="rfc.section.8.15.p.16">Author: Ludwig Seitz &lt;ludwig.seitz@combitech.se&gt;</p>
<p id="rfc.section.8.15.p.17">Change controller: IETF</p>
<h1 id="rfc.section.8.16">
<a href="#rfc.section.8.16">8.16.</a> <a href="#IANAcoapContentFormat" id="IANAcoapContentFormat">CoAP Content-Format Registry</a>
</h1>
<p id="rfc.section.8.16.p.1">This specification registers the following entry to the "CoAP Content-Formats" registry:</p>
<p id="rfc.section.8.16.p.2">Media Type: application/ace+cbor</p>
<p id="rfc.section.8.16.p.3">Encoding: -</p>
<p id="rfc.section.8.16.p.4">ID: TBD (suggested: 19)</p>
<p id="rfc.section.8.16.p.5">Reference: [this document]</p>
<h1 id="rfc.section.8.17">
<a href="#rfc.section.8.17">8.17.</a> <a href="#IANAinstructions" id="IANAinstructions">Expert Review Instructions</a>
</h1>
<p id="rfc.section.8.17.p.1">All of the IANA registries established in this document are defined to use a registration policy of Expert Review.  This section gives some general guidelines for what the experts should be looking for, but they are being designated as experts for a reason, so they should be given substantial latitude.</p>
<p id="rfc.section.8.17.p.2">Expert reviewers should take into consideration the following points: </p>

<ul>
<li>Point squatting should be discouraged.  Reviewers are encouraged to get sufficient information for registration requests to ensure that the usage is not going to duplicate one that is already registered, and that the point is likely to be used in deployments.  The zones tagged as private use are intended for testing purposes and closed environments; code points in other ranges should not be assigned for testing.</li>
<li>Specifications are needed for the first-come, first-serve range if they are expected to be used outside of closed environments in an interoperable way.  When specifications are not provided, the description provided needs to have sufficient information to identify what the point is being used for.</li>
<li>Experts should take into account the expected usage of fields when approving point assignment.  The fact that there is a range for standards track documents does not mean that a standards track document cannot have points assigned outside of that range.  The length of the encoded value should be weighed against how many code points of that length are left, the size of device it will be used on.</li>
<li>Since a high degree of overlap is expected between these registries and the contents of the OAuth parameters <a href="#IANA.OAuthParameters" class="xref">[IANA.OAuthParameters]</a> registries, experts should require new registrations to maintain alignment with parameters from OAuth that have comparable functionality.  Deviation from this alignment should only be allowed if there are functional differences, that are motivated by the use case and that cannot be easily or efficiently addressed by comparable OAuth parameters.</li>
</ul>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#Acknowledgments" id="Acknowledgments">Acknowledgments</a>
</h1>
<p id="rfc.section.9.p.1">This document is a product of the ACE working group of the IETF.</p>
<p id="rfc.section.9.p.2">Thanks to Eve Maler for her contributions to the use of OAuth 2.0 and UMA in IoT scenarios, Robert Taylor for his discussion input, and Malisa Vucinic for his input on the predecessors of this proposal.</p>
<p id="rfc.section.9.p.3">Thanks to the authors of draft-ietf-oauth-pop-key-distribution, from where parts of the security considerations where copied.</p>
<p id="rfc.section.9.p.4">Thanks to Stefanie Gerdes, Olaf Bergmann, and Carsten Bormann for contributing their work on AS discovery from draft-gerdes-ace-dcaf-authorize (see <a href="#asDiscovery" class="xref">Section 5.1</a>) and the considerations on multiple access tokens.</p>
<p id="rfc.section.9.p.5">Thanks to Jim Schaad and Mike Jones for their comprehensive reviews.</p>
<p id="rfc.section.9.p.6">Thanks to Benjamin Kaduk for his input on various questions related to this work.</p>
<p id="rfc.section.9.p.7">Thanks to Cigdem Sengul for some very useful review comments.</p>
<p id="rfc.section.9.p.8">Thanks to Carsten Bormann for contributing the text for the CoRE Resource Type registry.</p>
<p id="rfc.section.9.p.9">Thanks to Roman Danyliw for suggesting the <a href="#app:diffOAuth" class="xref">Appendix E</a> (including its contents).</p>
<p id="rfc.section.9.p.10">Ludwig Seitz and Goeran Selander worked on this document as part of the CelticPlus project CyberWI, with funding from Vinnova. Ludwig Seitz was also received further funding for this work by Vinnova in the context of the CelticNext project Critisec.</p>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-ace-oauth-params">[I-D.ietf-ace-oauth-params]</b></td>
<td class="top">
<a title="Combitech">Seitz, L.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-ace-oauth-params-15">Additional OAuth Parameters for Authorization in Constrained Environments (ACE)</a>", Internet-Draft draft-ietf-ace-oauth-params-15, May 2021.</td>
</tr>
<tr>
<td class="reference"><b id="IANA.CborWebTokenClaims">[IANA.CborWebTokenClaims]</b></td>
<td class="top">
<a>IANA</a>, "<a href="https://www.iana.org/assignments/cwt/cwt.xhtml#claims-registry">CBOR Web Token (CWT) Claims</a>"</td>
</tr>
<tr>
<td class="reference"><b id="IANA.CoreParameters">[IANA.CoreParameters]</b></td>
<td class="top">
<a>IANA</a>, "<a href="https://www.iana.org/assignments/core-parameters/core-parameters.xhtml">Constrained RESTful Environments (CoRE) Parameters</a>"</td>
</tr>
<tr>
<td class="reference"><b id="IANA.JsonWebTokenClaims">[IANA.JsonWebTokenClaims]</b></td>
<td class="top">
<a>IANA</a>, "<a href="https://www.iana.org/assignments/jwt/jwt.xhtml#claims">JSON Web Token Claims</a>"</td>
</tr>
<tr>
<td class="reference"><b id="IANA.OAuthAccessTokenTypes">[IANA.OAuthAccessTokenTypes]</b></td>
<td class="top">
<a>IANA</a>, "<a href="https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#token-types">OAuth Access Token Types</a>"</td>
</tr>
<tr>
<td class="reference"><b id="IANA.OAuthExtensionsErrorRegistry">[IANA.OAuthExtensionsErrorRegistry]</b></td>
<td class="top">
<a>IANA</a>, "<a href="https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#extensions-error">OAuth Extensions Error Registry</a>"</td>
</tr>
<tr>
<td class="reference"><b id="IANA.OAuthParameters">[IANA.OAuthParameters]</b></td>
<td class="top">
<a>IANA</a>, "<a href="https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#parameters">OAuth Parameters</a>"</td>
</tr>
<tr>
<td class="reference"><b id="IANA.TokenIntrospectionResponse">[IANA.TokenIntrospectionResponse]</b></td>
<td class="top">
<a>IANA</a>, "<a href="https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#token-introspection-response">OAuth Token Introspection Response</a>"</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6347">[RFC6347]</b></td>
<td class="top">
<a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="https://tools.ietf.org/html/rfc6347">Datagram Transport Layer Security Version 1.2</a>", RFC 6347, DOI 10.17487/RFC6347, January 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6749">[RFC6749]</b></td>
<td class="top">
<a>Hardt, D.</a>, "<a href="https://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization Framework</a>", RFC 6749, DOI 10.17487/RFC6749, October 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6750">[RFC6750]</b></td>
<td class="top">
<a>Jones, M.</a> and <a>D. Hardt</a>, "<a href="https://tools.ietf.org/html/rfc6750">The OAuth 2.0 Authorization Framework: Bearer Token Usage</a>", RFC 6750, DOI 10.17487/RFC6750, October 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6838">[RFC6838]</b></td>
<td class="top">
<a>Freed, N.</a>, <a>Klensin, J.</a> and <a>T. Hansen</a>, "<a href="https://tools.ietf.org/html/rfc6838">Media Type Specifications and Registration Procedures</a>", BCP 13, RFC 6838, DOI 10.17487/RFC6838, January 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6920">[RFC6920]</b></td>
<td class="top">
<a>Farrell, S.</a>, <a>Kutscher, D.</a>, <a>Dannewitz, C.</a>, <a>Ohlman, B.</a>, <a>Keranen, A.</a> and <a>P. Hallam-Baker</a>, "<a href="https://tools.ietf.org/html/rfc6920">Naming Things with Hashes</a>", RFC 6920, DOI 10.17487/RFC6920, April 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7252">[RFC7252]</b></td>
<td class="top">
<a>Shelby, Z.</a>, <a>Hartke, K.</a> and <a>C. Bormann</a>, "<a href="https://tools.ietf.org/html/rfc7252">The Constrained Application Protocol (CoAP)</a>", RFC 7252, DOI 10.17487/RFC7252, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7519">[RFC7519]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Bradley, J.</a> and <a>N. Sakimura</a>, "<a href="https://tools.ietf.org/html/rfc7519">JSON Web Token (JWT)</a>", RFC 7519, DOI 10.17487/RFC7519, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7662">[RFC7662]</b></td>
<td class="top">
<a>Richer, J.</a>, "<a href="https://tools.ietf.org/html/rfc7662">OAuth 2.0 Token Introspection</a>", RFC 7662, DOI 10.17487/RFC7662, October 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8126">[RFC8126]</b></td>
<td class="top">
<a>Cotton, M.</a>, <a>Leiba, B.</a> and <a>T. Narten</a>, "<a href="https://tools.ietf.org/html/rfc8126">Guidelines for Writing an IANA Considerations Section in RFCs</a>", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8152">[RFC8152]</b></td>
<td class="top">
<a>Schaad, J.</a>, "<a href="https://tools.ietf.org/html/rfc8152">CBOR Object Signing and Encryption (COSE)</a>", RFC 8152, DOI 10.17487/RFC8152, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8392">[RFC8392]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Wahlstroem, E.</a>, <a>Erdtman, S.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/rfc8392">CBOR Web Token (CWT)</a>", RFC 8392, DOI 10.17487/RFC8392, May 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8693">[RFC8693]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Nadalin, A.</a>, <a>Campbell, B.</a>, <a>Bradley, J.</a> and <a>C. Mortimore</a>, "<a href="https://tools.ietf.org/html/rfc8693">OAuth 2.0 Token Exchange</a>", RFC 8693, DOI 10.17487/RFC8693, January 2020.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8747">[RFC8747]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Seitz, L.</a>, <a>Selander, G.</a>, <a>Erdtman, S.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/rfc8747">Proof-of-Possession Key Semantics for CBOR Web Tokens (CWTs)</a>", RFC 8747, DOI 10.17487/RFC8747, March 2020.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8949">[RFC8949]</b></td>
<td class="top">
<a>Bormann, C.</a> and <a>P. Hoffman</a>, "<a href="https://tools.ietf.org/html/rfc8949">Concise Binary Object Representation (CBOR)</a>", STD 94, RFC 8949, DOI 10.17487/RFC8949, December 2020.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="BLE">[BLE]</b></td>
<td class="top">
<a>Bluetooth SIG</a>, "<a href="https://www.bluetooth.com/specifications/bluetooth-core-specification/">Bluetooth Core Specification v5.1</a>", Section 4.4, January 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.erdtman-ace-rpcc">[I-D.erdtman-ace-rpcc]</b></td>
<td class="top">
<a title="RISE SICS">Seitz, L.</a> and <a title="Spotify AB">S. Erdtman</a>, "<a href="https://tools.ietf.org/html/draft-erdtman-ace-rpcc-02">Raw-Public-Key and Pre-Shared-Key as OAuth client credentials</a>", Internet-Draft draft-erdtman-ace-rpcc-02, October 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-ace-dtls-authorize">[I-D.ietf-ace-dtls-authorize]</b></td>
<td class="top">
<a title="Universit&#228;t Bremen TZI">Gerdes, S.</a>, <a title="Universit&#228;t Bremen TZI">Bergmann, O.</a>, <a title="Universit&#228;t Bremen TZI">Bormann, C.</a>, <a title="Ericsson AB">Selander, G.</a> and <a title="Combitech">L. Seitz</a>, "<a href="https://tools.ietf.org/html/draft-ietf-ace-dtls-authorize-18">Datagram Transport Layer Security (DTLS) Profile for Authentication and Authorization for Constrained Environments (ACE)</a>", Internet-Draft draft-ietf-ace-dtls-authorize-18, June 2021.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-ace-oscore-profile">[I-D.ietf-ace-oscore-profile]</b></td>
<td class="top">
<a title="Ericsson AB">Palombini, F.</a>, <a title="Combitech">Seitz, L.</a>, <a title="Ericsson AB">Selander, G.</a> and <a title="RISE">M. Gunnarsson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-ace-oscore-profile-19">OSCORE Profile of the Authentication and Authorization for Constrained Environments Framework</a>", Internet-Draft draft-ietf-ace-oscore-profile-19, May 2021.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-quic-transport">[I-D.ietf-quic-transport]</b></td>
<td class="top">
<a title="Fastly">Iyengar, J.</a> and <a title="Mozilla">M. Thomson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-quic-transport-34">QUIC: A UDP-Based Multiplexed and Secure Transport</a>", Internet-Draft draft-ietf-quic-transport-34, January 2021.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-tls-dtls13">[I-D.ietf-tls-dtls13]</b></td>
<td class="top">
<a>Rescorla, E.</a>, <a>Tschofenig, H.</a> and <a>N. Modadugu</a>, "<a href="https://tools.ietf.org/html/draft-ietf-tls-dtls13-43">The Datagram Transport Layer Security (DTLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-dtls13-43, April 2021.</td>
</tr>
<tr>
<td class="reference"><b id="Margi10impact">[Margi10impact]</b></td>
<td class="top">
<a>Margi, C.</a>, <a>de Oliveira, B.</a>, <a>de Sousa, G.</a>, <a>Simplicio Jr, M.</a>, <a>Barreto, P.</a>, <a>Carvalho, T.</a>, <a>Naeslund, M.</a> and <a>R. Gold</a>, "<a>Impact of Operating Systems on Wireless Sensor Networks (Security) Applications and Testbeds</a>", Proceedings of the 19th International Conference on Computer Communications and Networks (ICCCN), August 2010.</td>
</tr>
<tr>
<td class="reference"><b id="MQTT5.0">[MQTT5.0]</b></td>
<td class="top">
<a>Banks, A.</a>, <a>Briggs, E.</a>, <a>Borgendale, K.</a> and <a>R. Gupta</a>, "<a href="https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html">MQTT Version 5.0</a>", OASIS Standard, March 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4949">[RFC4949]</b></td>
<td class="top">
<a>Shirey, R.</a>, "<a href="https://tools.ietf.org/html/rfc4949">Internet Security Glossary, Version 2</a>", FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6690">[RFC6690]</b></td>
<td class="top">
<a>Shelby, Z.</a>, "<a href="https://tools.ietf.org/html/rfc6690">Constrained RESTful Environments (CoRE) Link Format</a>", RFC 6690, DOI 10.17487/RFC6690, August 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6819">[RFC6819]</b></td>
<td class="top">
<a>Lodderstedt, T.</a>, <a>McGloin, M.</a> and <a>P. Hunt</a>, "<a href="https://tools.ietf.org/html/rfc6819">OAuth 2.0 Threat Model and Security Considerations</a>", RFC 6819, DOI 10.17487/RFC6819, January 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7009">[RFC7009]</b></td>
<td class="top">
<a>Lodderstedt, T.</a>, <a>Dronia, S.</a> and <a>M. Scurtescu</a>, "<a href="https://tools.ietf.org/html/rfc7009">OAuth 2.0 Token Revocation</a>", RFC 7009, DOI 10.17487/RFC7009, August 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7228">[RFC7228]</b></td>
<td class="top">
<a>Bormann, C.</a>, <a>Ersue, M.</a> and <a>A. Keranen</a>, "<a href="https://tools.ietf.org/html/rfc7228">Terminology for Constrained-Node Networks</a>", RFC 7228, DOI 10.17487/RFC7228, May 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7231">[RFC7231]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7521">[RFC7521]</b></td>
<td class="top">
<a>Campbell, B.</a>, <a>Mortimore, C.</a>, <a>Jones, M.</a> and <a>Y. Goland</a>, "<a href="https://tools.ietf.org/html/rfc7521">Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants</a>", RFC 7521, DOI 10.17487/RFC7521, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7540">[RFC7540]</b></td>
<td class="top">
<a>Belshe, M.</a>, <a>Peon, R.</a> and <a>M. Thomson</a>, "<a href="https://tools.ietf.org/html/rfc7540">Hypertext Transfer Protocol Version 2 (HTTP/2)</a>", RFC 7540, DOI 10.17487/RFC7540, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7591">[RFC7591]</b></td>
<td class="top">
<a>Richer, J.</a>, <a>Jones, M.</a>, <a>Bradley, J.</a>, <a>Machulak, M.</a> and <a>P. Hunt</a>, "<a href="https://tools.ietf.org/html/rfc7591">OAuth 2.0 Dynamic Client Registration Protocol</a>", RFC 7591, DOI 10.17487/RFC7591, July 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7641">[RFC7641]</b></td>
<td class="top">
<a>Hartke, K.</a>, "<a href="https://tools.ietf.org/html/rfc7641">Observing Resources in the Constrained Application Protocol (CoAP)</a>", RFC 7641, DOI 10.17487/RFC7641, September 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7744">[RFC7744]</b></td>
<td class="top">
<a>Seitz, L.</a>, <a>Gerdes, S.</a>, <a>Selander, G.</a>, <a>Mani, M.</a> and <a>S. Kumar</a>, "<a href="https://tools.ietf.org/html/rfc7744">Use Cases for Authentication and Authorization in Constrained Environments</a>", RFC 7744, DOI 10.17487/RFC7744, January 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7959">[RFC7959]</b></td>
<td class="top">
<a>Bormann, C.</a> and <a>Z. Shelby</a>, "<a href="https://tools.ietf.org/html/rfc7959">Block-Wise Transfers in the Constrained Application Protocol (CoAP)</a>", RFC 7959, DOI 10.17487/RFC7959, August 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8252">[RFC8252]</b></td>
<td class="top">
<a>Denniss, W.</a> and <a>J. Bradley</a>, "<a href="https://tools.ietf.org/html/rfc8252">OAuth 2.0 for Native Apps</a>", BCP 212, RFC 8252, DOI 10.17487/RFC8252, October 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8259">[RFC8259]</b></td>
<td class="top">
<a>Bray, T.</a>, "<a href="https://tools.ietf.org/html/rfc8259">The JavaScript Object Notation (JSON) Data Interchange Format</a>", STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8414">[RFC8414]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Sakimura, N.</a> and <a>J. Bradley</a>, "<a href="https://tools.ietf.org/html/rfc8414">OAuth 2.0 Authorization Server Metadata</a>", RFC 8414, DOI 10.17487/RFC8414, June 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8446">[RFC8446]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/rfc8446">The Transport Layer Security (TLS) Protocol Version 1.3</a>", RFC 8446, DOI 10.17487/RFC8446, August 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8516">[RFC8516]</b></td>
<td class="top">
<a>Keranen, A.</a>, "<a href="https://tools.ietf.org/html/rfc8516">"Too Many Requests" Response Code for the Constrained Application Protocol</a>", RFC 8516, DOI 10.17487/RFC8516, January 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8613">[RFC8613]</b></td>
<td class="top">
<a>Selander, G.</a>, <a>Mattsson, J.</a>, <a>Palombini, F.</a> and <a>L. Seitz</a>, "<a href="https://tools.ietf.org/html/rfc8613">Object Security for Constrained RESTful Environments (OSCORE)</a>", RFC 8613, DOI 10.17487/RFC8613, July 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8628">[RFC8628]</b></td>
<td class="top">
<a>Denniss, W.</a>, <a>Bradley, J.</a>, <a>Jones, M.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/rfc8628">OAuth 2.0 Device Authorization Grant</a>", RFC 8628, DOI 10.17487/RFC8628, August 2019.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#constraints" id="constraints">Design Justification</a>
</h1>
<p id="rfc.section.A.p.1">This section provides further insight into the design decisions of the solution documented in this document.  <a href="#overview" class="xref">Section 3</a> lists several building blocks and briefly summarizes their importance.  The justification for offering some of those building blocks, as opposed to using OAuth 2.0 as is, is given below.</p>
<p id="rfc.section.A.p.2">Common IoT constraints are: </p>

<dl>
<dt>Low Power Radio:</dt>
<dd style="margin-left: 8">
<br><br> Many IoT devices are equipped with a small battery which needs to last for a long time.  For many constrained wireless devices, the highest energy cost is associated to transmitting or receiving messages (roughly by a factor of 10 compared to AES) <a href="#Margi10impact" class="xref">[Margi10impact]</a>.  It is therefore important to keep the total communication overhead low, including minimizing the number and size of messages sent and received, which has an impact of choice on the message format and protocol.  By using CoAP over UDP and CBOR encoded messages, some of these aspects are addressed.  Security protocols contribute to the communication overhead and can, in some cases, be optimized.  For example, authentication and key establishment may, in certain cases where security requirements allow, be replaced by provisioning of security context by a trusted third party, using transport or application-layer security.  <br> </dd>
<dt>Low CPU Speed:</dt>
<dd style="margin-left: 8">
<br><br> Some IoT devices are equipped with processors that are significantly slower than those found in most current devices on the Internet.  This typically has implications on what timely cryptographic operations a device is capable of performing, which in turn impacts, e.g., protocol latency.  Symmetric key cryptography may be used instead of the computationally more expensive public key cryptography where the security requirements so allow, but this may also require support for trusted-third-party-assisted secret key establishment using transport- or application-layer security.  <br>
</dd>
<dt>Small Amount of Memory:</dt>
<dd style="margin-left: 8">
<br><br> Microcontrollers embedded in IoT devices are often equipped with only a small amount of RAM and flash memory, which places limitations on what kind of processing can be performed and how much code can be put on those devices.  To reduce code size, fewer and smaller protocol implementations can be put on the firmware of such a device.  In this case, CoAP may be used instead of HTTP,  symmetric-key cryptography instead of public-key cryptography, and CBOR instead of JSON.  An authentication and key establishment protocol, e.g., the DTLS handshake,  in comparison with assisted key establishment, also has an impact on memory and code footprints.<br> </dd>
<dt>User Interface Limitations:</dt>
<dd style="margin-left: 8">
<br><br> Protecting access to resources is both an important security as well as privacy feature.  End users and enterprise customers may not want to give access to the data collected by their IoT device or to functions it may offer to third parties.  Since the classical approach of requesting permissions from end users via a rich user interface does not work in many IoT deployment scenarios, these functions need to be delegated to user-controlled devices that are better suitable for such tasks, such as smart phones and tablets.  <br><br>
</dd>
<dt>Communication Constraints:</dt>
<dd style="margin-left: 8">
<br><br> In certain constrained settings an IoT device may not be able to communicate with a given device at all times.  Devices may be sleeping, or just disconnected from the Internet because of general lack of connectivity in the area, for cost reasons, or for security reasons, e.g., to avoid an entry point for Denial-of-Service attacks.  <br><br> The communication interactions this framework builds upon (as shown graphically in <a href="#fig:protocolFlow" class="xref">Figure 1</a>) may be accomplished using a variety of different protocols, and not all parts of the message flow are used in all applications due to the communication constraints.  Deployments making use of CoAP are expected, but this framework is not limited to them.  Other protocols such as HTTP, or even protocols such as Bluetooth Smart communication that do not necessarily use IP, could also be used.  The latter raises the need for application-layer security over the various interfaces.</dd>
</dl>

<p> </p>
<p id="rfc.section.A.p.3">In the light of these constraints we have made the following design decisions: </p>

<dl>
<dt>CBOR, COSE, CWT:</dt>
<dd style="margin-left: 8">
<br><br> When using this framework, it is RECOMMENDED to use CBOR <a href="#RFC8949" class="xref">[RFC8949]</a> as data format.  Where CBOR data needs to be protected, the use of COSE <a href="#RFC8152" class="xref">[RFC8152]</a> is RECOMMENDED.  Furthermore, where self-contained tokens are needed, it is RECOMMENDED to use of CWT <a href="#RFC8392" class="xref">[RFC8392]</a>.  These measures aim at reducing the size of messages sent over the wire, the RAM size of data objects that need to be kept in memory and the size of libraries that devices need to support.  <br><br>
</dd>
<dt>CoAP:</dt>
<dd style="margin-left: 8">
<br><br> When using this framework, it is RECOMMENDED to use of CoAP <a href="#RFC7252" class="xref">[RFC7252]</a> instead of HTTP.  This does not preclude the use of other protocols specifically aimed at constrained devices, like, e.g., Bluetooth Low Energy (see <a href="#coap" class="xref">Section 3.2</a>).  This aims again at reducing the size of messages sent over the wire, the RAM size of data objects that need to be kept in memory and the size of libraries that devices need to support.  <br><br>
</dd>
<dt>Access Information:</dt>
<dd style="margin-left: 8">
<br><br> This framework defines the name "Access Information" for data concerning the RS that the AS returns to the client in an access token response (see  <a href="#tokenResponse" class="xref">Section 5.8.2</a>).  This aims at enabling scenarios where a powerful client, supporting multiple profiles, needs to interact with an RS for which it does not know the supported profiles and the raw public key.  <br><br>
</dd>
<dt>Proof-of-Possession:</dt>
<dd style="margin-left: 8">
<br><br> This framework makes use of proof-of-possession tokens, using the "cnf" claim <a href="#RFC8747" class="xref">[RFC8747]</a>.  A request parameter "cnf" and a Response parameter "cnf", both having a value space semantically and syntactically identical to the "cnf" claim, are defined for the token endpoint, to allow requesting and stating confirmation keys.  This aims at making token theft harder.  Token theft is specifically relevant in constrained use cases, as communication often passes through middle-boxes, which could be able to steal bearer tokens and use them to gain unauthorized access.  <br><br> </dd>
<dt>Authz-Info endpoint:</dt>
<dd style="margin-left: 8">
<br><br> This framework introduces a new way of providing access tokens to an RS by exposing a authz-info endpoint, to which access tokens can be POSTed.  This aims at reducing the size of the request message and the code complexity at the RS.  The size of the request message is problematic, since many constrained protocols have severe message size limitations at the physical layer (e.g., in the order of 100 bytes). This means that larger packets get fragmented, which in turn combines badly with the high rate of packet loss, and the need to retransmit the whole message if one packet gets lost.  Thus separating sending of the request and sending of the access tokens helps to reduce fragmentation.  <br><br>
</dd>
<dt>Client Credentials Grant:</dt>
<dd style="margin-left: 8">
<br><br> In this framework the use of the client credentials grant is RECOMMENDED for machine-to-machine communication use cases, where manual intervention of the resource owner to produce a grant token is not feasible.  The intention is that the resource owner would instead pre-arrange authorization with the AS, based on the client's own credentials.  The client can then (without manual intervention) obtain access tokens from the AS.  <br><br>
</dd>
<dt>Introspection:</dt>
<dd style="margin-left: 8">
<br><br> In this framework the use of access token introspection is RECOMMENDED in cases where the client is constrained in a way that it can not easily obtain new access tokens (i.e. it has connectivity issues that prevent it from communicating with the AS). In that case it is RECOMMENDED to use a long-term token, that could be a simple reference.  The RS is assumed to be able to communicate with the AS, and can therefore perform introspection, in order to learn the claims associated with the token reference.  The advantage of such an approach is that the resource owner can change the claims associated to the token reference without having to be in contact with the client, thus granting or revoking access rights.  <br><br>
</dd>
</dl>

<p> </p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#app:rolesAndResponsibilities" id="app:rolesAndResponsibilities">Roles and Responsibilities</a>
</h1>
<p></p>

<dl>
<dt>Resource Owner</dt>
<dd style="margin-left: 8">
<ul>
<li>Make sure that the RS is registered at the AS.  This includes making known to the AS which profiles, token_type, scopes, and key types (symmetric/asymmetric) the RS supports. Also making it known to the AS which audience(s) the RS identifies itself with.</li>
<li>Make sure that clients can discover the AS that is in charge of the RS.</li>
<li>If the client-credentials grant is used, make sure that the AS has the necessary, up-to-date, access control policies for the RS.</li>
</ul>
<p> </p>
<br> </dd>
<dt>Requesting Party</dt>
<dd style="margin-left: 8">
<ul>
<li>Make sure that the client is provisioned the necessary credentials to authenticate to the AS.</li>
<li>Make sure that the client is configured to follow the security requirements of the Requesting Party when issuing requests (e.g., minimum communication security requirements, trust anchors).</li>
<li>Register the client at the AS.  This includes making known to the AS which profiles, token_types, and key types (symmetric/asymmetric) the client.</li>
</ul>
<p> </p>
<br> </dd>
<dt>Authorization Server</dt>
<dd style="margin-left: 8">
<ul>
<li>Register the RS and manage corresponding security contexts.</li>
<li>Register clients and authentication credentials.</li>
<li>Allow Resource Owners to configure and update access control policies related to their registered RSs.</li>
<li>Expose the token endpoint to allow  clients to request tokens.</li>
<li>Authenticate clients that wish to request a token.</li>
<li>Process a token request using the authorization policies configured for the RS.</li>
<li>Optionally:  Expose the introspection endpoint that allows RS's to submit token introspection requests.</li>
<li>If providing an introspection endpoint: Authenticate RSs that wish to get an introspection response.</li>
<li>If providing an introspection endpoint: Process token introspection requests.</li>
<li>Optionally: Handle token revocation.</li>
<li>Optionally: Provide discovery metadata. See <a href="#RFC8414" class="xref">[RFC8414]</a>
</li>
<li>Optionally: Handle refresh tokens.</li>
</ul>
<br> </dd>
<dt>Client</dt>
<dd style="margin-left: 8">
<ul>
<li>Discover the AS in charge of the RS that is to be targeted with a request.</li>
<li>Submit the token request (see step (A) of <a href="#fig:protocolFlow" class="xref">Figure 1</a>).  <ul>
<li>Authenticate to the AS.</li>
<li>Optionally (if not pre-configured): Specify which RS, which resource(s), and which action(s) the request(s) will target.</li>
<li>If raw public keys (rpk) or certificates are used, make sure the AS has the right rpk or certificate for this client.</li>
</ul>
<p> </p>
</li>
<li>Process the access token and Access Information (see step (B) of <a href="#fig:protocolFlow" class="xref">Figure 1</a>).  <ul>
<li>Check that the Access Information provides the necessary security parameters (e.g., PoP key, information on communication security protocols supported by the RS).</li>
<li>Safely store the proof-of-possession key.</li>
<li>If provided by the AS: Safely store the refresh token.</li>
</ul>
<p> </p>
</li>
<li>Send the token and request to the RS (see step (C) of <a href="#fig:protocolFlow" class="xref">Figure 1</a>).  <ul>
<li>Authenticate towards the RS (this could coincide with the proof of possession process).</li>
<li>Transmit the token as specified by the AS (default is to the authz-info endpoint, alternative options are specified by profiles).</li>
<li>Perform the proof-of-possession procedure as specified by the profile in use (this may already have been taken care of through the authentication procedure).</li>
</ul>
<p> </p>
</li>
<li>Process the RS response (see step (F) of <a href="#fig:protocolFlow" class="xref">Figure 1</a>) of the RS.</li>
</ul>
<br> </dd>
<dt>Resource Server</dt>
<dd style="margin-left: 8">
<ul>
<li>Expose a way to submit access tokens. By default this is the authz-info endpoint.</li>
<li>Process an access token.  <ul>
<li>Verify the token is from a recognized AS.</li>
<li>Check the token's integrity.</li>
<li>Verify that the token applies to this RS.</li>
<li>Check that the token has not expired (if the token provides expiration information).</li>
<li>Store the token so that it can be retrieved in the context of a matching request.</li>
</ul>
<p> Note: The order proposed here is not normative, any process that arrives at an equivalent result can be used.  A noteworthy consideration is whether one can use cheap operations early on to quickly discard non-applicable or invalid tokens, before performing expensive cryptographic operations (e.g. doing an expiration check before verifying a signature).  </p>
<br> </li>
<li>Process a request.  <ul>
<li>Set up communication security with the client.</li>
<li>Authenticate the client.</li>
<li>Match the client against existing tokens.</li>
<li>Check that tokens belonging to the client actually authorize the requested action.</li>
<li>Optionally: Check that the matching tokens are still valid, using introspection (if this is possible.)</li>
</ul>
<p> </p>
</li>
<li>Send a response following the agreed upon communication security mechanism(s).</li>
<li>Safely store credentials such as raw public keys for authentication or proof-of-possession keys linked to access tokens.</li>
</ul>
<p> </p>
</dd>
</dl>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#app:profileRequirements" id="app:profileRequirements">Requirements on Profiles</a>
</h1>
<p id="rfc.section.C.p.1">This section lists the requirements on profiles of this framework, for the convenience of profile designers.  </p>

<ul>
<li>Optionally define new methods for the client to discover the necessary permissions and AS for accessing a resource, different from the one proposed in <a href="#asDiscovery" class="xref">Section 5.1</a>. <a href="#specs" class="xref">Section 4</a> </li>
<li>Optionally specify new grant types.  <a href="#authorizationGrants" class="xref">Section 5.4</a>
</li>
<li>Optionally define the use of client certificates as client credential type. <a href="#clientCredentials" class="xref">Section 5.5</a>
</li>
<li>Specify the communication protocol the client and RS the must use (e.g., CoAP). <a href="#oauthProfile" class="xref">Section 5</a> and <a href="#paramProfile" class="xref">Section 5.8.4.3</a>
</li>
<li>Specify the security protocol the client and RS must use to protect their communication (e.g., OSCORE or DTLS).  This must provide encryption, integrity and replay protection. <a href="#paramProfile" class="xref">Section 5.8.4.3</a>
</li>
<li>Specify how the client and the RS mutually authenticate. <a href="#specs" class="xref">Section 4</a>
</li>
<li>Specify the proof-of-possession protocol(s) and how to select one, if several are available.  Also specify which key types (e.g., symmetric/asymmetric) are supported by a specific proof-of-possession protocol. <a href="#paramTokenType" class="xref">Section 5.8.4.2</a>
</li>
<li>Specify a unique ace_profile identifier. <a href="#paramProfile" class="xref">Section 5.8.4.3</a>
</li>
<li>If introspection is supported: Specify the communication and security protocol for introspection. <a href="#introspectionEndpoint" class="xref">Section 5.9</a>
</li>
<li>Specify the communication and security protocol for interactions between client and AS. This must provide encryption, integrity protection, replay protection and a binding between requests and responses. <a href="#oauthProfile" class="xref">Section 5</a> and <a href="#tokenEndpoint" class="xref">Section 5.8</a>
</li>
<li>Specify how/if the authz-info endpoint is protected, including how error responses are protected. <a href="#tokenAuthInfoEndpoint" class="xref">Section 5.10.1</a>
</li>
<li>Optionally define other methods of token transport than the authz-info endpoint. <a href="#tokenAuthInfoEndpoint" class="xref">Section 5.10.1</a>
</li>
</ul>

<p> </p>
<h1 id="rfc.appendix.D">
<a href="#rfc.appendix.D">Appendix D.</a> <a href="#app:registration" id="app:registration">Assumptions on AS Knowledge about C and RS</a>
</h1>
<p id="rfc.section.D.p.1">This section lists the assumptions on what an AS should know about a client and an RS in order to be able to respond to requests to the token and introspection endpoints.  How this information is established is out of scope for this document.  </p>

<ul>
<li>The identifier of the client or RS.</li>
<li>The profiles that the client or RS supports.</li>
<li>The scopes that the RS supports.</li>
<li>The audiences that the RS identifies with.</li>
<li>The key types (e.g., pre-shared symmetric key, raw public key, key length, other key parameters) that the client or RS supports.</li>
<li>The types of access tokens the RS supports (e.g., CWT).</li>
<li>If the RS supports CWTs, the COSE parameters for the crypto wrapper (e.g., algorithm, key-wrap algorithm, key-length) that the RS supports.</li>
<li>The expiration time for access tokens issued to this RS (unless the RS accepts a default time chosen by the AS).</li>
<li>The symmetric key shared between client and AS (if any).</li>
<li>The symmetric key shared between RS and AS (if any).</li>
<li>The raw public key of the client or RS (if any).</li>
<li>Whether the RS has synchronized time (and thus is able to use the 'exp' claim) or not.</li>
</ul>

<p> </p>
<h1 id="rfc.appendix.E">
<a href="#rfc.appendix.E">Appendix E.</a> <a href="#app:diffOAuth" id="app:diffOAuth">Differences to OAuth 2.0</a>
</h1>
<p id="rfc.section.E.p.1">This document adapts OAuth 2.0 to be suitable for constrained environments.  This sections lists the main differences from the normative requirements of OAuth 2.0.  </p>

<ul>
<li>Use of TLS -- OAuth 2.0 requires the use of TLS both to protect the communication between AS and client when requesting an access token; between client and RS when accessing a resource and between AS and RS if introspection is used.  This framework requires similar security properties, but does not require that they be realized with TLS.  See <a href="#oauthProfile" class="xref">Section 5</a>.</li>
<li>Cardinality of "grant_type" parameter -- In client-to-AS requests using OAuth 2.0, the "grant_type" parameter is required (per <a href="#RFC6749" class="xref">[RFC6749]</a>).  In this framework, this parameter is optional.  See <a href="#tokenRequest" class="xref">Section 5.8.1</a>.</li>
<li>Encoding of "scope" parameter -- In client-to-AS requests using OAuth 2.0, the "scope" parameter is string encoded (per <a href="#RFC6749" class="xref">[RFC6749]</a>).  In this framework, this parameter may also be encoded as a byte string.  See <a href="#tokenRequest" class="xref">Section 5.8.1</a>.</li>
<li>Cardinality of "token_type" parameter -- in AS-to-client responses using OAuth 2.0, the token_type parameter is required (per <a href="#RFC6749" class="xref">[RFC6749]</a>).  In this framework, this parameter is optional.  See <a href="#tokenResponse" class="xref">Section 5.8.2</a>.</li>
<li>Access token retention -- in OAuth 2.0, the access token may be sent with every request to the RS. The exact use of access tokens depends on the semantics of the application and the session management concept it uses. In this framework, the RS must be able to store these tokens for later use.  See <a href="#tokenAuthInfoEndpoint" class="xref">Section 5.10.1</a>.</li>
</ul>

<p> </p>
<h1 id="rfc.appendix.F">
<a href="#rfc.appendix.F">Appendix F.</a> <a href="#app:options" id="app:options">Deployment Examples</a>
</h1>
<p id="rfc.section.F.p.1">There is a large variety of IoT deployments, as is indicated in <a href="#constraints" class="xref">Appendix A</a>, and this section highlights a few common variants.  This section is not normative but illustrates how the framework can be applied.  </p>
<p id="rfc.section.F.p.2">For each of the deployment variants, there are a number of possible security setups between clients, resource servers and authorization servers.  The main focus in the following subsections is on how authorization of a client request for a resource hosted by an RS is performed.  This requires the security of the requests and responses between the clients and the RS to be considered.  </p>
<p id="rfc.section.F.p.3">Note: CBOR diagnostic notation is used for examples of requests and responses.</p>
<h1 id="rfc.appendix.F.1">
<a href="#rfc.appendix.F.1">F.1.</a> <a href="#localTokenValidation" id="localTokenValidation">Local Token Validation</a>
</h1>
<p id="rfc.section.F.1.p.1">In this scenario, the case where the resource server is offline is considered, i.e., it is not connected to the AS at the time of the access request.  This access procedure involves steps A, B, C, and F of <a href="#fig:protocolFlow" class="xref">Figure 1</a>.  </p>
<p id="rfc.section.F.1.p.2">Since the resource server must be able to verify the access token locally, self-contained access tokens must be used.</p>
<p id="rfc.section.F.1.p.3">This example shows the interactions between a client, the authorization server and a temperature sensor acting as a resource server.  Message exchanges A and B are shown in <a href="#fig:RSOffline" class="xref">Figure 17</a>.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">A: The client first generates a public-private key pair used for communication security with the RS.</dd>
<dt></dt>
<dd style="margin-left: 8">The client sends a CoAP POST request to the token endpoint at the AS.  The security of this request can be transport or application layer. It is up the communication security profile to define. In the example it is assumed that both client and AS have performed mutual authentication e.g. via DTLS.  The request contains the public key of the client and the Audience parameter set to "tempSensorInLivingRoom", a value that the temperature sensor identifies itself with.  The AS evaluates the request and authorizes the client to access the resource.</dd>
<dt></dt>
<dd style="margin-left: 8">B: The AS responds with a 2.05 Content response containing the Access Information, including the access token.  The PoP access token contains the public key of the client, and the Access Information  contains the public key of the RS.  For communication security this example uses DTLS RawPublicKey between the client and the RS. The issued token will have a short validity time, i.e., "exp" close to "iat", in order to mitigate attacks using stolen client credentials.  The token includes the claim such as "scope" with the authorized access that an owner of the temperature device can enjoy.  In this example, the "scope" claim, issued by the AS, informs the RS that the owner of the token, that can prove the possession of a key is authorized to make a GET request against the /temperature resource and a POST request on the /firmware resource.  Note that the syntax and semantics of the scope claim are application specific.</dd>
<dt></dt>
<dd style="margin-left: 8">Note: In this example it is assumed that the client knows what resource it wants to access, and is therefore able to request specific audience and scope claims for the access token.</dd>
</dl>
<div id="rfc.figure.17"></div>
<div id="fig:RSOffline"></div>
<pre>
         Authorization
  Client    Server
    |         |
    |&lt;=======&gt;| DTLS Connection Establishment
    |         |   and mutual authentication
    |         |
A:  +--------&gt;| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"token"
    |         | Content-Format: application/ace+cbor
    |         | Payload: &lt;Request-Payload&gt;
    |         |
B:  |&lt;--------+ Header: 2.05 Content
    |  2.05   | Content-Format: application/ace+cbor
    |         | Payload: &lt;Response-Payload&gt;
    |         |
        </pre>
<p class="figure">Figure 17: Token Request and Response Using Client Credentials.</p>
<p></p>
<div id="rfc.figure.18"></div>
<div id="fig:RSOfflineReq"></div>
<pre>
Request-Payload :
{
  "audience" : "tempSensorInLivingRoom",
  "client_id" : "myclient",
  "req_cnf" : {
    "COSE_Key" : {
      "kid" : b64'1Bg8vub9tLe1gHMzV76e8',
      "kty" : "EC",
      "crv" : "P-256",
      "x" : b64'f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU',
      "y" : b64'x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0'
    }
  }
}

Response-Payload :
{
  "access_token" : b64'0INDoQEKoQVNKkXfb7xaWqMTf6 ...',
  "rs_cnf" : {
    "COSE_Key" : {
      "kid" : b64'c29tZSBwdWJsaWMga2V5IGlk',
      "kty" : "EC",
      "crv" : "P-256",
      "x"   : b64'MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4',
      "y"   : b64'4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM'
    }
  }
}
        </pre>
<p class="figure">Figure 18: Request and Response Payload Details.</p>
<p id="rfc.section.F.1.p.6">The information contained in the Request-Payload and the Response-Payload is shown in <a href="#fig:RSOfflineReq" class="xref">Figure 18</a> Note that the parameter "rs_cnf" from <a href="#I-D.ietf-ace-oauth-params" class="xref">[I-D.ietf-ace-oauth-params]</a> is used to inform the client about the resource server's public key.  </p>
<p id="rfc.section.F.1.p.7">The content of the access token is shown in <a href="#fig:BothcborMappingValueAsymmetricCWT" class="xref">Figure 19</a>.</p>
<div id="rfc.figure.19"></div>
<div id="fig:BothcborMappingValueAsymmetricCWT"></div>
<pre>
{
  "aud" : "tempSensorInLivingRoom",
  "iat" : "1563451500",
  "exp" : "1563453000",
  "scope" :  "temperature_g firmware_p",
  "cnf" : {
    "COSE_Key" : {
      "kid" : b64'1Bg8vub9tLe1gHMzV76e8',
      "kty" : "EC",
      "crv" : "P-256",
      "x" : b64'f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU',
      "y" : b64'x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0'
    }
  }
}
        </pre>
<p class="figure">Figure 19: Access Token including Public Key of the client.</p>
<p></p>
<div id="rfc.figure.20"></div>
<div id="fig:RSOfflinePostAccessTokenAsymmetric"></div>
<pre>
           Resource
 Client     Server
    |         |
C:  +--------&gt;| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"authz-info"
    |         | Payload: 0INDoQEKoQVN ...
    |         |
    |&lt;--------+ Header: 2.04 Changed
    |  2.04   |
    |         |
</pre>
<p class="figure">Figure 20: Access Token provisioning to RS</p>
<p id="rfc.section.F.1.p.9">Messages C and F are shown in <a href="#fig:RSOfflinePostAccessTokenAsymmetric" class="xref">Figure 20</a> - <a href="#fig:RSOfflineDTLSRequestAndResponse" class="xref">Figure 21</a>.  </p>

<dl>
<dt></dt>
<dd style="margin-left: 8">C: The client then sends the PoP access token to the authz-info endpoint at the RS.  This is a plain CoAP POST request, i.e., no transport or application-layer security is used between client and RS since the token is integrity protected between the AS and RS.  The RS verifies that the PoP access token was created by a known and trusted AS, that it applies to this RS, and that it is valid.  The RS caches the security context together with authorization information about this client contained in the PoP access token.</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt></dt>
<dd style="margin-left: 8">The client and the RS runs the DTLS handshake using the raw public keys established in step B and C.</dd>
<dt></dt>
<dd style="margin-left: 8">The client sends a CoAP GET request to /temperature on RS over DTLS.  The RS verifies that the request is authorized, based on previously established security context.</dd>
<dt></dt>
<dd style="margin-left: 8">F: The RS responds over the same DTLS channel with a CoAP 2.05 Content response, containing a resource representation as payload.</dd>
</dl>
<div id="rfc.figure.21"></div>
<div id="fig:RSOfflineDTLSRequestAndResponse"></div>
<pre>
           Resource
 Client     Server
    |         |
    |&lt;=======&gt;| DTLS Connection Establishment
    |         |   using Raw Public Keys
    |         |
    +--------&gt;| Header: GET (Code=0.01)
    | GET     | Uri-Path: "temperature"
    |         |
    |         |
    |         |
F:  |&lt;--------+ Header: 2.05 Content
    | 2.05    | Payload: &lt;sensor value&gt;
    |         |
      </pre>
<p class="figure">Figure 21: Resource Request and Response protected by DTLS.</p>
<p></p>
<h1 id="rfc.appendix.F.2">
<a href="#rfc.appendix.F.2">F.2.</a> <a href="#introspectionAidedTokenValidation" id="introspectionAidedTokenValidation">Introspection Aided Token Validation</a>
</h1>
<p id="rfc.section.F.2.p.1">In this deployment scenario it is assumed that a client is not able to access the AS at the time of the access request, whereas the RS is assumed to be connected to the back-end infrastructure. Thus the RS can make use of token introspection.  This access procedure involves steps A-F of <a href="#fig:protocolFlow" class="xref">Figure 1</a>, but assumes steps A and B have been carried out during a phase when the client had connectivity to AS.  </p>
<p id="rfc.section.F.2.p.2">Since the client is assumed to be offline, at least for a certain period of time, a pre-provisioned access token has to be long-lived.  Since the client is constrained, the token will not be self contained (i.e. not a CWT) but instead just a reference.  The resource server uses its connectivity to learn about the claims associated to the access token by using introspection, which is shown in the example below.</p>
<p id="rfc.section.F.2.p.3">In the example interactions between an offline client (key fob), an RS (online lock), and an AS is shown.  It is assumed that there is a provisioning step where the client has access to the AS.  This corresponds to message exchanges A and B which are shown in <a href="#fig:cOffline" class="xref">Figure 22</a>.  </p>
<p id="rfc.section.F.2.p.4">Authorization consent from the resource owner can be pre-configured, but it can also be provided via an interactive flow with the resource owner.  An example of this for the key fob case could be that the resource owner has a connected car, he buys a generic key that he wants to use with the car.  To authorize the key fob he connects it to his computer that then provides the UI for the device.  After that OAuth 2.0 implicit flow can used to authorize the key for his car at the car manufacturers AS.</p>
<p id="rfc.section.F.2.p.5">Note: In this example the client does not know the exact door it will be used to access since the token request is not send at the time of access. So the scope and audience parameters are set quite wide to start with, while tailored values narrowing down the claims to the specific RS being accessed can be provided to that RS during an introspection step.</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">A: The client sends a CoAP POST request to the token endpoint at AS.  The request contains the Audience parameter set to  "PACS1337" (PACS, Physical Access System), a value the that identifies the physical access control system to which the individual doors are connected.  The AS generates an access token as	an opaque string, which it can match to the specific client and the targeted audience. It furthermore generates a symmetric proof-of-possession key. The communication security and authentication between client and AS is assumed to have been	provided at transport layer (e.g. via DTLS) using a pre-shared security context (psk, rpk or certificate).</dd>
<dt></dt>
<dd style="margin-left: 8">B: The AS responds with a CoAP 2.05 Content response, containing as payload the Access Information, including the access token and the symmetric proof-of-possession key.  Communication security between C and RS will be DTLS and PreSharedKey.  The PoP key is used as the PreSharedKey.  </dd>
</dl>

<p> </p>
<p id="rfc.section.F.2.p.7">Note: In this example we are using a symmetric key for a multi-RS audience, which is not recommended normally (see <a href="#audience" class="xref">Section 6.9</a>).  However in this case the risk is deemed to be acceptable, since all the doors are part of the same physical access control system, and therefore the risk of a malicious RS impersonating the client towards another RS is low.</p>
<div id="rfc.figure.22"></div>
<div id="fig:cOffline"></div>
<pre>

         Authorization
 Client     Server
    |         |
    |&lt;=======&gt;| DTLS Connection Establishment
    |         |   and mutual authentication
    |         |
A:  +--------&gt;| Header: POST (Code=0.02)
    |  POST   | Uri-Path:"token"
    |         | Content-Format: application/ace+cbor
    |         | Payload: &lt;Request-Payload&gt;
    |         |
B:  |&lt;--------+ Header: 2.05 Content
    |         | Content-Format: application/ace+cbor
    |  2.05   | Payload: &lt;Response-Payload&gt;
    |         |
    </pre>
<p class="figure">Figure 22: Token Request and Response using Client Credentials.</p>
<p></p>
<div id="rfc.figure.23"></div>
<div id="fig:cOfflineReq"></div>
<pre>
Request-Payload:
{
  "client_id" : "keyfob",
  "audience" : "PACS1337"
}

Response-Payload:
{
  "access_token" : b64'VGVzdCB0b2tlbg==',
  "cnf" : {
    "COSE_Key" : {
      "kid" : b64'c29tZSBwdWJsaWMga2V5IGlk',
      "kty" : "oct",
      "alg" : "HS256",
      "k": b64'ZoRSOrFzN_FzUA5XKMYoVHyzff5oRJxl-IXRtztJ6uE'
    }
  }
}
      </pre>
<p class="figure">Figure 23: Request and Response Payload for C offline</p>
<p id="rfc.section.F.2.p.9">The information contained in the Request-Payload and the Response-Payload is shown in <a href="#fig:cOfflineReq" class="xref">Figure 23</a>.  </p>
<p id="rfc.section.F.2.p.10">The access token in this case is just an opaque byte string referencing the authorization information at the AS.</p>
<div id="rfc.figure.24"></div>
<div id="fig:cOfflineIntrospection"></div>
<pre>
           Resource
  Client    Server
    |         |
C:  +--------&gt;| Header: POST (T=CON, Code=0.02)
    |  POST   | Uri-Path:"authz-info"
    |         | Payload: b64'VGVzdCB0b2tlbg=='
    |         |
    |         |     Authorization
    |         |       Server
    |         |          |
    |      D: +---------&gt;| Header: POST (Code=0.02)
    |         |  POST    | Uri-Path: "introspect"
    |         |          | Content-Format: "application/ace+cbor"
    |         |          | Payload: &lt;Request-Payload&gt;
    |         |          |
    |      E: |&lt;---------+ Header: 2.05 Content
    |         |  2.05    | Content-Format: "application/ace+cbor"
    |         |          | Payload: &lt;Response-Payload&gt;
    |         |          |
    |         |
    |&lt;--------+ Header: 2.01 Created
    |  2.01   |
    |         |
</pre>
<p class="figure">Figure 24: Token Introspection for C offline</p>
<div id="rfc.figure.25"></div>
<div id="fig:cOfflineIntroReq"></div>
<pre>
Request-Payload:
{
  "token" : b64'VGVzdCB0b2tlbg==',
  "client_id" : "FrontDoor",
}

Response-Payload:
{
  "active" : true,
  "aud" : "lockOfDoor4711",
  "scope" : "open, close",
  "iat" : 1563454000,
  "cnf" : {
    "kid" : b64'c29tZSBwdWJsaWMga2V5IGlk'
  }
}
          </pre>
<p class="figure">Figure 25: Request and Response Payload for Introspection</p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">C: Next, the client POSTs the access token to the authz-info endpoint in the RS.  This is a plain CoAP request, i.e., no DTLS between client and RS.  Since the token is an opaque string, the RS cannot verify it on its own, and thus defers to respond the client with a status code until after step E.</dd>
<dt></dt>
<dd style="margin-left: 8">D: The RS sends the token to the introspection endpoint on the AS using a CoAP POST request.  In this example RS and AS are assumed to have performed mutual authentication using a pre shared security context (psk, rpk or certificate) with the RS acting as DTLS client.  </dd>
<dt></dt>
<dd style="margin-left: 8">E: The AS provides the introspection response (2.05 Content) containing parameters about the token.  This includes the confirmation key (cnf) parameter that allows the RS to verify the client's proof of possession in step F. Note that our example in <a href="#fig:cOfflineIntroReq" class="xref">Figure 25</a>	assumes a pre-established key (e.g. one used by the client and the RS for a previous token) that is now only referenced by its key-identifier 'kid'.  </dd>
<dt></dt>
<dd style="margin-left: 8">After receiving message E, the RS responds to the client's POST in step C with the CoAP response code 2.01 (Created).</dd>
<dt></dt>
<dd style="margin-left: 8"></dd>
<dt></dt>
<dd style="margin-left: 8">The information contained in the Request-Payload and the Response-Payload is shown in <a href="#fig:cOfflineIntroReq" class="xref">Figure 25</a>.  </dd>
</dl>

<p> </p>
<p></p>

<dl>
<dt></dt>
<dd style="margin-left: 8">The client uses the symmetric PoP key to establish a DTLS PreSharedKey secure connection to the RS. The CoAP request PUT is sent to the uri-path /state on the RS, changing the state of the door to locked.  </dd>
<dt></dt>
<dd style="margin-left: 8">F: The RS responds with a appropriate over the secure DTLS channel.  </dd>
</dl>

<p> </p>
<div id="rfc.figure.26"></div>
<div id="fig:cOfflineDTLSRequestAndResponse"></div>
<pre>
           Resource
  Client    Server
    |         |
    |&lt;=======&gt;| DTLS Connection Establishment
    |         |   using Pre Shared Key
    |         |
    +--------&gt;| Header: PUT (Code=0.03)
    | PUT     | Uri-Path: "state"
    |         | Payload: &lt;new state for the lock&gt;
    |         |
F:  |&lt;--------+ Header: 2.04 Changed
    | 2.04    | Payload: &lt;new state for the lock&gt;
    |         |
            </pre>
<p class="figure">Figure 26: Resource request and response protected by OSCORE</p>
<p></p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ludwig Seitz</span> 
	  <span class="n hidden">
		<span class="family-name">Seitz</span>
	  </span>
	</span>
	<span class="org vcardline">Combitech</span>
	<span class="adr">
	  <span class="vcardline">Dj&#228;knegatan 31</span>

	  <span class="vcardline">
		<span class="locality">Malm&#246;</span>,  
		<span class="region"></span>
		<span class="code">211 35</span>
	  </span>
	  <span class="country-name vcardline">Sweden</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ludwig.seitz@combitech.com">ludwig.seitz@combitech.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Goeran Selander</span> 
	  <span class="n hidden">
		<span class="family-name">Selander</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson</span>
	<span class="adr">
	  <span class="vcardline">Faroegatan 6</span>

	  <span class="vcardline">
		<span class="locality">Kista</span>,  
		<span class="region"></span>
		<span class="code">164 80</span>
	  </span>
	  <span class="country-name vcardline">Sweden</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:goran.selander@ericsson.com">goran.selander@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Erik Wahlstroem</span> 
	  <span class="n hidden">
		<span class="family-name">Wahlstroem</span>
	  </span>
	</span>
	<span class="org vcardline"></span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline">Sweden</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:erik@wahlstromstekniska.se">erik@wahlstromstekniska.se</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Samuel Erdtman</span> 
	  <span class="n hidden">
		<span class="family-name">Erdtman</span>
	  </span>
	</span>
	<span class="org vcardline">Spotify AB</span>
	<span class="adr">
	  <span class="vcardline">Birger Jarlsgatan 61, 4tr</span>

	  <span class="vcardline">
		<span class="locality">Stockholm</span>,  
		<span class="region"></span>
		<span class="code">113 56</span>
	  </span>
	  <span class="country-name vcardline">Sweden</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:erdtman@spotify.com">erdtman@spotify.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Hannes Tschofenig</span> 
	  <span class="n hidden">
		<span class="family-name">Tschofenig</span>
	  </span>
	</span>
	<span class="org vcardline">Arm Ltd.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Absam</span>,  
		<span class="region"></span>
		<span class="code">6067</span>
	  </span>
	  <span class="country-name vcardline">Austria</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:Hannes.Tschofenig@arm.com">Hannes.Tschofenig@arm.com</a></span>

  </address>
</div>

</body>
</html>
